<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Andrewsy&#39;s Space</title>
  
  
  <link href="https://stonefishy.github.io/atom.xml" rel="self"/>
  
  <link href="https://stonefishy.github.io/"/>
  <updated>2023-09-23T16:03:49.013Z</updated>
  <id>https://stonefishy.github.io/</id>
  
  <author>
    <name>Andrewsy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>What is Bixby Capsule？How to develop it?</title>
    <link href="https://stonefishy.github.io/2023/09/10/what-is-bixby-capsule/"/>
    <id>https://stonefishy.github.io/2023/09/10/what-is-bixby-capsule/</id>
    <published>2023-09-10T20:24:58.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/assets/images/bixby/bixby.webp" class="lazyload placeholder" data-srcset="/assets/images/bixby/bixby.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Bixby Capsule"></p><h2 class="bamboo-h " id="导言apeg77czxgk">导言</h2><br/><p>在今天的数字时代，虚拟助手已经成为我们日常生活的一部分。Bixby，三星电子开发的人工智能助手，是其中一个备受欢迎的助手之一。<code>Bixby Capsule</code> 是扩展 Bixby 功能的关键组成部分，本文将介绍什么是 Bixby Capsule、它的工作原理以及如何开发自己的 Capsule。</p><h2 class="bamboo-h " id="什么是 Bixby Capsule？1wxg5nkcq7z">什么是 Bixby Capsule？</h2><br/><p>Bixby Capsule 是一个为 Bixby 助手创建自定义功能和技能的容器。它允许开发者创建、部署和共享特定领域的虚拟助手应用程序，使用户能够通过语音和文本与虚拟助手进行交互。Capsule 的核心目标是扩展 Bixby 的能力，使其能够执行特定领域的任务，如设定闹钟、预订餐厅、查询天气、播放音乐等。</p><h2 class="bamboo-h " id="Bixby Capsule 的工作原理2ze9p2ybbyg">Bixby Capsule 的工作原理</h2><br/><p>了解 Bixby Capsule 的工作原理对于开发者非常重要。下面是 Bixby Capsule 的工作原理的简要概述：</p><p><strong>语音输入或文本输入</strong>：<br>用户通过语音或文本与 Bixby 进行交互，提出请求或问题。</p><p><strong>语音识别和自然语言处理</strong>：<br>Bixby 使用语音识别技术将用户的语音转化为文本，然后使用自然语言处理（NLP）技术理解用户的意图和需求。</p><p><strong>Capsule 匹配</strong>：<br>Bixby 确定用户的请求与哪个 Capsule 最匹配，这是通过匹配用户的意图与 Capsule 的功能来实现的。</p><p><strong>Capsule 交互</strong>：<br>一旦确定了匹配的 Capsule，Bixby 与该 Capsule 进行交互，将用户的请求传递给 Capsule。</p><p><strong>Capsule 执行</strong>：<br>Capsule 接收用户的请求并执行相关操作，可能需要与外部数据源或服务进行交互以获取信息或执行任务。</p><p><strong>响应用户</strong>：<br>Capsule 返回结果给 Bixby，然后 Bixby 将结果呈现给用户，通常以语音或文本形式。</p><h2 class="bamboo-h " id="如何开发 Bixby Capsule？j8zj9xccx7">如何开发 Bixby Capsule？</h2><br/><p>现在让我们来看看如何开发自己的 Bixby Capsule。以下是一个简要的步骤：</p><h3 id="步骤-1：准备开发环境"><a href="#步骤-1：准备开发环境" class="headerlink" title="步骤 1：准备开发环境"></a>步骤 1：准备开发环境</h3><p>在开始开发之前，您需要准备好开发环境。这包括以下步骤：</p><h4 id="1-1-安装-Bixby-开发工具"><a href="#1-1-安装-Bixby-开发工具" class="headerlink" title="1.1 安装 Bixby 开发工具"></a>1.1 安装 Bixby 开发工具</h4><p>Bixby 开发工具包括 Bixby IDE（集成开发环境）和 Bixby CLI（命令行工具）。可以从 Bixby Developer Center 的官方网站上下载和安装这些工具。确保您的开发环境设置正确。</p><h4 id="1-2-注册-Bixby-开发者账户"><a href="#1-2-注册-Bixby-开发者账户" class="headerlink" title="1.2 注册 Bixby 开发者账户"></a>1.2 注册 Bixby 开发者账户</h4><p>在开始之前，您需要在 Bixby Developer Center 上注册一个开发者账户。这个账户将用于创建、管理和部署 Capsules。</p><h3 id="步骤-2：创建-Capsule"><a href="#步骤-2：创建-Capsule" class="headerlink" title="步骤 2：创建 Capsule"></a>步骤 2：创建 Capsule</h3><p>现在，让我们创建一个新的 Capsule：</p><h4 id="2-1-使用-Bixby-IDE-创建-Capsule"><a href="#2-1-使用-Bixby-IDE-创建-Capsule" class="headerlink" title="2.1 使用 Bixby IDE 创建 Capsule"></a>2.1 使用 Bixby IDE 创建 Capsule</h4><ol><li>打开 Bixby IDE。</li><li>在 IDE 中选择 “File” &gt; “New” &gt; “Bixby Capsule”。</li><li>输入 Capsule 的名称和描述，并选择 Capsule 的类型（例如，”自定义” 或 “Smart Speaker”）。</li><li>点击 “Create” 按钮。</li></ol><h4 id="2-2-定义结构、概念和操作"><a href="#2-2-定义结构、概念和操作" class="headerlink" title="2.2 定义结构、概念和操作"></a>2.2 定义结构、概念和操作</h4><p>在 Capsule 中，您可以定义结构（Structures）、概念（Concepts）和操作（Actions）来表示您的数据和功能：</p><ol><li>在 IDE 中，导航到 models 目录，然后创建一个新的 .bxb 文件。</li><li>在文件中，您可以开始定义结构、概念和操作。例如：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">integer (NumDiceConcept) &#123;</span><br><span class="line">  description (The number of dice to throw.)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">structure (RollResultConcept) &#123;</span><br><span class="line">  description (The result object produced by the RollDice action.)</span><br><span class="line">  property (sum) &#123;</span><br><span class="line">    type (SumConcept)</span><br><span class="line">    min (Required)</span><br><span class="line">    max (One)</span><br><span class="line">  &#125;</span><br><span class="line">  property (roll) &#123;</span><br><span class="line">    description (The list of results for each dice roll.)</span><br><span class="line">    type (RollConcept)</span><br><span class="line">    min (Required)</span><br><span class="line">    max (Many)</span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">action (RollDice) &#123;</span><br><span class="line">  collect&#123;</span><br><span class="line">    input (numDice) &#123;</span><br><span class="line">      type (NumDiceConcept)</span><br><span class="line">      min (Required)</span><br><span class="line">      max (One)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input (numSides) &#123;</span><br><span class="line">      type (NumSidesConcept)</span><br><span class="line">      min (Required)</span><br><span class="line">      max (One)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  output (RollResultConcept)</span><br><span class="line">  type (Calculation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="步骤-3：设计对话"><a href="#步骤-3：设计对话" class="headerlink" title="步骤 3：设计对话"></a>步骤 3：设计对话</h3><p>使用 Bixby IDE 的对话工具，您可以设计用户与 Capsule 的对话：</p><h4 id="3-1-创建对话文件"><a href="#3-1-创建对话文件" class="headerlink" title="3.1 创建对话文件"></a>3.1 创建对话文件</h4><ol><li>在 IDE 中，导航到 resources&#x2F;dialogs 目录。</li><li>创建一个新的 .dialog 文件，为您的 Capsule 定义一个对话。</li></ol><h4 id="3-2-定义用户输入和回复"><a href="#3-2-定义用户输入和回复" class="headerlink" title="3.2 定义用户输入和回复"></a>3.2 定义用户输入和回复</h4><p>在对话文件中，定义用户输入示例和 Capsule 的回复示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dialog (Result) &#123;</span><br><span class="line">  match &#123;</span><br><span class="line">    BusinessCategory (this) &#123;</span><br><span class="line">      from-property: Business (business)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  template(&quot;#&#123;value(business.name)&#125; has #&#123;joinAs(&#x27;value&#x27;, this)&#125;.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤-4：测试和调试-Capsule"><a href="#步骤-4：测试和调试-Capsule" class="headerlink" title="步骤 4：测试和调试 Capsule"></a>步骤 4：测试和调试 Capsule</h3><p>在部署之前，确保您对 Capsule 进行了测试和调试：</p><h4 id="4-1-使用模拟器测试"><a href="#4-1-使用模拟器测试" class="headerlink" title="4.1 使用模拟器测试"></a>4.1 使用模拟器测试</h4><p>在 Bixby IDE 中，使用模拟器来模拟用户与 Capsule 的对话，以确保一切正常工作。检查回复是否符合预期。</p><h4 id="4-2-调试"><a href="#4-2-调试" class="headerlink" title="4.2 调试"></a>4.2 调试</h4><p>使用 Bixby IDE 的调试工具来查找和修复潜在问题。您可以设置断点、查看变量的值，并进行单步调试以确保 Capsule 的行为正确。</p><h3 id="步骤-5：部署-Capsule"><a href="#步骤-5：部署-Capsule" class="headerlink" title="步骤 5：部署 Capsule"></a>步骤 5：部署 Capsule</h3><p>一旦您对 Capsule 满意并通过了测试，就可以开始部署它：</p><h4 id="5-1-创建开发版本"><a href="#5-1-创建开发版本" class="headerlink" title="5.1 创建开发版本"></a>5.1 创建开发版本</h4><p>在 Bixby IDE 中，您可以创建一个开发版本的 Capsule，这个版本可以在您的开发环境中使用：</p><ol><li>选择 “Build” &gt; “Create Development Version”。</li><li>确认创建版本并等待完成。</li></ol><h4 id="5-2-提交审核"><a href="#5-2-提交审核" class="headerlink" title="5.2 提交审核"></a>5.2 提交审核</h4><p>如果您计划将 Capsule 分享给其他人或发布到 Bixby Marketplace，您需要提交审核请求：</p><ol><li>在 Bixby Developer Center 上登录。</li><li>在开发者中心中，选择您的 Capsule 项目，然后提交审核请求。</li></ol><h3 id="步骤-6：发布和分享"><a href="#步骤-6：发布和分享" class="headerlink" title="步骤 6：发布和分享"></a>步骤 6：发布和分享</h3><p>一旦审核通过，您可以将 Capsule 发布并分享给其他用户：</p><h4 id="6-1-发布"><a href="#6-1-发布" class="headerlink" title="6.1 发布"></a>6.1 发布</h4><ol><li>在 Bixby Developer Center 上，选择 “发布” 选项。</li><li>输入有关 Capsule 的详细信息，包括名称、描述和图标。</li><li>发布您的 Capsule。</li></ol><h4 id="6-2-分享"><a href="#6-2-分享" class="headerlink" title="6.2 分享"></a>6.2 分享</h4><p>您可以分享您的 Capsule 的链接给其他用户，或者在 Bixby Marketplace 上找到它</p><h2 class="bamboo-h " id="结论2k1xuk2zexw">结论</h2><br/><p>Bixby Capsule 是一个强大的工具，可以帮助开发者创建自定义虚拟助手应用程序，提供各种功能和技能。了解其工作原理以及按照上述步骤进行开发，将使您能够构建出令人印象深刻的 Bixby Capsules，改善用户体验，扩展 Bixby 的功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/assets/images/bixby/bixby.webp&quot; class=&quot;lazyload placeholder&quot; data-srcset=&quot;/assets/images/bixby/bixby.webp&quot; srcset=&quot;https://pic</summary>
      
    
    
    
    <category term="AI" scheme="https://stonefishy.github.io/categories/AI/"/>
    
    
    <category term="AI" scheme="https://stonefishy.github.io/tags/AI/"/>
    
    <category term="Bixby" scheme="https://stonefishy.github.io/tags/Bixby/"/>
    
  </entry>
  
  <entry>
    <title>AWS Glue DataBrew - 简化数据准备的利器</title>
    <link href="https://stonefishy.github.io/2023/09/05/aws-glue-databrew-data-preparation-tool/"/>
    <id>https://stonefishy.github.io/2023/09/05/aws-glue-databrew-data-preparation-tool/</id>
    <published>2023-09-05T23:21:33.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p>数据准备是数据分析和机器学习的关键步骤之一。<code>AWS Glue DataBrew</code> 是 Amazon Web Services（AWS）提供的一项强大工具，旨在帮助数据工程师、数据分析师和数据科学家轻松地准备数据以进行分析、报告和机器学习。本文将深入探讨 AWS Glue DataBrew 的特点、优势、使用场景和如何入门。<br><img src="/assets/images/aws/aws-glue-databrew.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-glue-databrew.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS Glue DataBrew"></p><h2 class="bamboo-h " id="AWS Glue DataBrew 简介1kcrsyun059">AWS Glue DataBrew 简介</h2><br/><p>AWS Glue DataBrew 是一项全托管的数据准备服务，它通过可视化界面和自动化工具简化了数据清理、转换和准备的过程。以下是 AWS Glue DataBrew 的一些关键特点：</p><h4 id="可视化数据准备"><a href="#可视化数据准备" class="headerlink" title="可视化数据准备"></a>可视化数据准备</h4><p>DataBrew 提供了直观的用户界面，使用户能够轻松地探索、清理和转换数据，而无需编写复杂的代码。</p><h4 id="数据探索"><a href="#数据探索" class="headerlink" title="数据探索"></a>数据探索</h4><p>您可以通过数据探索功能快速了解数据的结构、内容和质量，以便更好地理解数据。</p><h4 id="自动数据规范化"><a href="#自动数据规范化" class="headerlink" title="自动数据规范化"></a>自动数据规范化</h4><p>DataBrew 自动检测数据类型和结构，并提供数据规范化建议，以确保数据在分析过程中的一致性。</p><h4 id="多源数据支持"><a href="#多源数据支持" class="headerlink" title="多源数据支持"></a>多源数据支持</h4><p>DataBrew 可以连接到多种数据源，包括数据湖、数据仓库、数据库、云存储和 API。</p><h4 id="数据转换和清洗"><a href="#数据转换和清洗" class="headerlink" title="数据转换和清洗"></a>数据转换和清洗</h4><p>您可以使用 DataBrew 进行各种数据转换和清洗操作，如删除重复数据、填充缺失值、合并列等。</p><h4 id="工作流程自动化"><a href="#工作流程自动化" class="headerlink" title="工作流程自动化"></a>工作流程自动化</h4><p>DataBrew 支持创建数据准备工作流程，以自动执行多个数据准备任务，提高效率。</p><h4 id="数据监控和审计"><a href="#数据监控和审计" class="headerlink" title="数据监控和审计"></a>数据监控和审计</h4><p>DataBrew 提供数据监控和审计功能，以跟踪数据准备操作，确保数据质量和安全性。</p><h2 class="bamboo-h " id="AWS Glue DataBrew 的优势2k9qsul198a">AWS Glue DataBrew 的优势</h2><br/><p>为什么要选择 AWS Glue DataBrew 作为数据准备工具？以下是它的一些显著优势：</p><h4 id="降低技术门槛"><a href="#降低技术门槛" class="headerlink" title="降低技术门槛"></a>降低技术门槛</h4><p>DataBrew 的可视化界面使数据准备过程对于不擅长编程的用户也变得更加可行，降低了技术门槛。</p><h4 id="节省时间"><a href="#节省时间" class="headerlink" title="节省时间"></a>节省时间</h4><p>自动化功能和预建的数据转换操作可以大幅节省数据准备的时间，使用户能够更快地获得洞察。</p><h4 id="改进数据质量"><a href="#改进数据质量" class="headerlink" title="改进数据质量"></a>改进数据质量</h4><p>DataBrew 的数据探索和质量评估工具有助于发现和解决数据质量问题，提高数据分析的可靠性。</p><h4 id="与-AWS-生态系统集成"><a href="#与-AWS-生态系统集成" class="headerlink" title="与 AWS 生态系统集成"></a>与 AWS 生态系统集成</h4><p>DataBrew 与其他 AWS 服务集成，可无缝集成到您的数据工作流程中，如 AWS Glue、S3、Redshift 等。</p><h2 class="bamboo-h " id="AWS Glue DataBrew 的使用场景1pi1y1gidsc">AWS Glue DataBrew 的使用场景</h2><br/><p>AWS Glue DataBrew 适用于多种使用场景，包括但不限于：</p><h4 id="数据清理和规范化"><a href="#数据清理和规范化" class="headerlink" title="数据清理和规范化"></a>数据清理和规范化</h4><p>将原始数据清理并规范化，以便进行分析和报告。</p><h4 id="数据探索和可视化"><a href="#数据探索和可视化" class="headerlink" title="数据探索和可视化"></a>数据探索和可视化</h4><p>通过数据探索功能可视化数据，以便更好地了解数据的特点。</p><h4 id="缺失数据处理"><a href="#缺失数据处理" class="headerlink" title="缺失数据处理"></a>缺失数据处理</h4><p>填充缺失数据或识别缺失数据的模式。</p><h4 id="数据合并和分割"><a href="#数据合并和分割" class="headerlink" title="数据合并和分割"></a>数据合并和分割</h4><p>合并不同来源的数据或拆分包含多个值的列。</p><h4 id="数据质量监控"><a href="#数据质量监控" class="headerlink" title="数据质量监控"></a>数据质量监控</h4><p>持续监控数据质量，以及时发现问题并采取纠正措施。</p><h2 class="bamboo-h " id="入门 AWS Glue DataBrewdmxeqm73jug">入门 AWS Glue DataBrew</h2><br/><p>要开始使用 AWS Glue DataBrew，您可以按照以下步骤操作：</p><ol><li>登录 AWS 控制台：使用您的 AWS 帐户登录 AWS 管理控制台。</li><li>导航到 AWS Glue DataBrew：在 AWS 控制台中，导航到 DataBrew 服务页面。</li><li>创建项目：创建一个新项目或选择现有项目，以开始数据准备工作。</li><li>导入数据：将您要准备的数据导入项目。</li><li>使用 DataBrew：在 DataBrew 的可视化界面中探索、清理和转换数据。</li><li>保存和导出数据：完成数据准备后，您可以将数据保存并导出到其他 AWS 服务或应用程序中。</li></ol><h2 class="bamboo-h " id="总结zi99078v5p">总结</h2><br/><p>AWS Glue DataBrew 是一项强大的数据准备工具，它通过可视化界面和自动化功能使数据准备变得更加容易和高效。无论您是数据工程师、数据分析师还是数据科学家，DataBrew 都可以帮助您加速数据分析的过程，从原始数据中提取有价值的信息。开始使用 DataBrew，并体验数据准备的全新方式！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数据准备是数据分析和机器学习的关键步骤之一。&lt;code&gt;AWS Glue DataBrew&lt;/code&gt; 是 Amazon Web Services（AWS）提供的一项强大工具，旨在帮助数据工程师、数据分析师和数据科学家轻松地准备数据以进行分析、报告和机器学习。本文将深入探</summary>
      
    
    
    
    <category term="大数据" scheme="https://stonefishy.github.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
    <category term="大数据" scheme="https://stonefishy.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>AWS Auto Scaling Group - 实现弹性自动扩展的技术指南</title>
    <link href="https://stonefishy.github.io/2022/11/15/aws-auto-scaling-group/"/>
    <id>https://stonefishy.github.io/2022/11/15/aws-auto-scaling-group/</id>
    <published>2022-11-15T22:27:54.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p>在云计算领域，弹性自动扩展是确保应用程序高可用性和性能的关键组成部分。<code>AWS Auto Scaling Group（ASG）</code>是Amazon Web Services（AWS）提供的一项强大服务，可帮助您自动扩展和管理应用程序的资源，以适应不断变化的工作负载需求。本文将深入探讨AWS Auto Scaling Group的技术细节，包括其核心概念、配置选项、最佳实践和实际应用场景。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="/assets/images/aws/aws-asg-capacity.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-asg-capacity.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS Auto Scaling Group" style="width:600px;"/></div><span class="image-caption">AWS Auto Scaling Group</span></div><h3 id="理解-AWS-Auto-Scaling-Group（ASG）"><a href="#理解-AWS-Auto-Scaling-Group（ASG）" class="headerlink" title="理解 AWS Auto Scaling Group（ASG）"></a>理解 AWS Auto Scaling Group（ASG）</h3><ul><li><strong>什么是Auto Scaling Group？</strong></li></ul><p>AWS Auto Scaling Group（ASG）是一项AWS服务，允许您自动增加或减少应用程序实例的数量，以满足流量波动。ASG基于一组规则来动态调整实例的数量，确保应用程序具有所需的容量，并提供高可用性。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="/assets/images/aws/aws-asg-elb.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-asg-elb.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Auto Scaling Group in AWS with Load Balancer" style="width:600px;"/></div><span class="image-caption">Auto Scaling Group in AWS with Load Balancer</span></div><ul><li><strong>ASG的工作原理</strong></li></ul><p>ASG通过监控配置的指标，例如CPU利用率或请求率，来确定是否需要调整实例数量。它可以自动启动新实例以应对高负载，或者停止不再需要的实例以节省成本。</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="/assets/images/aws/aws-asg-cloudwatch.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-asg-cloudwatch.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Auto Scaling in AWS with Cloud Watch Alarm" style="width:600px;"/></div><span class="image-caption">Auto Scaling in AWS with Cloud Watch Alarm</span></div><ul><li><strong>ASG的优势</strong></li></ul><p>ASG的优势包括自动化扩展、高可用性、成本效益以及应对不断变化的需求。它可以确保应用程序始终具备所需的性能，并且无需手动干预。</p><h3 id="Auto-Scaling-Group的关键组件"><a href="#Auto-Scaling-Group的关键组件" class="headerlink" title="Auto Scaling Group的关键组件"></a>Auto Scaling Group的关键组件</h3><ul><li><strong>启动配置（Launch Configuration）</strong></li></ul><p>启动配置定义了ASG启动新实例时使用的AMI、实例类型、安全组等参数。它充当了创建实例的蓝图。</p><ul><li><strong>自动扩展策略（Auto Scaling Policies）</strong></li></ul><p>自动扩展策略是ASG的核心。它们定义了何时以及如何扩展或缩减实例数量，基于监控指标和阈值的触发条件。</p><ul><li><strong>健康检查（Health Checks）</strong></li></ul><p>健康检查用于监控实例的健康状态。ASG可以自动替换失败或不健康的实例，确保应用程序的稳定性。</p><h3 id="Auto-Scaling-Group的配置选项"><a href="#Auto-Scaling-Group的配置选项" class="headerlink" title="Auto Scaling Group的配置选项"></a>Auto Scaling Group的配置选项</h3><ul><li><strong>期望容量与最小&#x2F;最大大小</strong></li></ul><p>期望容量是您希望ASG维护的实例数量，而最小和最大大小则定义了ASG可以自动扩展或缩减的范围。</p><ul><li><strong>使用负载均衡器</strong></li></ul><p>如果您使用负载均衡器（如AWS ELB），ASG可以与之集成，确保新实例被平衡地分配到负载均衡器后端。</p><ul><li><strong>实例类型与AMI选择</strong></li></ul><p>选择适当的实例类型和AMI对性能和成本至关重要。ASG允许您在启动配置中定义这些选项，以便根据需求选择。</p><ul><li><strong>自动扩展策略：手动、定时和动态</strong></li></ul><p>ASG支持多种自动扩展策略。您可以手动设置扩展策略，定时触发扩展，或根据动态触发条件自动调整容量。</p><h3 id="高级ASG功能"><a href="#高级ASG功能" class="headerlink" title="高级ASG功能"></a>高级ASG功能</h3><ul><li><strong>生命周期挂钩（Lifecycle Hooks）</strong></li></ul><p>生命周期挂钩允许您执行自定义操作，例如在实例启动或终止时发送通知或运行脚本。</p><ul><li><strong>实例终止策略（Instance Termination Policies）</strong></li></ul><p>终止策略定义了ASG在需要缩减容量时应如何选择要终止的实例。您可以自定义终止策略以满足特定需求。</p><ul><li><strong>预测性自动扩展（Predictive Scaling）</strong></li></ul><p>预测性自动扩展使用机器学习来预测将来的负载，并相应地调整实例数量，以减少资源浪费和成本。</p><ul><li><strong>混合实例策略（Mixed Instances Policy）</strong></li></ul><p>混合实例策略允许ASG使用多种实例类型，包括On-Demand和Spot实例，以提高成本效益。</p><ul><li><strong>在ASG中使用Spot实例</strong></li></ul><p>Spot实例是成本较低但可中断的实例类型。ASG可以使用Spot实例来降低成本，同时仍保持可用性。</p><h3 id="配置AWS-Auto-Scaling-Group"><a href="#配置AWS-Auto-Scaling-Group" class="headerlink" title="配置AWS Auto Scaling Group"></a>配置AWS Auto Scaling Group</h3><ul><li><strong>创建 Auto Scaling Group</strong></li></ul><p>在AWS控制台中创建Auto Scaling Group（ASG）是一项简单但重要的任务。首先，登录到AWS管理控制台，然后遵循以下步骤：</p><ol><li>导航到Auto Scaling控制台。</li><li>单击“创建Auto Scaling组”。</li><li>指定ASG的名称和描述。</li><li>选择要使用的启动配置。启动配置定义了新实例的配置，包括AMI、实例类型、安全组等。</li><li>设置期望容量。这是您希望ASG维护的实例数量。</li><li>选择最小和最大大小。最小大小是ASG可以缩减到的最小实例数，最大大小是ASG可以扩展到的最大实例数。</li><li>选择要使用的VPC。</li><li>配置负载均衡（如果需要）。您可以选择将ASG与负载均衡器相关联，以分配流量。</li><li>配置健康检查以确保实例的健康状态。</li><li>设置通知，以便在ASG执行自动扩展时接收通知。</li><li>审查和创建ASG。</li></ol><ul><li><strong>定义启动配置</strong></li></ul><p>启动配置是ASG创建新实例时使用的模板。您可以在创建ASG时选择现有的启动配置或创建新的。启动配置包括以下关键选项：</p><ol><li>AMI（Amazon Machine Image）：选择适合您应用程序的AMI。这是新实例的操作系统和应用程序基础。</li><li>实例类型：选择实例的规格，以满足性能和资源需求。</li><li>安全组：定义实例的网络访问策略，确保适当的安全性。</li><li>存储卷：定义实例的根卷和附加卷。</li><li>用户数据：可选项，允许您提供启动脚本或其他自定义配置。</li></ol><ul><li><strong>配置自动扩展策略</strong></li></ul><p>自动扩展策略定义了ASG何时以及如何调整实例数量。在ASG中，您可以配置以下类型的策略：</p><ol><li>目标跟踪策略：设置CPU利用率、网络流量等指标的目标值。ASG将自动增加或减少实例以维持目标。</li><li>简单缩放策略：基于CloudWatch指标（如CPU利用率）的阈值进行自动缩放。</li><li>定时扩展策略：按计划定期增加或减少实例数量。适用于按时间表的工作负载。</li></ol><ul><li><strong>关联负载均衡器</strong></li></ul><p>如果您的应用程序需要负载均衡，您可以将ASG与AWS Elastic Load Balancer（ELB）相关联。这样，ASG将自动将新实例注册到负载均衡器，确保流量平衡。</p><ul><li><strong>设置健康检查</strong></li></ul><p>健康检查是确保实例健康的关键。您可以定义HTTP、TCP或自定义健康检查来监控实例。如果实例标记为不健康，ASG将自动替换它们。</p><h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><p>AWS Auto Scaling Group（ASG）在各种应用场景中都具有广泛的用途，以下是一些常见的应用场景：</p><ul><li><strong>Web应用程序</strong></li></ul><p>Web应用程序通常会面临不断变化的流量。ASG可帮助您根据实际请求量自动扩展或缩减实例数量，以确保用户始终获得稳定的性能。在这种情况下，您可以根据请求率、CPU利用率或其他性能指标来配置自动扩展策略。</p><ul><li><strong>微服务架构</strong></li></ul><p>微服务架构将应用程序拆分成多个微小的服务，每个服务都可以独立扩展。ASG为每个微服务提供弹性，使您能够根据每个服务的负载需求来动态调整实例数量。这有助于确保整体系统的高可用性和性能。</p><ul><li><strong>批处理处理</strong></li></ul><p>对于需要处理大量数据或批量作业的场景，ASG可以帮助您实现自动化的扩展和缩减。您可以根据作业队列的长度、处理速度等指标来配置自动扩展策略，以确保作业能够及时完成。</p><ul><li><strong>数据分析</strong></li></ul><p>数据分析工作负载通常需要大量计算资源，但其负载可能在不同时间段内变化。ASG允许您根据数据分析工作负载的需求来动态调整实例数量。这意味着您可以在数据处理高峰期扩展实例数量，并在需求下降时自动缩减容量，以优化成本。</p><ul><li><strong>电子商务平台</strong></li></ul><p>电子商务平台在特定时间段内可能会面临季节性高峰，如假日购物季。使用ASG，您可以根据销售活动的预期来调整实例数量，以应对潜在的流量增加。这有助于确保用户在高峰期间获得无缝的购物体验。</p><ul><li><strong>游戏服务器</strong></li></ul><p>在线游戏通常会有大量玩家同时在线，因此需要具备高度可扩展性。ASG可以根据游戏服务器的负载情况来自动扩展或缩减实例数量，以满足玩家需求。这有助于确保游戏的稳定性和响应速度。</p><ul><li><strong>科学计算</strong></li></ul><p>科学计算工作负载需要大量计算资源来执行复杂的计算任务，例如模拟、数据分析和渲染。ASG可以帮助科学研究团队在需要时获得额外的计算能力，以加速研究进程。</p><p>这些是一些常见的实际应用场景，ASG的灵活性和自动化特性使其成为各种工作负载的理想选择。根据您的特定需求，您可以调整自动扩展策略和配置，以满足不同应用程序的要求。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>AWS Auto Scaling Group（ASG）是云计算中实现弹性自动扩展的重要工具，它使您能够根据需求自动调整资源，同时优化资源使用和成本。通过深入了解ASG的核心概念、配置选项、最佳实践以及实际应用场景，您将能够构建可扩展和具有适应性的云基础架构，以应对不断变化的应用程序和服务需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在云计算领域，弹性自动扩展是确保应用程序高可用性和性能的关键组成部分。&lt;code&gt;AWS Auto Scaling Group（ASG）&lt;/code&gt;是Amazon Web Services（AWS）提供的一项强大服务，可帮助您自动扩展和管理应用程序的资源，以适应不断变化的</summary>
      
    
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>Elastic Load Balancer: CLB, ALB, NLB and GWLB</title>
    <link href="https://stonefishy.github.io/2022/10/21/elastic-load-balancer-clb-alb-nlb-and-gwlb/"/>
    <id>https://stonefishy.github.io/2022/10/21/elastic-load-balancer-clb-alb-nlb-and-gwlb/</id>
    <published>2022-10-21T20:23:06.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Classic-Load-Balancers-v1"><a href="#Classic-Load-Balancers-v1" class="headerlink" title="Classic Load Balancers (v1)"></a>Classic Load Balancers (v1)</h2><p><strong>Supports TCP (Layer 4), HTTP &amp; HTTPS (Layer 7)</strong></p><p><strong>Health checks are TCP or HTTP based</strong></p><p><strong>Fixed hostname XXX.region.elb.amazonaws.com</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="/assets/images/aws/aws-elb-clb.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-elb-clb.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS Classic Load Balancer" style="width:600px;"/></div><span class="image-caption">AWS Classic Load Balancer</span></div><h2 id="Application-Load-Balancer-v2"><a href="#Application-Load-Balancer-v2" class="headerlink" title="Application Load Balancer (v2)"></a>Application Load Balancer (v2)</h2><p><strong>Application  load balancers is Layer 7 (HTTP)</strong></p><p><strong>Load balancing to multiple HTTP applications across machines (target groups)</strong></p><p><strong>Load balancing to multiple applications on the same machine (ex: containers)</strong></p><p><strong>Support for HTTP&#x2F;2 and WebSocket</strong></p><p><strong>Supports redirects (from HTTP to HTTPS for example)</strong></p><p><strong>Routing tables to different target groups:</strong></p><ol><li>Routing base on path in URL (example.com&#x2F;<strong>users</strong> &amp; example.com&#x2F;<strong>posts</strong>)</li><li>Routing base on hostname in URL (<strong>one</strong>.example.com &amp; <strong>other</strong>.example.com)</li><li>Routing base on Query String, Headers (example.com&#x2F;users?<strong>id&#x3D;123&amp;order&#x3D;false</strong>)</li></ol><span class='pbg danger'>ALB are a great fit for micro services & container-based application (example: Docker & Amazon ECS)</span><p>Has a port mapping feature to redirect to a dynamic port in ECS<br>In comparison, we’d need multiple Classic Load Balancer per application</p><h3 id="ALB-v2-HTTP-Based-Traffic"><a href="#ALB-v2-HTTP-Based-Traffic" class="headerlink" title="ALB (v2) HTTP Based Traffic"></a>ALB (v2) HTTP Based Traffic</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="/assets/images/aws/aws-elb-alb-traffic.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-elb-alb-traffic.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS Application Load Balancer Traffic" style="width:600px;"/></div><span class="image-caption">AWS Application Load Balancer Traffic</span></div><h3 id="ALB-v2-Target-Groups"><a href="#ALB-v2-Target-Groups" class="headerlink" title="ALB (v2) Target Groups"></a>ALB (v2) Target Groups</h3><p><strong>EC2 instances (can be managed by an Auto Scaling Group) - HTTP</strong></p><p><strong>ECS tasks (managed by ECS itself) - HTTP</strong></p><p><strong>Lambda functions - HTTP request is translated into a JSON event</strong></p><p><strong>IP Addresses - must be private IPs</strong></p><p><strong>ALB can route to multiple target groups</strong></p><p><strong>Health checks are at the target group level</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="/assets/images/aws/aws-elb-alb-targetgroup.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-elb-alb-targetgroup.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS ALB Query Strings/Parameters Routing" style="width:600px;"/></div><span class="image-caption">AWS ALB Query Strings/Parameters Routing</span></div><h2 id="Network-Load-Balancer-v2"><a href="#Network-Load-Balancer-v2" class="headerlink" title="Network Load Balancer (v2)"></a>Network Load Balancer (v2)</h2><p><strong>Network load balancers (Layer 4) allow to:</strong></p><ol><li>Forward TCP &amp; UDP traffic to your instances</li><li>Handle millions of request per seconds</li><li>Less latency ~ 100ms (vs 400 ms for ALB)</li></ol><p><strong>NLB has one static IP per AZ, and supports assigning Elastic IP(helpful for whitelisting specific IP)</strong></p><p><strong>NLB are used for extreme performance, TCP or UDP traffic</strong></p><p><strong>Not included in the AWS free tier</strong></p><h3 id="Network-Load-Balancer-v2-TCP-Layer-4-Based-Traffic"><a href="#Network-Load-Balancer-v2-TCP-Layer-4-Based-Traffic" class="headerlink" title="Network Load Balancer (v2) TCP (Layer 4) Based Traffic"></a>Network Load Balancer (v2) TCP (Layer 4) Based Traffic</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="/assets/images/aws/aws-elb-nlb-traffic.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-elb-nlb-traffic.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS NLB TCP Based Traffic" style="width:600px;"/></div><span class="image-caption">AWS NLB TCP Based Traffic</span></div><h3 id="Network-Load-Balancer-Target-Groups"><a href="#Network-Load-Balancer-Target-Groups" class="headerlink" title="Network Load Balancer - Target Groups"></a>Network Load Balancer - Target Groups</h3><p><strong>EC2 instances</strong></p><p><strong>IP Addresses - must be private IPs</strong></p><p><strong>Application Load Balancer</strong></p><p><strong>Health Checks support the TCP, HTTP and HTTPS protocols</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="/assets/images/aws/aws-elb-nlb-targetgroup.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-elb-nlb-targetgroup.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS Network Load Balancer Target Group" style="width:600px;"/></div><span class="image-caption">AWS Network Load Balancer Target Group</span></div><h2 id="Gateway-Load-Balancer"><a href="#Gateway-Load-Balancer" class="headerlink" title="Gateway Load Balancer"></a>Gateway Load Balancer</h2><p><strong>Deploy, scale, and manage a fleet of 3rd party network virtual applications in AWS Example: Firewalls, Intrusion Detection and Prevention Systems, Deep Packet Inspect Inspection Systems, payload manipulation, …</strong></p><p><strong>Operates at Layer 3 (Network Layer) - IP Packages</strong></p><p><strong>Combines the following fuctions:</strong></p><ol><li>Transparent Network Gateway - single entry&#x2F;exit for all traffic</li><li>Load Balancer - distributes traffic to your virtual applications</li><li>Uses the GENEVE protocol on port 6081</li></ol><h3 id="Gateway-Load-Balancer-Network-Layer-Layer-3-Based-Traffic"><a href="#Gateway-Load-Balancer-Network-Layer-Layer-3-Based-Traffic" class="headerlink" title="Gateway Load Balancer Network Layer (Layer 3) Based Traffic"></a>Gateway Load Balancer Network Layer (Layer 3) Based Traffic</h3><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="/assets/images/aws/aws-elb-gwlb.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-elb-gwlb.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS Gateway Load Balancer Traffic" style="height:500px;"/></div><span class="image-caption">AWS Gateway Load Balancer Traffic</span></div>  <h3 id="Gateway-Load-Balancer-Target-Group"><a href="#Gateway-Load-Balancer-Target-Group" class="headerlink" title="Gateway Load Balancer - Target Group"></a>Gateway Load Balancer - Target Group</h3><p><strong>EC2 instances</strong></p><p><strong>IP Addresses - must be private IPs</strong></p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="/assets/images/aws/aws-elb-gwlb-targetgroup.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-elb-gwlb-targetgroup.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS Gateway Load Balancer Target Group" style="width:600px;"/></div><span class="image-caption">AWS Gateway Load Balancer Target Group</span></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Classic-Load-Balancers-v1&quot;&gt;&lt;a href=&quot;#Classic-Load-Balancers-v1&quot; class=&quot;headerlink&quot; title=&quot;Classic Load Balancers (v1)&quot;&gt;&lt;/a&gt;Classic L</summary>
      
    
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>Elastic Load Balancing (ELB) Overview</title>
    <link href="https://stonefishy.github.io/2022/10/17/elastic-load-balancing-elb-overview/"/>
    <id>https://stonefishy.github.io/2022/10/17/elastic-load-balancing-elb-overview/</id>
    <published>2022-10-17T16:01:25.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<h2 class="bamboo-h " id="What is load balancing2nj373pspvq">What is load balancing</h2><br/><p>Load Balances are servers that forward traffic to multiple servers (e.g., EC2 instances) downstream.</p><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="/assets/images/aws/aws-elb-1.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-elb-1.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS ELB" style="width:600px;"/></div><span class="image-caption">AWS ELB</span></div><h2 class="bamboo-h " id="Why use a load balancingglm9g4xma6">Why use a load balancing</h2><br/><ul><li>Spread load across multiple downstream instances</li><li>Expose a single point of access (DNS) to your application</li><li>Seamlessly handle failures of downstream instances</li><li>Do regular health checks to your instances</li><li>Provide SSL termination (HTTPS) for your websites</li><li>Enforce stickiness with cookies</li><li>Hight availability across zones</li><li>Separate public traffic from private traffic</li></ul><h2 class="bamboo-h " id="Why use an Elastic Load Balancer1uwa4p4ppl0">Why use an Elastic Load Balancer</h2><br/><ul><li>An Elastic Load Balancer is a managed load balancer<ul><li>AWS guarantees that it will be working</li><li>AWS takes care of upgrades, maintenance, hight availability</li><li>AWS provides only a few configuration knobs</li></ul></li><li>It costs less to setup your own load balancer but it will be a lot more effort on your end</li><li>It is integrarted with many AWS offerings&#x2F;services<ul><li>EC2, EC2 Auto Scaling Groups, Amazon ECS</li><li>AWS Certificate Manager (ACM), CloudWatch</li><li>Route 53, AWS WAF, AWS Global Accelerator</li></ul></li></ul><h2 class="bamboo-h " id="Health Checks6h4zyklba8g">Health Checks</h2><br/><ul><li>Health Checks are crucial for Load Balancers</li><li>They enable the load balancer to know if instances it forwards traffic to are available to reply to requests</li><li>The health check is done on a port and a route (&#x2F;health is common)</li><li>If the response is not 200 (OK), then the instance is unhealthy</li></ul><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="/assets/images/aws/aws-elb-health.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-elb-health.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS ELB Health Check" style="width:600px;"/></div><span class="image-caption">AWS ELB Health Check</span></div><h2 class="bamboo-h " id="Types of load balancer on AWS14town4re8v">Types of load balancer on AWS</h2><br/><ul><li>AWS has 4 kinds of managed Load Balancers</li><li>Classic Load Balancer (v1 - old generation) - 2009 - CLB<ul><li>HTTP, HTTPS, TCP, SSL (secure TCP)</li></ul></li><li>Application Load Balancer (v2 - new generation) - 2016 - ALB<ul><li>HTTP, HTTPS, WebSocker</li></ul></li><li>Network Load Balancer (v2 - new generation) - 2017 - NLB<ul><li>TCP, TLC (secure TCP), UDP</li></ul></li><li>Gateway Load Balancer - 2020 - GWLB<ul><li>Operates at layer 3 (Network layer) - IP Protocol</li></ul></li><li>Overall, it is recommended to use the new generation load balancers as they provides more features</li><li>Some load balancers can be setup as internal (private) or external (public) ELBs</li></ul><h2 class="bamboo-h " id="Load Balancer Security Groups1ubczuay3ix">Load Balancer Security Groups</h2><br/><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="/assets/images/aws/aws-elb-security.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-elb-security.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS ELB Security Group" style="width:600px;"/></div><span class="image-caption">AWS ELB Security Group</span></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 class=&quot;bamboo-h &quot; id=&quot;What is load balancing2nj373pspvq&quot;&gt;What is load balancing&lt;/h2&gt;&lt;br/&gt;

&lt;p&gt;Load Balances are servers that forward tra</summary>
      
    
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>AWS EBS vs AWS EFS - Understanding the Key Differences</title>
    <link href="https://stonefishy.github.io/2022/09/21/aws-ebs-vs-aws-efs/"/>
    <id>https://stonefishy.github.io/2022/09/21/aws-ebs-vs-aws-efs/</id>
    <published>2022-09-21T18:39:28.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<h2 class="bamboo-h " id="Introductiontzhge71a4i">Introduction</h2><br/><p>Amazon Web Services (AWS) offers a wide range of storage solutions to cater to the diverse needs of businesses and developers. Two popular options are <code>Amazon Elastic Block Store (EBS)</code> and <code>Amazon Elastic File System (EFS)</code>. While both provide storage capabilities within the AWS ecosystem, they serve different purposes and have distinct characteristics. In this blog post, we will explore the key differences between AWS EBS and AWS EFS to help you make an informed choice for your specific use case.</p><h2 class="bamboo-h " id="Amazon Elastic Block Store (EBS)1m17rup8hig">Amazon Elastic Block Store (EBS)</h2><br/><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="/assets/images/aws/aws-ebs-efs-1.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ebs-efs-1.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS EBS" style="width:400px;"/></div><span class="image-caption">AWS EBS</span></div><span class='pbg warning'>Amazon Elastic Block Store (EBS) is a block-level storage service that provides durable and high-performance storage volumes that can be attached to Amazon Elastic Compute Cloud (EC2) instances.</span>.<p>Here are some of the main characteristics and use cases of AWS EBS.</p><h4 class="bamboo-h " id="Block Storage18rzm7zqec9">Block Storage</h4><br/><p>EBS provides block storage, which means it is best suited for scenarios where you need to store data at the block level, such as databases and applications that require direct access to disk devices.</p><h4 class="bamboo-h " id="Low-Latency Performance2gt4t8fehyg">Low-Latency Performance</h4><br/><p> EBS volumes offer low-latency, high-throughput performance, making them ideal for I&#x2F;O-intensive workloads where rapid data access is crucial.</p><h4 class="bamboo-h " id="Data Persistence1i7yow40cwy">Data Persistence</h4><br/><p> EBS volumes are persistent, meaning the data stored on them remains intact even when the associated EC2 instance is stopped or terminated. This is useful for maintaining critical data.</p><h4 class="bamboo-h " id="Availability and Redundancy536rzgnb5xw">Availability and Redundancy</h4><br/><p>EBS volumes can be replicated within a specific<br>Availability Zone (AZ) for redundancy, but they are not natively designed for cross-AZ or cross-region redundancy. For cross-AZ redundancy, you need to set up additional configurations.</p><h4 class="bamboo-h " id="Cost1tpa9irdnfj">Cost</h4><br/><p>You pay for the provisioned capacity of the EBS volume, regardless of whether it is in use or not. This can make it cost-effective for certain use cases but might require careful capacity planning.</p><h2 class="bamboo-h " id="Amazon Elastic File System (EFS)2ca5dfaskph">Amazon Elastic File System (EFS)</h2><br/><div class="img-wrap"><div class="img-bg"><img class="img lazyload placeholder" src="/assets/images/aws/aws-ebs-efs-2.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ebs-efs-2.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS EFS" style="width:400px;"/></div><span class="image-caption">AWS EFS</span></div><span class='pbg warning'>Amazon Elastic File System (EFS) is a fully managed</span> <p>Here are the key attributes and use cases of AWS EFS:</p><h4 class="bamboo-h " id="File Storage288xws0hs1h">File Storage</h4><br/><p>EFS offers file-level storage, making it suitable for scenarios where multiple instances need shared access to the same data, such as web applications, content management systems, and shared repositories.</p><h4 class="bamboo-h " id="Scalabilityabx86iumg0w">Scalability</h4><br/><p>EFS is designed to scale automatically as your storage needs grow. It can handle a dynamic number of EC2 instances concurrently, making it a great choice for applications with varying workloads.</p><h4 class="bamboo-h " id="Cross-AZ and Cross-Regionhrktvjtskh">Cross-AZ and Cross-Region</h4><br/><p>EFS provides built-in redundancy and can be accessed across multiple Availability Zones and even across regions. This ensures high availability and disaster recovery capabilities.</p><h4 class="bamboo-h " id="Pay-as-You-Go2jhyrg94fy6">Pay-as-You-Go</h4><br/><p>With EFS, you pay for the storage capacity you use, making it a cost-effective option for applications with fluctuating storage requirements.</p><h4 class="bamboo-h " id="Simplified Management2u192dxab6o">Simplified Management</h4><br/><p>EFS takes care of the underlying infrastructure and scaling, allowing you to focus on your applications without worrying about managing storage hardware.</p><h2 class="bamboo-h " id="Choosing Between EBS and EFS2on66yqi3pm">Choosing Between EBS and EFS</h2><br/><p>To decide between AWS EBS and AWS EFS, consider the following factors:</p><h4 class="bamboo-h " id="Use Case2hnm0bix2xc">Use Case</h4><br/><p>Determine whether your application requires block-level storage (EBS) or file-level storage (EFS).</p><h4 class="bamboo-h " id="Performance Requirements3vcpx6klc1">Performance Requirements</h4><br/> <p>Assess your performance needs. EBS is often preferred for high-performance workloads, while EFS offers good performance for a wide range of applications.</p><h4 class="bamboo-h " id="Scalability14qdkwm25ot">Scalability</h4><br/><p>Consider whether your storage needs are likely to scale over time. EFS is designed for easy scalability.</p><h4 class="bamboo-h " id="Availability and Redundancybvgihpiuenk">Availability and Redundancy</h4><br/> <p>If high availability and redundancy are crucial, EFS may be a better choice due to its built-in cross-AZ and cross-region capabilities.</p><h4 class="bamboo-h " id="Cost2lvomdej8vs">Cost</h4><br/> <p>Evaluate your budget and cost considerations. EBS charges are based on provisioned capacity, while EFS charges are based on actual usage.</p><h2 class="bamboo-h " id="Conclusiong4riqi8ym6">Conclusion</h2><br/><p>In summary, AWS EBS and AWS EFS are both valuable storage services within the AWS ecosystem, but they serve different purposes and have distinct characteristics. <span class='pbg danger'>EBS is ideal for block-level storage with high-performance requirements and provides data persistence within a single Availability Zone</span>. On the other hand, <span class='pbg danger'>EFS is designed for scalable file-level storage</span>. Your choice between the two should be based on your specific use case and requirements. Understanding these differences is crucial for optimizing your AWS storage strategy and ensuring the best performance and cost-efficiency for your applications.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 class=&quot;bamboo-h &quot; id=&quot;Introductiontzhge71a4i&quot;&gt;Introduction&lt;/h2&gt;&lt;br/&gt;

&lt;p&gt;Amazon Web Services (AWS) offers a wide range of storage soluti</summary>
      
    
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>AWS Elastic File System (EFS)：云中的弹性文件存储</title>
    <link href="https://stonefishy.github.io/2022/08/13/the-elastic-file-system/"/>
    <id>https://stonefishy.github.io/2022/08/13/the-elastic-file-system/</id>
    <published>2022-08-13T21:39:36.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p>在云计算时代，数据的管理和共享至关重要。<code>AWS Elastic File System（EFS）</code>是 Amazon Web Services（AWS）提供的一项云存储服务，旨在满足企业和开发者对可扩展、高可用性文件存储的需求。本文将深入探讨 AWS EFS 的特点、优势、使用案例以及如何开始使用它。</p><p><img src="/assets/images/aws/aws-efs.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-efs.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS EFS"></p><h2 class="bamboo-h " id="AWS EFS 概览2oxf6rj0uwo">AWS EFS 概览</h2><br/><span class='pbg danger'>AWS EFS 是一种托管的网络文件存储服务，旨在提供可扩展、高可用性的文件系统，以满足各种应用程序和工作负载的存储需求。</span> 以下是 AWS EFS 的关键特点：<p><strong>共享文件存储</strong>：EFS 允许多个 Amazon EC2 实例同时访问相同的文件系统，支持多用户和多应用程序的共享文件访问。</p><p><strong>自动伸缩</strong>：EFS 自动扩展以适应容量和吞吐量的需求，无需手动干预。这使得它适用于不断变化的工作负载。</p><p><strong>高可用性</strong>：EFS 文件系统在多个可用区（Availability Zones）内复制数据，以提供高可用性和冗余性。这意味着如果一个可用区发生故障，文件系统仍然可用。</p><p><strong>数据一致性</strong>：EFS 提供强一致性的数据访问，确保多个实例并发访问时的数据一致性。</p><p><strong>多种访问协议</strong>：EFS 支持多种文件访问协议，包括 NFSv4、NFSv3 和 Amazon EFS 文件系统客户端。</p><p><strong>安全性</strong>：EFS 文件系统支持 Amazon VPC（Virtual Private Cloud）网络隔离，以确保数据的安全性和隐私性。</p><p><img src="/assets/images/aws/aws-efs-ia.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-efs-ia.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS EFS IA"></p><h2 class="bamboo-h " id="AWS EFS 的优势f356rlu5zn">AWS EFS 的优势</h2><br/><p>为什么选择 AWS EFS 作为文件存储解决方案? 以下是一些显著的优势：</p><p><strong>可扩展性</strong>：EFS 自动扩展，因此您不必担心文件系统的容量限制。它可以根据需要增加存储空间。</p><p><strong>高可用性</strong>：EFS 提供多可用区部署，使文件系统在单个可用区故障时保持可用，提高了应用程序的可用性。</p><p><strong>共享性</strong>：多个 EC2 实例可以同时访问同一文件系统，使其适用于需要多个实例之间共享文件的应用程序。</p><p><strong>强一致性</strong>：EFS 提供强一致性，确保多个实例并发写入或读取文件时的数据一致性。</p><p><strong>灵活性</strong>：您可以根据需求创建和管理多个文件系统，每个文件系统可以有不同的权限和访问策略。</p><h2 class="bamboo-h " id="AWS EFS 的使用场景2g1jfdntext">AWS EFS 的使用场景</h2><br/><p>AWS EFS 适用于许多不同的使用场景，包括但不限于：</p><p><strong>Web 服务器</strong>：EFS 可用于存储 Web 服务器的静态内容、日志文件和配置文件，以实现高可用性和可扩展性。</p><p><strong>容器化应用程序</strong>：将容器化应用程序的配置文件和数据存储在 EFS 中，以便多个容器实例之间共享。</p><p><strong>大数据分析</strong>：EFS 可用于存储大数据分析工作负载的输入数据和输出结果，支持多个分析节点的并发访问。</p><p><strong>应用程序共享</strong>：EFS 使不同应用程序之间可以轻松地共享文件，适用于微服务架构和多个应用程序共存的情况。</p><p><strong>开发和测试环境</strong>：开发人员可以使用 EFS 存储开发和测试环境的代码和资源，确保一致的开发和测试数据。</p><h2 class="bamboo-h " id="开始使用 AWS EFSrxl608qksp">开始使用 AWS EFS</h2><br/><p>要开始使用 AWS EFS，您可以按照以下步骤操作：</p><ol><li>登录 AWS 控制台：使用您的 AWS 帐户登录 AWS 管理控制台。</li><li>创建 EFS 文件系统：在 AWS 控制台中导航到 EFS 服务，创建一个新的文件系统，并配置存储容量和权限。</li><li>设置访问权限：定义哪些 EC2 实例可以访问文件系统，并分配适当的权限。</li><li>将文件系统挂载到 EC2 实例：在您的 EC2 实例上挂载 EFS 文件系统，使实例能够访问共享文件。</li><li>开始使用：将您的应用程序或工作负载配置为使用挂载的 EFS 文件系统。</li></ol><h2 class="bamboo-h " id="总结2i1sy17nq5i">总结</h2><br/><p>AWS Elastic File System（EFS）是一项强大的云文件存储服务，为各种应用程序和业务提供可扩展，高可能性的文件存储功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在云计算时代，数据的管理和共享至关重要。&lt;code&gt;AWS Elastic File System（EFS）&lt;/code&gt;是 Amazon Web Services（AWS）提供的一项云存储服务，旨在满足企业和开发者对可扩展、高可用性文件存储的需求。本文将深入探讨 AWS </summary>
      
    
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>How to Backup and Restore AWS EBS</title>
    <link href="https://stonefishy.github.io/2022/07/19/how-to-backup-and-restore-aws-ebs/"/>
    <id>https://stonefishy.github.io/2022/07/19/how-to-backup-and-restore-aws-ebs/</id>
    <published>2022-07-19T16:46:38.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p>在Amazon Web Services（AWS）中，<code>Snapshot</code>是一种备份和恢复Amazon Elastic Block Store（EBS）卷数据的关键工具。<br><img src="/assets/images/aws/aws-ebs-snapshot.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ebs-snapshot.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS EBS Snapshot"></p><h2 class="bamboo-h " id="什么是Snapshot1wpxyq6q2pl">什么是Snapshot</h2><br/><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Snapshot是EBS卷的点对点备份，它记录了卷的特定时刻的状态，包括数据、配置和元数据。快照是存储在Amazon S3中的，因此具有高可靠性和持久性。</p><h2 class="bamboo-h " id="特点和功能1bvljqyg5bh">特点和功能</h2><br/><h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h4><p>Snapshot是持久性的，一旦创建，它们会一直存在，即使原始EBS卷被删除也是如此。</p><h4 id="增量备份"><a href="#增量备份" class="headerlink" title="增量备份"></a>增量备份</h4><p>快照仅捕获自上一个快照以来发生的更改，这降低了备份的成本和时间。</p><h4 id="快速创建"><a href="#快速创建" class="headerlink" title="快速创建"></a>快速创建</h4><p>Snapshot创建通常非常快，因为它只会记录发生的更改。</p><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>可以创建多个快照，并根据需要还原到不同的版本，以便进行数据版本控制和历史记录。</p><h4 id="复制到其他区域"><a href="#复制到其他区域" class="headerlink" title="复制到其他区域"></a>复制到其他区域</h4><p>可以将Snapshot复制到其他AWS区域，以增加数据的可用性和灾难恢复选项。</p><h4 id="创建新EBS卷"><a href="#创建新EBS卷" class="headerlink" title="创建新EBS卷"></a>创建新EBS卷</h4><p>可以使用Snapshot创建新的EBS卷，这对于在不同EC2实例之间共享数据非常有用。</p><h4 id="自动快照策略"><a href="#自动快照策略" class="headerlink" title="自动快照策略"></a>自动快照策略</h4><p>可以设置自动快照策略，以定期创建快照，从而实现自动备份。</p><h2 class="bamboo-h " id="如何创建和使用Snapshotbsy5419b17c">如何创建和使用Snapshot</h2><br/><h4 id="创建Snapshot"><a href="#创建Snapshot" class="headerlink" title="创建Snapshot"></a>创建Snapshot</h4><p>在AWS管理控制台上，可以选择要备份的EBS卷，然后创建Snapshot。也可以使用AWS命令行工具或SDK来创建Snapshot。</p><h4 id="备份策略"><a href="#备份策略" class="headerlink" title="备份策略"></a>备份策略</h4><p>可以选择手动创建Snapshot，也可以设置自动快照策略来定期备份数据。</p><h4 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h4><p>如果需要，可以使用Snapshot还原数据。可以创建新的EBS卷，然后从快照还原数据，或者将快照直接附加到现有EBS卷上。</p><h4 id="数据保护"><a href="#数据保护" class="headerlink" title="数据保护"></a>数据保护</h4><p>Snapshot是数据保护的关键，它可以防止因数据丢失或损坏而引发的灾难情况。</p><h4 id="数据复制和迁移"><a href="#数据复制和迁移" class="headerlink" title="数据复制和迁移"></a>数据复制和迁移</h4><p>可以将Snapshot复制到其他AWS区域或AWS账户，以实现数据复制和迁移。</p><h2 class="bamboo-h " id="快照的应用场景1uhi9om3vid">快照的应用场景</h2><br/><h4 id="数据备份和恢复"><a href="#数据备份和恢复" class="headerlink" title="数据备份和恢复"></a>数据备份和恢复</h4><p>主要用于备份重要的数据，以便在数据丢失或损坏时能够迅速恢复。</p><h4 id="点对点复制和迁移"><a href="#点对点复制和迁移" class="headerlink" title="点对点复制和迁移"></a>点对点复制和迁移</h4><p>可以将快照复制到不同的 AWS 区域或 AWS 账户，以实现数据的复制和迁移。</p><h4 id="测试和开发"><a href="#测试和开发" class="headerlink" title="测试和开发"></a>测试和开发</h4><p>创建快照可以帮助在不影响生产环境的情况下为测试和开发环境提供实验数据。</p><h4 id="版本控制和数据恢复"><a href="#版本控制和数据恢复" class="headerlink" title="版本控制和数据恢复"></a>版本控制和数据恢复</h4><p>可以使用快照来实现数据版本控制，允许在不同时间点恢复到不同的数据状态。</p><h4 id="数据分析和报告"><a href="#数据分析和报告" class="headerlink" title="数据分析和报告"></a>数据分析和报告</h4><p>可以创建快照以便进行数据分析、生成报告或生成数据副本以供其他用途使用。</p><h2 class="bamboo-h " id="快照的定价1o38hhitwbz">快照的定价</h2><br/><p>会被收费用于创建和保留快照的存储空间。快照的价格取决于存储的数据量。AWS 还提供了一些定价选项，如创建和保留快照的频率。具体查看 AWS 官方网站的定价详情获取最新信息。</p><h2 class="bamboo-h " id="最佳实践和注意事项27vlgv8l4x5">最佳实践和注意事项</h2><br/><h4 id="定期创建快照"><a href="#定期创建快照" class="headerlink" title="定期创建快照"></a>定期创建快照</h4><p>建议定期创建快照，以确保数据的定期备份和恢复能力。</p><h4 id="标记和命名"><a href="#标记和命名" class="headerlink" title="标记和命名"></a>标记和命名</h4><p>为快照提供有意义的标记和命名，以便轻松识别和管理。</p><h4 id="自动化备份策略"><a href="#自动化备份策略" class="headerlink" title="自动化备份策略"></a>自动化备份策略</h4><p>使用 AWS 的自动备份策略来定期创建快照，减少人工干预。</p><h4 id="根据需求调整快照"><a href="#根据需求调整快照" class="headerlink" title="根据需求调整快照"></a>根据需求调整快照</h4><p>根据数据的重要性和变化频率，调整快照的保留策略。</p><h4 id="监控和警报"><a href="#监控和警报" class="headerlink" title="监控和警报"></a>监控和警报</h4><p>设置监控和警报，以便在快照创建或数据丢失时及时获得通知。</p><h2 class="bamboo-h " id="总结tfqf9bm8ob">总结</h2><br/><p>总之，AWS Snapshot 用于EBS卷备份和数据保护的关键工具。它具有高度的持久性和可靠性，并支持数据版本控制、恢复、复制和迁移。通过定期创建Snapshot，可以确保数据的安全性和可用性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Amazon Web Services（AWS）中，&lt;code&gt;Snapshot&lt;/code&gt;是一种备份和恢复Amazon Elastic Block Store（EBS）卷数据的关键工具。&lt;br&gt;&lt;img src=&quot;/assets/images/aws/aws-ebs-</summary>
      
    
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>Understanding AWS EC2 Instance Store</title>
    <link href="https://stonefishy.github.io/2022/06/13/understanding-aws-ec2-instance-store/"/>
    <id>https://stonefishy.github.io/2022/06/13/understanding-aws-ec2-instance-store/</id>
    <published>2022-06-13T21:08:54.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p>Amazon Web Services (AWS) 的弹性云计算实例（EC2）为用户提供了多种存储选项，其中之一是实例存储(<code>Instance Store</code>)，也被称为本地实例存储或瞬态存储。本文将深入研究 AWS EC2 实例存储，包括其定义、特点、使用场景以及最佳实践。</p><h2 class="bamboo-h " id="什么是 EC2 实例存储？1zobqmg9tp0">什么是 EC2 实例存储？</h2><br/><div class="note info"><p>EC2 实例存储是 EC2 实例上提供的临时、本地存储选项。这些存储卷是物理存储设备（如硬盘驱动器）的一部分，直接连接到宿主实例，而不是通过网络进行访问。实例存储通常提供了非常高的性能，适用于需要低延迟和高吞吐量的工作负载。</p></div><p><img src="/assets/images/aws/aws-ec2-instancestore-iops.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ec2-instancestore-iops.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS EC2 Instance Store IOPS"></p><h2 class="bamboo-h " id="实例存储的特点ladwj0ks7">实例存储的特点</h2><br/><p><strong>临时性</strong>：实例存储是临时的，与 EC2 实例的生命周期紧密相连。当 EC2 实例停止、终止或失败时，存储中的数据将不再可用。</p><p><strong>高性能</strong>：实例存储通常提供非常高的 I&#x2F;O 性能，适用于需要大量读写操作的应用程序，如数据库缓存或临时计算。</p><p><strong>低延迟</strong>：由于实例存储直接连接到宿主实例，因此具有非常低的访问延迟，适用于对速度要求极高的工作负载。</p><p><strong>不同于 Amazon EBS</strong>：<wavy>, 与 Amazon Elastic Block Store（EBS）不同，实例存储不需要预配，也没有额外的费用，但缺乏 EBS 提供的持久性和数据备份功能。</wavy></p><h2 class="bamboo-h " id="使用场景3y6vjrxzyf6">使用场景</h2><br/><p><strong>缓存层</strong>：实例存储适用于临时数据，如缓存层。通过将缓存存储在实例存储上，可以提高读取速度和降低后端存储负担。</p><p><strong>临时计算</strong>：对于需要执行大规模数据处理的任务，实例存储可以用作临时工作空间，以加速计算过程。</p><p><strong>日志存储</strong>：对于需要快速记录大量日志数据的应用程序，实例存储可以提供高性能的日志存储解决方案。</p><h2 class="bamboo-h " id="最佳实践1kx98kneghk">最佳实践</h2><br/><p><strong>备份重要数据</strong>：由于实例存储是临时性的，重要数据需要备份到持久性存储（如 Amazon EBS 或 Amazon S3）以防止数据丢失。</p><p><strong>了解生命周期</strong>：在使用实例存储时，了解 EC2 实例的生命周期非常重要。确保存储中的数据不会在实例终止时丢失。</p><p><strong>监控性能</strong>：实例存储通常提供高性能，但仍然需要监控其性能以确保正常运行。</p><h2 class="bamboo-h " id="总结3i6qg99syd4">总结</h2><br/><span class='pbg danger'>AWS EC2 实例存储是一种适用于需要高性能和低延迟的临时数据存储的选择。尽管它不适用于持久性数据存储，但在特定场景下，如缓存、临时计算和日志存储，它可以提供卓越的性能和效率</span>。使用实例存储时，请谨记存储临时性质，并采取适当的备份和监控措施，以确保数据的可用性和完整性。]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Amazon Web Services (AWS) 的弹性云计算实例（EC2）为用户提供了多种存储选项，其中之一是实例存储(&lt;code&gt;Instance Store&lt;/code&gt;)，也被称为本地实例存储或瞬态存储。本文将深入研究 AWS EC2 实例存储，包括其定义、特点、</summary>
      
    
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>What is AWS EBS and how to use it</title>
    <link href="https://stonefishy.github.io/2022/05/01/what-is-aws-ebs-and-how-to-use-it/"/>
    <id>https://stonefishy.github.io/2022/05/01/what-is-aws-ebs-and-how-to-use-it/</id>
    <published>2022-05-01T15:09:49.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p><code>Amazon Elastic Block Store (EBS)</code> 是 Amazon Web Services (AWS) 提供的一项块存储服务，它允许用户创建和管理持久性块存储卷，并将这些卷附加到 Amazon Elastic Compute Cloud (EC2) 实例上。以下是关于 AWS EBS 的详细信息，包括特征、原理和使用方法。<br><img src="/assets/images/aws/aws-ebs-1.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ebs-1.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS EBS"></p><h2 id="特征和功能"><a href="#特征和功能" class="headerlink" title="特征和功能"></a>特征和功能</h2><h4 id="持久性存储"><a href="#持久性存储" class="headerlink" title="持久性存储"></a>持久性存储</h4><p>EBS 卷是持久性的，这意味着数据在卷被附加到 EC2 实例上时保持不变。即使 EC2 实例停止或终止，数据仍然保留在卷上。</p><h4 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h4><p>EBS 卷会自动复制到同一可用性区域的多个设备上，以提高可用性和数据冗余。这确保了卷的数据可靠性。</p><h4 id="不断电的性能"><a href="#不断电的性能" class="headerlink" title="不断电的性能"></a>不断电的性能</h4><p>EBS 提供不断电的性能，可以提供一致的低延迟和高吞吐量，适用于各种工作负载，包括数据库、应用程序和文件系统。</p><h4 id="多种卷类型"><a href="#多种卷类型" class="headerlink" title="多种卷类型"></a>多种卷类型</h4><p>EBS 提供不同类型的卷，包括通用用途（gp2、gp3）、块存储（io1、io2）、冷 HDD 存储（sc1）和磁盘存储（st1）。每种类型都针对不同的性能和成本需求进行了优化。</p><h4 id="大小和性能的可扩展性"><a href="#大小和性能的可扩展性" class="headerlink" title="大小和性能的可扩展性"></a>大小和性能的可扩展性</h4><p>您可以根据需要调整 EBS 卷的大小和性能，而无需停机。这种可扩展性使您能够适应变化的工作负载需求。</p><h4 id="快照和备份"><a href="#快照和备份" class="headerlink" title="快照和备份"></a>快照和备份</h4><p>您可以创建 EBS 卷的快照，以备份数据，并可以使用这些快照创建新的卷。这对于数据恢复和备份非常有用。<br><img src="/assets/images/aws/aws-ebs-attach.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ebs-attach.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="EBS Attached to EC2"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>EBS 基于云上虚拟化技术实现，其主要原理如下</p><h4 id="块级别存储"><a href="#块级别存储" class="headerlink" title="块级别存储"></a>块级别存储</h4><p>EBS 存储是以块级别（通常为 512KB 或 1MB）来管理的。每个 EBS 卷由多个块组成，这些块可以独立读取和写入。</p><h4 id="分布式复制"><a href="#分布式复制" class="headerlink" title="分布式复制"></a>分布式复制</h4><p>EBS 卷的数据在同一可用性区域内的多个设备上进行分布式复制。这种复制提高了可用性和数据冗余。</p><h4 id="异步持久性"><a href="#异步持久性" class="headerlink" title="异步持久性"></a>异步持久性</h4><p>EBS 异步将数据写入持久性存储，以确保数据持久性。这意味着数据写入可能不会立即返回成功，但在后续读取时数据是可靠的。</p><h2 id="如何使用-EBS"><a href="#如何使用-EBS" class="headerlink" title="如何使用 EBS"></a>如何使用 EBS</h2><h4 id="创建-EBS-卷"><a href="#创建-EBS-卷" class="headerlink" title="创建 EBS 卷"></a>创建 EBS 卷</h4><p>在 AWS 控制台上，您可以创建新的 EBS 卷，选择卷类型、大小和其他配置选项。</p><h4 id="附加-EBS-卷"><a href="#附加-EBS-卷" class="headerlink" title="附加 EBS 卷"></a>附加 EBS 卷</h4><p>创建的 EBS 卷可以附加到 EC2 实例上。您可以选择在启动 EC2 实例时附加卷，或者在运行实例时添加卷。</p><h4 id="格式化和挂载"><a href="#格式化和挂载" class="headerlink" title="格式化和挂载"></a>格式化和挂载</h4><p>一旦附加到 EC2 实例，您需要在实例上格式化 EBS 卷，并将其挂载到文件系统上，以便在实例上使用。</p><h4 id="使用和管理"><a href="#使用和管理" class="headerlink" title="使用和管理"></a>使用和管理</h4><p>一旦 EBS 卷附加到实例上，您可以在其上创建、读取和写入数据。您还可以使用快照功能创建备份。</p><p><code>AWS EC2启动默认使用的根存储EBS在EC2终止的时候会一并删掉，而额外附加的EBS存储块则不会删除。EBS存储卷只能附加到同一个可用区的EC2实例上。</code><br><img src="/assets/images/aws/aws-ebs-root.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ebs-root.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="EBS for AMI Root Volume"></p><p>EBS 是 AWS 中的核心存储服务，用于持久性数据存储和扩展存储性能。它适用于各种应用程序和工作负载，从数据库到文件存储。通过了解 EBS 的特点和原理，您可以更好地配置和管理您的云存储需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Amazon Elastic Block Store (EBS)&lt;/code&gt; 是 Amazon Web Services (AWS) 提供的一项块存储服务，它允许用户创建和管理持久性块存储卷，并将这些卷附加到 Amazon Elastic Compute Cl</summary>
      
    
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>什么是AWS EC2 Hibernation</title>
    <link href="https://stonefishy.github.io/2022/04/08/shi-yao-shi-aws-ec2-hibernation/"/>
    <id>https://stonefishy.github.io/2022/04/08/shi-yao-shi-aws-ec2-hibernation/</id>
    <published>2022-04-08T09:00:59.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p><code>EC2 Hibernation</code> 是 Amazon Elastic Compute Cloud (EC2) 服务的一个功能，它允许您将 EC2 实例从运行状态转换为休眠状态，然后再次唤醒它，而不会丢失实例的内存中的数据。这个功能非常适合那些需要保持应用程序状态或长时间运行进程的工作负载。<br><img src="/assets/images/aws/aws-ec2-hibernation-flow.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ec2-hibernation-flow.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br>这里详细说明 EC2 Hibernation 的<strong>工作原理</strong></p><span id="more"></span><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><strong>1.启用 Hibernation：</strong> 要使用 EC2 Hibernation，首先需要在 EC2 实例上启用它。这可以通过使用支持 Hibernation 的实例类型，并在启动时启用 Hibernation 选项来完成。并且EBS卷必须要开启加密。<br><img src="/assets/images/aws/aws-ec2-hibernation-enable.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ec2-hibernation-enable.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>2.创建 Hibernation 快照：</strong> 在启用 Hibernation 后，EC2 实例的内存状态将被定期保存到 Amazon Elastic Block Store (EBS) 卷上的 Hibernation 快照中。这确保了在实例休眠时不会丢失内存中的数据。</p><p><strong>3.休眠实例：</strong> 一旦 Hibernation 启用并创建了快照，您可以通过执行 hibernate 命令或使用 AWS 管理控制台将实例转换为休眠状态。在休眠期间，实例的状态和数据将保存在 EBS 卷上。</p><p><strong>4.唤醒实例：</strong> 当您希望恢复实例的运行状态时，只需执行唤醒命令或使用控制台，EC2 实例将从 Hibernation 快照中还原内存状态，并继续运行。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>EC2 Hibernation 可以应用于多种使用场景，包括但不限于：</p><p><strong>长时间运行的进程：</strong> 如果您的 EC2 实例运行有状态的应用程序或长时间运行的进程，您可以使用 Hibernation 将实例休眠，以节省计算成本，而无需中断应用程序。</p><p><strong>工作负载保持状态：</strong> 某些工作负载需要保持状态，例如内存中的会话数据或数据库连接。通过 Hibernation，您可以在需要时恢复工作负载，而无需重新创建状态。</p><p><strong>成本优化：</strong> 对于不需要全天候运行的工作负载，您可以使用 Hibernation 在闲置时降低成本，然后在需要时快速恢复。</p><p><strong>实例维护：</strong> 在 EC2 实例需要进行操作系统更新或其他维护操作时，可以使用 Hibernation 将实例休眠，然后在完成维护后唤醒它，以减少维护期间的停机时间。</p><p>&#x3D;&#x3D;请注意&#x3D;&#x3D;，<u>不是所有的 EC2 实例类型都支持 Hibernation</u>，您需要选择支持该功能的实例类型并启用它。此外，<u>使用 Hibernation 可能会产生额外的 EBS 存储费用，因为需要存储 Hibernation 快照</u>。所以，在使用 Hibernation 时，需要权衡成本和性能需求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;EC2 Hibernation&lt;/code&gt; 是 Amazon Elastic Compute Cloud (EC2) 服务的一个功能，它允许您将 EC2 实例从运行状态转换为休眠状态，然后再次唤醒它，而不会丢失实例的内存中的数据。这个功能非常适合那些需要保持应用程序状态或长时间运行进程的工作负载。&lt;br&gt;&lt;img src=&quot;/assets/images/aws/aws-ec2-hibernation-flow.webp&quot;&gt;&lt;br&gt;这里详细说明 EC2 Hibernation 的&lt;strong&gt;工作原理&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>AWS EC2的主要特点和工作方式以及计费模式</title>
    <link href="https://stonefishy.github.io/2022/03/02/aws-ec2de-xiang-xi-jie-shao-he-ji-fei-mo-shi/"/>
    <id>https://stonefishy.github.io/2022/03/02/aws-ec2de-xiang-xi-jie-shao-he-ji-fei-mo-shi/</id>
    <published>2022-03-02T03:28:07.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p>Amazon Elastic Compute Cloud（Amazon EC2）是Amazon Web Services（AWS）提供的一项基于云的可伸缩性、弹性、安全性和监控的计算服务，它允许用户租用虚拟服务器（称为EC2实例）来运行应用程序。我们从主要特点，工作方式以及计价模式来介绍下EC2<br><img src="/assets/images/aws/aws-ec2-intro.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ec2-intro.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><span id="more"></span><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><p><strong>可伸缩性 (Scalability)</strong><br>EC2 允许用户根据需要快速扩展或缩减实例数量。这种可伸缩性使您能够适应不断变化的工作负载，确保您的应用程序始终具备所需的计算资源。</p><p><strong>多样性的实例类型 (Diverse Instance Types)</strong><br>AWS 提供多种不同类型的 EC2 实例，以满足各种计算需求。这些类型包括计算优化、内存优化、存储优化、GPU 实例等，每种类型都针对不同类型的工作负载进行了优化。</p><p><strong>弹性IP地址 (Elastic IP Addresses)</strong><br>您可以分配弹性 IP 地址给 EC2 实例，确保即使实例停止和重新启动，IP 地址也能保持不变。这有助于确保应用程序的连通性。</p><p><strong>安全组和网络 ACL (Security Groups and Network ACLs)</strong><br>EC2 允许您配置安全组和网络 ACL，以控制实例的入站和出站流量。这提供了一层网络安全性，以确保只有授权的流量可以访问实例。</p><p><strong>Amazon Machine Images (AMIs)</strong><br>AMIs 是虚拟机镜像，包含了操作系统、应用程序和配置信息。您可以使用标准 AMIs 或创建自定义 AMIs 来启动 EC2 实例，从而简化部署。</p><p><strong>多个操作系统支持 (Multiple OS Support)</strong><br>EC2 支持多种操作系统，包括各种 Linux 发行版、Windows Server 和其他操作系统。这使您可以选择适合您应用程序的操作系统。</p><p><strong>自动化和托管选项 (Automation and Managed Options)</strong><br>EC2 实例可以与其他 AWS 服务集成，如 AWS Auto Scaling、Elastic Load Balancing 和 AWS Elastic Beanstalk，以实现自动化部署和托管。</p><p><strong>监控和警报 (Monitoring and Alerts)</strong><br>EC2 实例集成了 Amazon CloudWatch，可监控实例的性能和状态，并配置警报以及自动响应性能问题。</p><p><strong>可靠性和容错性 (Reliability and Fault Tolerance)</strong><br>EC2 提供高可用性和容错性，实例可以在不同的可用性区域和可用性域中运行，以确保服务的连续性。</p><p><strong>身份和访问管理 (Identity and Access Management)</strong><br>EC2 实例可以与 AWS Identity and Access Management (IAM) 集成，以进行身份验证和授权，使您能够控制对实例和资源的访问权限。</p><p><strong>多种定价选项 (Pricing Options)</strong><br>EC2 提供多种不同的定价选项，包括按需实例、预留实例、定期实例、Spot 实例等，以满足不同的预算和使用需求。</p><h3 id="工作方式："><a href="#工作方式：" class="headerlink" title="工作方式："></a>工作方式：</h3><p><strong>选择实例类型</strong><br>在使用 EC2 之前，您首先需要选择适合您工作负载需求的 EC2 实例类型。不同类型的实例提供不同的计算、内存、存储和网络性能。您可以根据您的需求来选择。</p><p><strong>启动实例</strong><br>一旦选择了实例类型，您可以使用 Amazon Machine Image（AMI）启动 EC2 实例。AMI 是一个预配置的虚拟机镜像，它包含了操作系统、应用程序和配置信息。您可以选择 AWS 提供的标准 AMI，也可以创建自己的自定义 AMI。</p><p><strong>安全组和密钥对</strong><br>在启动实例时，您可以选择一个或多个安全组，这些安全组定义了实例的入站和出站流量规则，以确保安全性。您还可以选择密钥对，以便安全地访问您的 EC2 实例。</p><p><strong>运行实例</strong><br>一旦实例启动，它将在 AWS 的数据中心中的物理服务器上运行。您可以通过 SSH（对于 Linux 实例）或 RDP（对于 Windows 实例）等远程协议连接到实例。</p><p><strong>管理实例</strong><br>一旦运行，您可以随时管理 EC2 实例。这包括启动、停止、重启、终止实例，以及更改实例的配置，如调整实例大小、添加存储卷等。</p><p><strong>存储和快照</strong><br>EC2 实例通常附带 Elastic Block Store（EBS）卷，您可以使用这些卷来存储数据。您还可以创建 EBS 快照，以备份数据或复制数据到其他地方。</p><p><strong>监控和伸缩</strong><br>AWS 提供了 Amazon CloudWatch，它可以用于监视 EC2 实例的性能指标，如 CPU 使用率、网络流量等。您可以设置警报以响应性能问题，并根据需要配置自动伸缩策略，以自动调整实例数量。</p><p><strong>安全性和身份验证</strong><br>EC2 实例可以与 AWS Identity and Access Management（IAM）集成，以实现身份验证和授权。您可以为实例分配 IAM 角色，以便它们可以访问其他 AWS 服务或资源，而无需硬编码的凭据。</p><h3 id="计费模式"><a href="#计费模式" class="headerlink" title="计费模式"></a>计费模式</h3><p><strong>按需实例 (On-Demand Instances)</strong><br>按需实例是一种灵活的计费方式，您只需为您实际使用的计算资源付费，没有长期合同或预付费。这意味着您可以随时启动或停止实例，只支付实际的运行时间。</p><p>适用于需要灵活性的工作负载，如开发和测试、临时工作负载、突发性工作负载。</p><p><strong>预留实例 (Reserved Instances)</strong><br>预留实例是一种合同制度，您提前支付一定费用，获得对特定实例类型的一定时期内的折扣，通常为1年或3年。这通常比按需实例更经济。</p><p>适用于长期工作负载，可以预测的、稳定的使用情况，例如生产服务器。</p><p><strong>可用性区域保留实例 (Reserved Instances for Availability Zones)</strong><br>这是预留实例的一种变种，允许您为特定的可用性区域（AZ）购买预留容量。这对于需要在特定区域内保留容量的应用程序非常有用。</p><p>适用于需要确保在特定可用性区域内拥有计算资源的工作负载。</p><p><strong>可调整实例 (Convertible Reserved Instances)</strong><br>这是一种预留实例，允许在合同期内更改实例类型，以适应不同的工作负载需求。</p><p>适用于工作负载需求可能会变化的情况，但仍然希望获得折扣。</p><p><strong>定期实例 (Scheduled Instances)</strong><br>定期实例允许您按预定的时间启动 EC2 实例。您可以在每天的特定时间、每周某个时间或其他预定时间启动实例。</p><p>适用于周期性的、预定的工作负载，如每天备份、批处理处理等。</p><p><strong>批量实例 (Spot Instances)</strong><br>Spot 实例基于竞价定价模式，您可以设定愿意支付的价格，当市场价格低于您的出价时，您可以获得实例。但它们可能随时被终止。</p><p>适用于可以容忍实例随时中断的工作负载，如大规模数据分析和渲染任务。</p><p><strong>Dedicated Hosts（专用主机）</strong><br>专用主机允许您在 AWS 的物理服务器上运行 EC2 实例，这些服务器专门为您的账户保留。这提供了硬件级别的隔离，适用于具有特殊合规性要求的工作负载。</p><p>适用于需要硬件隔离的工作负载，例如合规性要求非常高的应用程序，或者需要将许多实例部署到同一物理服务器上的场景。</p><p><strong>Dedicated Instances（专用实例）</strong><br>专用实例是 EC2 实例，它们在共享的物理服务器上运行，但只与您的账户中的其他实例共享。这提供了实例级别的隔离。</p><p>适用于需要实例级别隔离的工作负载，但不需要物理主机级别的隔离的场景。</p><p><strong>Free Tier（免费层级）</strong><br>AWS 提供了一定程度的免费使用，即免费层级，对于新用户以及AWS账户中的某些服务和资源，提供有限的免费额度，通常为12个月。这是用于学习、试验和小型项目的好方法，以降低成本。</p><p>适用于学习 AWS、开发和测试小型应用程序，或者初期的小规模项目。</p><p>这些计费模式为不同的使用情况提供了各种选择。您可以根据您的需求和预算来选择适合您的模式。请注意，AWS定期更新其价格和计费模式，因此建议查看官方文档以获取最新的信息。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Amazon Elastic Compute Cloud（Amazon EC2）是Amazon Web Services（AWS）提供的一项基于云的可伸缩性、弹性、安全性和监控的计算服务，它允许用户租用虚拟服务器（称为EC2实例）来运行应用程序。我们从主要特点，工作方式以及计价模式来介绍下EC2&lt;br&gt;&lt;img src=&quot;/assets/images/aws/aws-ec2-intro.webp&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>AWS IAM原理以及如何使用</title>
    <link href="https://stonefishy.github.io/2022/02/17/aws-iamyuan-li-yi-ji-ru-he-shi-yong/"/>
    <id>https://stonefishy.github.io/2022/02/17/aws-iamyuan-li-yi-ji-ru-he-shi-yong/</id>
    <published>2022-02-17T15:22:57.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p>AWS Identity and Access Management（<code>IAM</code>）是Amazon Web Services（AWS）提供的身份和访问管理服务，用于安全地管理对AWS资源的访问权限。IAM使您能够精细控制用户、组、角色等实体对AWS服务和资源的访问权限，以确保安全性和合规性。</p><h3 id="IAM的原理"><a href="#IAM的原理" class="headerlink" title="IAM的原理"></a>IAM的原理</h3><p>IAM基于一些核心概念：</p><p><strong>用户（Users）：</strong> 代表实际的个人用户，可以分配安全凭证（如访问密钥、密码）来访问AWS资源。<br><img src="/assets/images/aws/aws-iam-users.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-iam-users.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><span id="more"></span><p><strong>组（Groups）：</strong> 用于将一组用户组合在一起，并将一组权限分配给该组，从而简化权限管理。<br><img src="/assets/images/aws/aws-iam-groups.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-iam-groups.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>角色（Roles）：</strong> 类似于用户，但不是直接分配给人，而是分配给AWS资源（例如EC2实例）。角色可以用于临时授权。<br><img src="/assets/images/aws/aws-iam-roles.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-iam-roles.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>权限策略（Permissions Policies）：</strong><br>定义了用户、组或角色可以执行的特定操作的权限。AWS提供了许多预定义的权限策略，同时也可以创建自定义策略。<br><img src="/assets/images/aws/aws-iam-policies.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-iam-policies.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="如何使用IAM"><a href="#如何使用IAM" class="headerlink" title="如何使用IAM"></a>如何使用IAM</h3><p><strong>创建用户和组：</strong> 在IAM中，您可以创建用户，并将用户组合成组。然后，为用户分配安全凭证和权限。</p><p><strong>定义和分配权限：</strong> 您可以使用AWS提供的预定义权限策略，也可以创建自定义策略，然后将这些策略附加到用户、组或角色上，以控制他们对资源的访问。</p><p><strong>使用角色：</strong> 如果您的应用程序需要访问AWS服务，可以创建角色，并将这些角色附加到您的应用程序或服务中。这样，您可以避免将敏感的凭证嵌入到应用程序代码中。</p><p><strong>多因素认证（MFA）：</strong> 您可以启用多因素认证来增加账户的安全性，要求用户在登录时提供额外的身份验证信息。</p><p><strong>访问审计：</strong> IAM提供了日志记录功能，可记录用户在AWS资源上执行的操作，以便进行审计和安全分析。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>在使用IAM时，建议采用以下最佳实践，例如：</p><p><strong>最小权限原则：</strong> 为用户和角色提供所需的最小权限，以减少潜在的安全风险。</p><p><strong>使用身份提供商：</strong> 将身份提供商（如企业目录）与IAM集成，以便集中管理用户和权限。</p><p><strong>定期审查权限：</strong> 定期审查用户、组和角色的权限，确保权限保持最新且合规。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;AWS Identity and Access Management（&lt;code&gt;IAM&lt;/code&gt;）是Amazon Web Services（AWS）提供的身份和访问管理服务，用于安全地管理对AWS资源的访问权限。IAM使您能够精细控制用户、组、角色等实体对AWS服务和资源的访问权限，以确保安全性和合规性。&lt;/p&gt;
&lt;h3 id=&quot;IAM的原理&quot;&gt;&lt;a href=&quot;#IAM的原理&quot; class=&quot;headerlink&quot; title=&quot;IAM的原理&quot;&gt;&lt;/a&gt;IAM的原理&lt;/h3&gt;&lt;p&gt;IAM基于一些核心概念：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户（Users）：&lt;/strong&gt; 代表实际的个人用户，可以分配安全凭证（如访问密钥、密码）来访问AWS资源。&lt;br&gt;&lt;img src=&quot;/assets/images/aws/aws-iam-users.webp&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>聊聊前端优化手段防抖</title>
    <link href="https://stonefishy.github.io/2017/03/16/liao-liao-qian-duan-you-hua-shou-duan-fang-dou/"/>
    <id>https://stonefishy.github.io/2017/03/16/liao-liao-qian-duan-you-hua-shou-duan-fang-dou/</id>
    <published>2017-03-16T08:29:09.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p>在前端开发中，<strong>防抖（Debouncing）</strong> 是一种常用的优化技术，用于处理频繁触发的事件，如浏览器窗口的resize、input输入等。<strong>防抖的目标是在事件被触发后，等待一段时间，只执行一次事件处理函数，以避免频繁的重复操作</strong>。</p><p><strong>防抖的原理</strong>很简单：当一个事件被触发时，立即设置一个定时器，在规定的时间内没有再次触发该事件时，执行事件处理函数。如果在定时器规定的时间内再次触发了事件，那么就清除前一个定时器，并重新设置新的定时器。这样，只有在事件停止触发一段时间后，才会执行事件处理函数。</p><p>以下是一个防抖的基本实现示例（使用 JavaScript）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 每次执行时，清除之前的定时器</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">//设置新的定时器</span></span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debounceFunction = <span class="title function_">debounce</span>(<span class="function">(<span class="params">args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Debounce function called&quot;</span>, args);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, debounceFunction);</span><br></pre></td></tr></table></figure><span id="more"></span><p>在上面的示例中，debounce 函数接受两个参数：<strong>要执行的事件处理函数</strong>和<strong>延迟时间</strong>（规定的等待时间）。在事件被触发时，debounce 返回一个新的函数，该函数会设置一个定时器来等待延迟时间，然后执行事件处理函数。</p><p>防抖的实现可以根据需要进行适当的调整，例如增加立即执行选项，即在事件触发时立即执行一次事件处理函数，然后再进入防抖模式。这样可以在事件触发的瞬间即时响应，同时仍然保留了后续的防抖效果。</p><p>现在在上面防抖的基础上多增加一个参数，<strong>immediate</strong>， 参数值为true时，函数立即执行，为false时延时执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay, immediate</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;    <span class="comment">// immediate为true，立即执行</span></span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args); <span class="comment">// 立即执行一次事件处理函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            timer = <span class="literal">null</span>; <span class="comment">// delay时间到后，将计时器设置null，下一次立即执行</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//immediate为false，延时执行</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args); <span class="comment">// 在延迟时间后执行事件处理函数</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用防抖处理事件，第一次触发立即执行，之后每次触发等待300毫秒后执行</span></span><br><span class="line"><span class="keyword">const</span> debouncedFunction = <span class="title function_">debounce</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Debounce function called.&quot;</span>);</span><br><span class="line">&#125;, <span class="number">500</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, debouncedFunction);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总的来说，防抖是一种有效的优化手段，可以帮助减少频繁触发的事件造成的重复操作，提升前端应用的性能和用户体验。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前端开发中，&lt;strong&gt;防抖（Debouncing）&lt;/strong&gt; 是一种常用的优化技术，用于处理频繁触发的事件，如浏览器窗口的resize、input输入等。&lt;strong&gt;防抖的目标是在事件被触发后，等待一段时间，只执行一次事件处理函数，以避免频繁的重复操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;防抖的原理&lt;/strong&gt;很简单：当一个事件被触发时，立即设置一个定时器，在规定的时间内没有再次触发该事件时，执行事件处理函数。如果在定时器规定的时间内再次触发了事件，那么就清除前一个定时器，并重新设置新的定时器。这样，只有在事件停止触发一段时间后，才会执行事件处理函数。&lt;/p&gt;
&lt;p&gt;以下是一个防抖的基本实现示例（使用 JavaScript）：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;debounce&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;func, delay&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; timer = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; context = &lt;span class=&quot;variable language_&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; args = &lt;span class=&quot;variable language_&quot;&gt;arguments&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;clearTimeout&lt;/span&gt;(timer); &lt;span class=&quot;comment&quot;&gt;// 每次执行时，清除之前的定时器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        timer = &lt;span class=&quot;built_in&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &amp;#123; &lt;span class=&quot;comment&quot;&gt;//设置新的定时器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            func.&lt;span class=&quot;title function_&quot;&gt;apply&lt;/span&gt;(context, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;, delay);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; debounceFunction = &lt;span class=&quot;title function_&quot;&gt;debounce&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;args&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Debounce function called&amp;quot;&lt;/span&gt;, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable language_&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;title function_&quot;&gt;addEventListener&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;#x27;resize&amp;#x27;&lt;/span&gt;, debounceFunction);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Frontend" scheme="https://stonefishy.github.io/categories/Frontend/"/>
    
    
    <category term="JavaScript" scheme="https://stonefishy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>一个免费高质量的图片分享平台</title>
    <link href="https://stonefishy.github.io/2017/02/23/yi-ge-mian-fei-gao-zhi-liang-de-tu-pian-fen-xiang-ping-tai/"/>
    <id>https://stonefishy.github.io/2017/02/23/yi-ge-mian-fei-gao-zhi-liang-de-tu-pian-fen-xiang-ping-tai/</id>
    <published>2017-02-23T10:02:19.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候在写文章或者制作PPT时需要用到一些图片资源，最近刚好发现了一个实用的高分辨率的免费资源平台Unspash, 跟大家分享一下。<br><img src="/assets/images/ziyuan/laptop-1.png" class="lazyload placeholder" data-srcset="/assets/images/ziyuan/laptop-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a href="https://unsplash.com/" title="免费高质量的图片分享平台">Unsplash.com</a> 是一个知名的免费高质量图片分享平台，提供各种类型的高分辨率摄影图片供用户免费下载和使用。这些图片可以用于个人、商业、创意和学术项目，包括网站、博客、社交媒体、演示文稿等。</p><span id="more"></span><p>这个平台的特点包括：</p><p><strong>高质量图片：</strong> Unsplash 上的图片质量往往很高，包括风景、人物、食物、建筑等多种主题。这些图片通常由专业摄影师拍摄，因此在设计和内容创作中具有很大的价值。<br><img src="/assets/images/ziyuan/fengjing-1.png" class="lazyload placeholder" data-srcset="/assets/images/ziyuan/fengjing-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>免费使用：</strong> Unsplash 的图片都是免费提供的，无需付费或订阅。用户可以自由下载、编辑和使用这些图片，而不需要担心版权问题。<br><img src="/assets/images/ziyuan/coding-1.png" class="lazyload placeholder" data-srcset="/assets/images/ziyuan/coding-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>简单的许可：</strong> Unsplash 使用的是创作共用许可（Creative Commons Zero License），这意味着用户可以自由使用这些图片，甚至可以用于商业目的，无需给予作者署名。<br><img src="/assets/images/ziyuan/license-1.png" class="lazyload placeholder" data-srcset="/assets/images/ziyuan/license-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>搜索和浏览功能：</strong> Unsplash 网站提供搜索功能和浏览不同主题的图片集合，帮助用户快速找到符合自己需求的图片。<br><img src="/assets/images/ziyuan/search-1.png" class="lazyload placeholder" data-srcset="/assets/images/ziyuan/search-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>社区和创作者：</strong> Unsplash 构建了一个活跃的摄影师社区，用户可以查看摄影师的个人主页，了解他们的作品，并选择关注自己喜欢的创作者。<br><img src="/assets/images/ziyuan/community-1.png" class="lazyload placeholder" data-srcset="/assets/images/ziyuan/community-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>总的来说，Unsplash.com 是一个受欢迎的图片资源平台，适用于需要高质量图片的个人和商业项目。真的是一个很棒的资源平台！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很多时候在写文章或者制作PPT时需要用到一些图片资源，最近刚好发现了一个实用的高分辨率的免费资源平台Unspash, 跟大家分享一下。&lt;br&gt;&lt;img src=&quot;/assets/images/ziyuan/laptop-1.png&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://unsplash.com/&quot; title=&quot;免费高质量的图片分享平台&quot;&gt;Unsplash.com&lt;/a&gt; 是一个知名的免费高质量图片分享平台，提供各种类型的高分辨率摄影图片供用户免费下载和使用。这些图片可以用于个人、商业、创意和学术项目，包括网站、博客、社交媒体、演示文稿等。&lt;/p&gt;</summary>
    
    
    
    <category term="Resources" scheme="https://stonefishy.github.io/categories/Resources/"/>
    
    
    <category term="高清图片" scheme="https://stonefishy.github.io/tags/%E9%AB%98%E6%B8%85%E5%9B%BE%E7%89%87/"/>
    
    <category term="资源" scheme="https://stonefishy.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>最短子数组之和</title>
    <link href="https://stonefishy.github.io/2016/03/01/minimum-size-subarray-sum/"/>
    <id>https://stonefishy.github.io/2016/03/01/minimum-size-subarray-sum/</id>
    <published>2016-03-01T09:18:50.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p>一个常见的最短子数组算法题是 “Minimum Size Subarray Sum”。在这个问题中，给定一个正整数数组和一个目标值，要找到数组中一个连续子数组，使得子数组的元素和大于等于目标值，并且子数组的长度最小。</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入： </span><br><span class="line">数组: [5, 3, 4, 2, 8, 5];  目标值: 10</span><br><span class="line">输出：</span><br><span class="line">[2, 8]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入： </span><br><span class="line">数组: [5, 3, 4, 2, 8, 5];  目标值: 28</span><br><span class="line">输出：</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入： </span><br><span class="line">数组: [5, 3, 4, 2, 8, 5];  目标值: 4</span><br><span class="line">输出：</span><br><span class="line">[5]</span><br></pre></td></tr></table></figure><p>这个问题可以使用双指针来解决窗口的滑动问题，核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] minSizeSubArray(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>, p2 = <span class="number">0</span>; <span class="comment">//定义两个指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minLeft</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最小子数组的左边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE; <span class="comment">// 最小子数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//子数组元素和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p2 = <span class="number">0</span>; p2 &lt; numbers.length; p2++) &#123;</span><br><span class="line">        sum += numbers[p2]; <span class="comment">// 将右指针的元素加入子数组</span></span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123; <span class="comment">// 如果子数组的和大于等于目标值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">curLen</span> <span class="operator">=</span> p2 - p1 + <span class="number">1</span>; <span class="comment">// 获取当前子数组长度</span></span><br><span class="line">            <span class="keyword">if</span> (minLen &gt; curLen) &#123; <span class="comment">// 如果子数组长度比上次还更小</span></span><br><span class="line">                minLen = curLen; <span class="comment">// 更新子数组最小长度</span></span><br><span class="line">                minLeft = p1;   <span class="comment">// 更新子数组的左边界</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum -= numbers[p1]; <span class="comment">// 将左指针的元素从子数组中移除</span></span><br><span class="line">            p1++;   <span class="comment">//移动左指针，缩小子数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minLen == Integer.MAX_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];  <span class="comment">// 没有找到匹配的子数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//根据子数组的左边界以及长度，返回子数组</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[minLen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; minLen; i++) &#123;</span><br><span class="line">            result[i] = numbers[i + minLeft];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用了两个指针 p1 和 p2，分别表示子数组的左右边界。我们在数组上使用滑动窗口来寻找满足条件的最短子数组。当子数组的和大于等于目标值时，我们移动左指针，并更新最小长度。如果发现有更小的数组长度，则更新最小数组长度以及数组的左边界值，当子数组的和不足以满足条件时，我们移动右指针，并继续扩展子数组。</p><p>测试结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] numbers = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    printArray(minSizeSubArray(numbers, <span class="number">10</span>)); <span class="comment">// [2, 8]</span></span><br><span class="line">    printArray(minSizeSubArray(numbers, <span class="number">28</span>)); <span class="comment">// []</span></span><br><span class="line">    printArray(minSizeSubArray(numbers, <span class="number">4</span>)); <span class="comment">// [5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        sb.append(numbers[i]).append(i == numbers.length - <span class="number">1</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个常见的最短子数组算法题是 “Minimum Size Subarray Sum”。在这个问题中，给定一个正整数数组和一个目标值，要找到数组中一个连续子数组，使得子数组的元素和大于等于目标值，并且子数组的长度最小。&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;数组: [5, 3, 4, 2, 8, 5];  目标值: 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[2, 8]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;数组: [5, 3, 4, 2, 8, 5];  目标值: 28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法" scheme="https://stonefishy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://stonefishy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://stonefishy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>双指针算法之两数之和</title>
    <link href="https://stonefishy.github.io/2016/02/05/shuang-zhi-zhen-suan-fa-zhi-liang-shu-zhi-he/"/>
    <id>https://stonefishy.github.io/2016/02/05/shuang-zhi-zhen-suan-fa-zhi-liang-shu-zhi-he/</id>
    <published>2016-02-05T01:51:39.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇中，我们讲到了双指针算法的几种使用场景，这里具体举例，以经典的两数之和为例。</p><p>给定一个有序数字的数组和一个目标值，在有序数组中找到两个数字之和等于该目标值，返回包含两个数字的数组，如果没有找到返回包含两个-1值的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">找到的情况</span><br><span class="line">输入： </span><br><span class="line">有序数组: [2, 4, 5, 6, 12];  目标值: 10</span><br><span class="line">输出：</span><br><span class="line">[4, 6]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">找不到的情况</span><br><span class="line">输入： </span><br><span class="line">有序数组: [2, 4, 5, 6, 12];  目标值: 3</span><br><span class="line">输出：</span><br><span class="line">[-1, -1]</span><br></pre></td></tr></table></figure><span id="more"></span><p>直接代码走起，下面以Java代码为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findNumbers(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pLeft</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 左指针初始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pRight</span> <span class="operator">=</span> numbers.length - <span class="number">1</span>; <span class="comment">// 右指针初始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pLeft &lt; pRight) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[pLeft] + numbers[pRight];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;numbers[pLeft], numbers[pRight]&#125;; <span class="comment">// 返回匹配的元素</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                pLeft++; <span class="comment">// 和小于目标值，左指针右移</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pRight--; <span class="comment">// 和大于目标值，右指针左移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] results = findNumbers(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">12</span>&#125;, <span class="number">10</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;[%d, %d]%n&quot;</span>, results[<span class="number">0</span>], results[<span class="number">1</span>]); <span class="comment">// 输出 [4, 6]</span></span><br><span class="line"></span><br><span class="line">        results = findNumbers(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">12</span>&#125;, <span class="number">3</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;[%d, %d]%n&quot;</span>, results[<span class="number">0</span>], results[<span class="number">1</span>]); <span class="comment">// 输出 [-1, -1]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用了两个指针 pLeft 和 pRight 分别指向有序数组的两端。然后，我们计算 numbers[pLeft] 和 numbers[pRight] 的和，并与目标值进行比较。根据和与目标值的大小关系，我们移动左指针或右指针，直到找到符合条件的元素对，或者指针重合没有找到。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一篇中，我们讲到了双指针算法的几种使用场景，这里具体举例，以经典的两数之和为例。&lt;/p&gt;
&lt;p&gt;给定一个有序数字的数组和一个目标值，在有序数组中找到两个数字之和等于该目标值，返回包含两个数字的数组，如果没有找到返回包含两个-1值的数组。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;找到的情况&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;有序数组: [2, 4, 5, 6, 12];  目标值: 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4, 6]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;找不到的情况&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;有序数组: [2, 4, 5, 6, 12];  目标值: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[-1, -1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法" scheme="https://stonefishy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://stonefishy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://stonefishy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>双指针算法</title>
    <link href="https://stonefishy.github.io/2016/01/25/shuang-zhi-zhen-suan-fa/"/>
    <id>https://stonefishy.github.io/2016/01/25/shuang-zhi-zhen-suan-fa/</id>
    <published>2016-01-25T01:09:24.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p>双指针算法（Two Pointer Algorithm）是一种常见的算法技巧，通常用于数组、链表等数据结构中解决一些问题。双指针算法的核心思想是使用两个指针在不同的位置上移动，以达到解决问题的目的。这两个指针可以朝着相同的方向移动，也可以朝着相反的方向移动，视问题而定。</p><p>双指针算法的常见应用场景和实现方法：</p><p><strong>对撞指针（Two Sum、Three Sum）：</strong> 在有序数组中查找满足特定条件的元素对或元素组合。使用两个指针分别从数组的两端开始，向中间逼近，根据元素之间的大小关系，调整指针的位置。</p><p><strong>快慢指针（环形链表判断、链表中间节点）：</strong> 在链表中判断是否存在环或找到链表的中间节点。使用两个指针，一个快指针每次移动两步，一个慢指针每次移动一步，根据指针的移动速度判断链表的性质。</p><span id="more"></span><p><strong>滑动窗口（子数组问题、字符串问题）：</strong> 用于解决一些窗口内的问题，例如找到最短子数组、找到最长连续子数组等。使用两个指针表示窗口的左右边界，移动窗口进行计算。</p><p><strong>夹逼法（容器装水问题、三数最接近问题）：</strong> 在一维数组中寻找满足特定条件的元素对。使用两个指针从两端开始，逐渐向中间夹逼，根据元素之间的大小关系，调整指针的位置。</p><p><strong>多指针法（四数之和问题、删除排序数组中的重复项）：</strong> 在一维或二维数组中寻找满足特定条件的元素组合。使用多个指针在数组中移动，根据问题需要，进行相应的指针调整。</p><p>双指针算法的优势在于它可以在O(N)的时间复杂度内解决一些复杂的问题，而不需要使用额外的空间。它在数组和链表等数据结构上都有广泛的应用，常用于解决数组遍历、查找、排序和操作等问题。这种算法可以帮助简化问题的解决过程，提高代码效率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;双指针算法（Two Pointer Algorithm）是一种常见的算法技巧，通常用于数组、链表等数据结构中解决一些问题。双指针算法的核心思想是使用两个指针在不同的位置上移动，以达到解决问题的目的。这两个指针可以朝着相同的方向移动，也可以朝着相反的方向移动，视问题而定。&lt;/p&gt;
&lt;p&gt;双指针算法的常见应用场景和实现方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对撞指针（Two Sum、Three Sum）：&lt;/strong&gt; 在有序数组中查找满足特定条件的元素对或元素组合。使用两个指针分别从数组的两端开始，向中间逼近，根据元素之间的大小关系，调整指针的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快慢指针（环形链表判断、链表中间节点）：&lt;/strong&gt; 在链表中判断是否存在环或找到链表的中间节点。使用两个指针，一个快指针每次移动两步，一个慢指针每次移动一步，根据指针的移动速度判断链表的性质。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://stonefishy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://stonefishy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://stonefishy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>How to fix Gem FilePermissionError</title>
    <link href="https://stonefishy.github.io/2016/01/12/how-to-fix-gem-filepermissionerror/"/>
    <id>https://stonefishy.github.io/2016/01/12/how-to-fix-gem-filepermissionerror/</id>
    <published>2016-01-12T15:31:35.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<p>Sometimes we face the erorr “Gem::FilePermissionError: You don’t have write permissions for the &#x2F;Library&#x2F;Ruby&#x2F;Gems&#x2F;x.x.x directory”. This error message indicates that the user doesn’t have the necessary permissions to install Ruby gems system-wide. This is because the system Ruby installation requires administrative privileges to modify its gem directory.</p><p>To resolve this issue, there is a few options:</p><h3 id="1-Use-a-Ruby-Version-Manager-Recommended"><a href="#1-Use-a-Ruby-Version-Manager-Recommended" class="headerlink" title="1. Use a Ruby Version Manager (Recommended)"></a>1. Use a Ruby Version Manager (Recommended)</h3><p>Instead of installing gems globally, consider using a Ruby version manager like <code>rbenv</code> or <code>RVM</code>. These tools allow you to manage multiple Ruby versions and gems without requiring administrative permissions.</p><h4 id="Using-rbenv"><a href="#Using-rbenv" class="headerlink" title="Using rbenv"></a>Using rbenv</h4><pre><code>1. Install rbenv if you haven&#39;t already.2. Install the desired version of Ruby using rbenv.3. Install gems without needing elevated permissions.</code></pre><h4 id="Using-RVM"><a href="#Using-RVM" class="headerlink" title="Using RVM"></a>Using RVM</h4><pre><code>1. Install RVM if you haven&#39;t already.2. Install the desired version of Ruby using RVM.3. Use the installed Ruby version without needing elevated permissions to install gems.</code></pre><span id="more"></span><h3 id="2-Install-Gems-Locally"><a href="#2-Install-Gems-Locally" class="headerlink" title="2. Install Gems Locally"></a>2. Install Gems Locally</h3><p>If you want to install gems for the system Ruby without using a version manager, you’ll need administrative privileges. You can use the sudo command to install gems as the superuser:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install gem_name</span><br></pre></td></tr></table></figure><p>However, keep in mind that modifying the system Ruby environment might affect other applications, and it’s generally recommended to use a version manager to manage Ruby environments.</p><h3 id="3-Use-–user-install-Option"><a href="#3-Use-–user-install-Option" class="headerlink" title="3. Use –user-install Option"></a>3. Use –user-install Option</h3><p>If you want to install gems locally without administrative privileges, you can use the <strong>–user-install</strong> option:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install gem_name --user-install</span><br></pre></td></tr></table></figure><p>This installs the gem in your user’s home directory, avoiding the need for system-wide modifications.</p><h3 id="4-Install-to-Custom-Directory"><a href="#4-Install-to-Custom-Directory" class="headerlink" title="4. Install to Custom Directory"></a>4. Install to Custom Directory</h3><p>You can configure gems to be installed in a specific directory where you have write permissions. This involves configuring the <strong>GEM_HOME</strong> and <strong>GEM_PATH</strong> environment variables:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GEM_HOME=<span class="variable">$HOME</span>/gems</span><br><span class="line"><span class="built_in">export</span> GEM_PATH=<span class="variable">$GEM_HOME</span>:/path/to/system/gems</span><br><span class="line">gem install gem_name</span><br></pre></td></tr></table></figure><p>Make sure to adjust the paths according to your preferences.</p><p>In general, using a Ruby version manager like <strong>rbenv</strong> or <strong>RVM</strong> is recommended, as it provides a more flexible and isolated way to manage Ruby versions and gems without affecting system-wide configurations or requiring administrative permissions.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Sometimes we face the erorr “Gem::FilePermissionError: You don’t have write permissions for the &amp;#x2F;Library&amp;#x2F;Ruby&amp;#x2F;Gems&amp;#x2F;x.x.x directory”. This error message indicates that the user doesn’t have the necessary permissions to install Ruby gems system-wide. This is because the system Ruby installation requires administrative privileges to modify its gem directory.&lt;/p&gt;
&lt;p&gt;To resolve this issue, there is a few options:&lt;/p&gt;
&lt;h3 id=&quot;1-Use-a-Ruby-Version-Manager-Recommended&quot;&gt;&lt;a href=&quot;#1-Use-a-Ruby-Version-Manager-Recommended&quot; class=&quot;headerlink&quot; title=&quot;1. Use a Ruby Version Manager (Recommended)&quot;&gt;&lt;/a&gt;1. Use a Ruby Version Manager (Recommended)&lt;/h3&gt;&lt;p&gt;Instead of installing gems globally, consider using a Ruby version manager like &lt;code&gt;rbenv&lt;/code&gt; or &lt;code&gt;RVM&lt;/code&gt;. These tools allow you to manage multiple Ruby versions and gems without requiring administrative permissions.&lt;/p&gt;
&lt;h4 id=&quot;Using-rbenv&quot;&gt;&lt;a href=&quot;#Using-rbenv&quot; class=&quot;headerlink&quot; title=&quot;Using rbenv&quot;&gt;&lt;/a&gt;Using rbenv&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1. Install rbenv if you haven&amp;#39;t already.
2. Install the desired version of Ruby using rbenv.
3. Install gems without needing elevated permissions.
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;Using-RVM&quot;&gt;&lt;a href=&quot;#Using-RVM&quot; class=&quot;headerlink&quot; title=&quot;Using RVM&quot;&gt;&lt;/a&gt;Using RVM&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1. Install RVM if you haven&amp;#39;t already.
2. Install the desired version of Ruby using RVM.
3. Use the installed Ruby version without needing elevated permissions to install gems.
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="Backend" scheme="https://stonefishy.github.io/categories/Backend/"/>
    
    
    <category term="Tool" scheme="https://stonefishy.github.io/tags/Tool/"/>
    
    <category term="Ruby" scheme="https://stonefishy.github.io/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Ruby修炼之道(18)</title>
    <link href="https://stonefishy.github.io/2015/12/28/ruby-practice-18/"/>
    <id>https://stonefishy.github.io/2015/12/28/ruby-practice-18/</id>
    <published>2015-12-28T02:59:48.000Z</published>
    <updated>2023-09-23T16:03:49.013Z</updated>
    
    <content type="html"><![CDATA[<h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>Ruby程序在启动后会预先分配3个<strong>IO</strong>对象:<br>标准输入 - 预定义常量(<strong>STDIN</strong>), 全局变量(<strong>$stdin</strong>)<br>标准输出 - 预定义常量(<strong>STDOUT</strong>), 全局变量(<strong>$stdout</strong>)<br>标准错误输出 - 预定义常量(<strong>STDERR</strong>), 全局变量(<strong>$stderr</strong>)</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$stdout</span>.print <span class="string">&quot;output something from $stdout\n&quot;</span></span><br><span class="line"><span class="variable constant_">STDERR</span>.print <span class="string">&quot;output something from $stderr\n&quot;</span></span><br></pre></td></tr></table></figure><p>IO对象是否与控制台关联，我们可以通过**tty?**方法来判断。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable">$stdin</span>.tty?</span><br><span class="line">  print <span class="string">&quot;stdin is a tty&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  print <span class="string">&quot;stdin is not a tty&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><p>通过File.open方法或open方法打开文件并获取新的IO对象，</p><pre><code>io = File.open(file, mode)io = open(file, mode)</code></pre><p>mode为文件的读写方法，缺省情况下为只读模式(r).</p><p>r  - 只读模式<br>r+ - 读写模式<br>w  - 只写模式，如果文件不存在则创建新文件，如果文件存在，则清空文件<br>w+ - 读写模式，其余同w<br>a  - 追加模式，文件不存在则创建新文件<br>a+ - 读取、追加模式，文件不存在则创建新文件    </p><p>io.<strong>close</strong><br>使用<strong>close</strong>方法关闭已打开的文件。File.open方法使用块，则文件会在使用完毕后自动关闭，io变量会被作为块变量传递给块。并且使用io.closed?方法可以检查是否关闭。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">File</span>.open(<span class="string">&quot;tty.rb&quot;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  <span class="keyword">while</span> line = io.gets</span><br><span class="line">    print line</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<strong>File.read</strong>可以一次性读取文件的内容。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="title class_">File</span>.read(<span class="string">&quot;tty.rb&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="基本输入"><a href="#基本输入" class="headerlink" title="基本输入"></a>基本输入</h5><p>io.<strong>gets</strong>(rs)<br>io.<strong>each</strong>(rs)<br>io.<strong>each_line</strong>(rs)<br>io.<strong>readlines</strong>(rs)<br>从IO类的对象中读取一行数据，用参数<strong>rs</strong>的字符串分行，缺省模式下为换行符。</p><p>使用**eof?**可以检查输入是否已经完毕。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">io = <span class="title class_">File</span>.open(<span class="string">&quot;tty.rb&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> line = io.gets</span><br><span class="line">  line.chomp!</span><br><span class="line">  print line</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">p io.eof?     <span class="comment">#=&gt; true</span></span><br><span class="line">io.close      <span class="comment">#=&gt; close file</span></span><br><span class="line">p io.closed?   <span class="comment">#=&gt; true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用<strong>readlines</strong>方法可以一次性读取所有数据，并返回将每行数据作为元素封装的数组.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">io = <span class="title class_">File</span>.open(<span class="string">&quot;tty.rb&quot;</span>)</span><br><span class="line">ary = io.readlines</span><br><span class="line">io.close</span><br><span class="line">ary.each <span class="keyword">do</span> |<span class="params">line</span>|</span><br><span class="line">  line.chomp!</span><br><span class="line">  print line</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>io.<strong>lineno</strong><br>使用gets方法，each_line方法逐行读取文件时，io会自动记录读取的行数，可以通过<strong>io.lineno</strong>来获取当前行数。   </p><p>io.<strong>each_char</strong><br>逐个字符读取io对象中的数据,并启动块。   </p><p>io.<strong>each_byte</strong><br>逐个字节读取io对象中的数据，并启动块。    </p><p>io.<strong>getc</strong><br>只读取io对象中的一个字符。<br>io.<strong>ungetc(ch)</strong><br>将参数ch指定的字符退回到io得缓冲流中   </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">File</span>.open(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  io.write(<span class="string">&quot;Hello Ruby&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="title class_">File</span>.open(<span class="string">&quot;hello.txt&quot;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  p io.getc       <span class="comment">#=&gt; H</span></span><br><span class="line">  io.ungetc(<span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">  p io.gets       <span class="comment">#=&gt; Hello Ruby</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span>.delete(<span class="string">&quot;hello.txt&quot;</span>)</span><br></pre></td></tr></table></figure><p>io.<strong>getbyte</strong>, io.<strong>ungetbyte</strong>的使用方法同上，不同之处在于此处是字节。    </p><p>io.<strong>read</strong>(size)<br>读取参数size指定大小的数据，如果没指定，则一次性读取所有数据。    </p><h5 id="输出操作"><a href="#输出操作" class="headerlink" title="输出操作"></a>输出操作</h5><p>io.<strong>puts</strong>(str0, str1, …)<br>指定多个字符串时，会在每个字符串后面添加换行符。   </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$stdout</span>.puts <span class="string">&quot;hi&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hey&quot;</span><span class="comment">#=&gt; hi\nhello\nhey\n</span></span><br></pre></td></tr></table></figure><p>io.<strong>putc</strong>(ch)<br>输出指定参数ch字符，如果参数为字符串，则输出首个字符    </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$stdout</span>.putc(<span class="string">&#x27;H&#x27;</span>)       <span class="comment">#=&gt; H</span></span><br><span class="line"><span class="variable">$stdout</span>.putc(<span class="string">&#x27;Hello&#x27;</span>)   <span class="comment">#=&gt; H</span></span><br><span class="line"><span class="variable">$stdout</span>.putc(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>io.<strong>print</strong>(str0, str1, …)<br>输出参数指定的字符串，不会在每个字符串后面追加换行符    </p><p>io.<strong>printf</strong>(fmt, arg0, arg1, …)<br>按照指定格式输出字符串。    </p><p>io.<strong>write</strong>(str)<br>输出参数str指定的字符串，方法返回值为输出的字节数    </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="variable">$stdout</span>.write(<span class="string">&quot;Hello&quot;</span>)<span class="comment">#=&gt; Hello</span></span><br><span class="line">p size<span class="comment">#=&gt; 5</span></span><br></pre></td></tr></table></figure><h5 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h5><p>用文件指针或者当前文件偏移量来表示IO对象指向文件的位置。    </p><p>io.<strong>pos</strong><br>io.<strong>pos</strong>&#x3D;position<br>通过<strong>pos</strong>方法获取文件指针位置，改变文件指针使用**pos&#x3D;**方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">File</span>.open(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  io.write(<span class="string">&quot;Hello Ruby&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="title class_">File</span>.open(<span class="string">&quot;hello.txt&quot;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  p io.read(<span class="number">5</span>)      <span class="comment">#=&gt; Hello</span></span><br><span class="line">  io.pos = <span class="number">0</span></span><br><span class="line">  p io.gets         <span class="comment">#=&gt; Hello Ruby</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>io.<strong>seek</strong>(offset, whence)<br>offset为指定位置的整数，whence为指定offset如何移动， 以下为whence的值:<br>IO::SEEK_SET - 将文件指针移动到指定offset指定的位置<br>IO::SEEK_CUR - 将offset视为相对于当前位置的偏移位置来移动文件指针<br>IO::SEEK_END - 将offset视为相对于文件末尾的偏移位置  </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">File</span>.open(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  io.write(<span class="string">&quot;Hello Ruby&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="title class_">File</span>.open(<span class="string">&quot;hello.txt&quot;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  p io.read(<span class="number">5</span>)      <span class="comment">#=&gt; Hello</span></span><br><span class="line">  io.seek(-<span class="number">5</span>, <span class="variable constant_">IO</span><span class="symbol">:</span><span class="symbol">:SEEK_CUR</span>)</span><br><span class="line">  p io.gets         <span class="comment">#=&gt; Hello Ruby</span></span><br><span class="line">  io.seek(<span class="number">0</span>, <span class="variable constant_">IO</span><span class="symbol">:</span><span class="symbol">:SEEK_SET</span>)</span><br><span class="line">  p io.gets         <span class="comment">#=&gt; Hello Ruby</span></span><br><span class="line">  io.seek(-<span class="number">4</span>, <span class="variable constant_">IO</span><span class="symbol">:</span><span class="symbol">:SEEK_END</span>)</span><br><span class="line">  p io.gets         <span class="comment">#=&gt; Ruby</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>io.<strong>rewind</strong><br>将文件指针重置到文件开始处，结果同以下两个操作:    </p><pre><code>io.pos = 0   io.seek(0, IO::SEEK_SET)</code></pre><p>io.<strong>truncate</strong>(size)<br>按照参数size指定的大小截断文件。</p><p>*注，新的IO对象默认为文本模式，可以通过io.<strong>binmode</strong>将其转为二进制模式*   </p><h5 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h5><p>IO对象在输出数据时，结果并不一定会马上输出出来，程序会在内部开辟一个缓冲空间来缓存输出，当空间满的时候再输出来。但是标准错误输出不会使用缓冲，如果有错误信息，则立刻输出。所以标准错误输出一般用于输出警告、错误之类的信息，能够立刻输出数据    </p><p>io.<strong>flush</strong><br>强制输出缓冲中的数据。</p><p>io.<strong>sync</strong><br>io.<strong>sync</strong>&#x3D;state<br>通过io.sync &#x3D; true, 程序写入缓冲时flush方法会被自动调用。    </p><h5 id="与命令行交互"><a href="#与命令行交互" class="headerlink" title="与命令行交互"></a>与命令行交互</h5><p>IO.<strong>popen</strong>(command, mode)<br>command为相关的命令    </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="title class_">Regexp</span>.new(<span class="variable constant_">ARGV</span>[<span class="number">0</span>])</span><br><span class="line">filename = <span class="variable constant_">ARGV</span>[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> /.gz<span class="variable">$/</span> =~ filename</span><br><span class="line">  file = <span class="variable constant_">IO</span>.popen(<span class="string">&quot;gunzip -c <span class="subst">#&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  file = <span class="title class_">File</span>.open(filename)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">file.close</span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**open**(&quot;|command&quot;, mode)   </span></span><br><span class="line"><span class="string">将带有管道符号的命令传递给open方法的效果与使用IO.popen方法是一样的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> ruby</span><br><span class="line">filename = <span class="variable constant_">ARGV</span>[<span class="number">0</span>]</span><br><span class="line">open(<span class="string">&quot;|gunzip -c <span class="subst">#&#123;filename&#125;</span>&quot;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  io.each_line <span class="keyword">do</span> |<span class="params">line</span>|</span><br><span class="line">    print line</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;IO&quot;&gt;&lt;a href=&quot;#IO&quot; class=&quot;headerlink&quot; title=&quot;IO&quot;&gt;&lt;/a&gt;IO&lt;/h4&gt;&lt;p&gt;Ruby程序在启动后会预先分配3个&lt;strong&gt;IO&lt;/strong&gt;对象:&lt;br&gt;标准输入 - 预定义常量(&lt;strong&gt;STDIN&lt;/strong&gt;), 全局变量(&lt;strong&gt;$stdin&lt;/strong&gt;)&lt;br&gt;标准输出 - 预定义常量(&lt;strong&gt;STDOUT&lt;/strong&gt;), 全局变量(&lt;strong&gt;$stdout&lt;/strong&gt;)&lt;br&gt;标准错误输出 - 预定义常量(&lt;strong&gt;STDERR&lt;/strong&gt;), 全局变量(&lt;strong&gt;$stderr&lt;/strong&gt;)&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$stdout&lt;/span&gt;.print &lt;span class=&quot;string&quot;&gt;&amp;quot;output something from $stdout&#92;n&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable constant_&quot;&gt;STDERR&lt;/span&gt;.print &lt;span class=&quot;string&quot;&gt;&amp;quot;output something from $stderr&#92;n&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;IO对象是否与控制台关联，我们可以通过**tty?**方法来判断。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$stdin&lt;/span&gt;.tty?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  print &lt;span class=&quot;string&quot;&gt;&amp;quot;stdin is a tty&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  print &lt;span class=&quot;string&quot;&gt;&amp;quot;stdin is not a tty&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Backend" scheme="https://stonefishy.github.io/categories/Backend/"/>
    
    
    <category term="Ruby" scheme="https://stonefishy.github.io/tags/Ruby/"/>
    
  </entry>
  
</feed>
