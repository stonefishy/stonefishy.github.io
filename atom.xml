<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Andrewsy&#39;s Space</title>
  
  
  <link href="https://stonefishy.github.io/atom.xml" rel="self"/>
  
  <link href="https://stonefishy.github.io/"/>
  <updated>2023-09-03T08:07:31.121Z</updated>
  <id>https://stonefishy.github.io/</id>
  
  <author>
    <name>Andrewsy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>What is AWS EBS and how to use it</title>
    <link href="https://stonefishy.github.io/2022/05/01/what-is-aws-ebs-and-how-to-use-it/"/>
    <id>https://stonefishy.github.io/2022/05/01/what-is-aws-ebs-and-how-to-use-it/</id>
    <published>2022-05-01T15:09:49.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<p><code>Amazon Elastic Block Store (EBS)</code> 是 Amazon Web Services (AWS) 提供的一项块存储服务，它允许用户创建和管理持久性块存储卷，并将这些卷附加到 Amazon Elastic Compute Cloud (EC2) 实例上。以下是关于 AWS EBS 的详细信息，包括特征、原理和使用方法。<br><img src="/assets/images/aws/aws-ebs-1.png" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ebs-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="AWS EBS"></p><h2 id="特征和功能"><a href="#特征和功能" class="headerlink" title="特征和功能"></a>特征和功能</h2><h4 id="持久性存储"><a href="#持久性存储" class="headerlink" title="持久性存储"></a>持久性存储</h4><p>EBS 卷是持久性的，这意味着数据在卷被附加到 EC2 实例上时保持不变。即使 EC2 实例停止或终止，数据仍然保留在卷上。</p><h4 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h4><p>EBS 卷会自动复制到同一可用性区域的多个设备上，以提高可用性和数据冗余。这确保了卷的数据可靠性。</p><h4 id="不断电的性能"><a href="#不断电的性能" class="headerlink" title="不断电的性能"></a>不断电的性能</h4><p>EBS 提供不断电的性能，可以提供一致的低延迟和高吞吐量，适用于各种工作负载，包括数据库、应用程序和文件系统。</p><h4 id="多种卷类型"><a href="#多种卷类型" class="headerlink" title="多种卷类型"></a>多种卷类型</h4><p>EBS 提供不同类型的卷，包括通用用途（gp2、gp3）、块存储（io1、io2）、冷 HDD 存储（sc1）和磁盘存储（st1）。每种类型都针对不同的性能和成本需求进行了优化。</p><h4 id="大小和性能的可扩展性"><a href="#大小和性能的可扩展性" class="headerlink" title="大小和性能的可扩展性"></a>大小和性能的可扩展性</h4><p>您可以根据需要调整 EBS 卷的大小和性能，而无需停机。这种可扩展性使您能够适应变化的工作负载需求。</p><h4 id="快照和备份"><a href="#快照和备份" class="headerlink" title="快照和备份"></a>快照和备份</h4><p>您可以创建 EBS 卷的快照，以备份数据，并可以使用这些快照创建新的卷。这对于数据恢复和备份非常有用。<br><img src="/assets/images/aws/aws-ebs-attach.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ebs-attach.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="EBS Attached to EC2"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>EBS 基于云上虚拟化技术实现，其主要原理如下</p><h4 id="块级别存储"><a href="#块级别存储" class="headerlink" title="块级别存储"></a>块级别存储</h4><p>EBS 存储是以块级别（通常为 512KB 或 1MB）来管理的。每个 EBS 卷由多个块组成，这些块可以独立读取和写入。</p><h4 id="分布式复制"><a href="#分布式复制" class="headerlink" title="分布式复制"></a>分布式复制</h4><p>EBS 卷的数据在同一可用性区域内的多个设备上进行分布式复制。这种复制提高了可用性和数据冗余。</p><h4 id="异步持久性"><a href="#异步持久性" class="headerlink" title="异步持久性"></a>异步持久性</h4><p>EBS 异步将数据写入持久性存储，以确保数据持久性。这意味着数据写入可能不会立即返回成功，但在后续读取时数据是可靠的。</p><h2 id="如何使用-EBS"><a href="#如何使用-EBS" class="headerlink" title="如何使用 EBS"></a>如何使用 EBS</h2><h4 id="创建-EBS-卷"><a href="#创建-EBS-卷" class="headerlink" title="创建 EBS 卷"></a>创建 EBS 卷</h4><p>在 AWS 控制台上，您可以创建新的 EBS 卷，选择卷类型、大小和其他配置选项。</p><h4 id="附加-EBS-卷"><a href="#附加-EBS-卷" class="headerlink" title="附加 EBS 卷"></a>附加 EBS 卷</h4><p>创建的 EBS 卷可以附加到 EC2 实例上。您可以选择在启动 EC2 实例时附加卷，或者在运行实例时添加卷。</p><h4 id="格式化和挂载"><a href="#格式化和挂载" class="headerlink" title="格式化和挂载"></a>格式化和挂载</h4><p>一旦附加到 EC2 实例，您需要在实例上格式化 EBS 卷，并将其挂载到文件系统上，以便在实例上使用。</p><h4 id="使用和管理"><a href="#使用和管理" class="headerlink" title="使用和管理"></a>使用和管理</h4><p>一旦 EBS 卷附加到实例上，您可以在其上创建、读取和写入数据。您还可以使用快照功能创建备份。</p><p><code>AWS EC2启动默认使用的根存储EBS在EC2终止的时候会一并删掉，而额外附加的EBS存储块则不会删除。EBS存储卷只能附加到同一个可用区的EC2实例上。</code><br><img src="/assets/images/aws/aws-ebs-root.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ebs-root.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="EBS for AMI Root Volume"></p><p>EBS 是 AWS 中的核心存储服务，用于持久性数据存储和扩展存储性能。它适用于各种应用程序和工作负载，从数据库到文件存储。通过了解 EBS 的特点和原理，您可以更好地配置和管理您的云存储需求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Amazon Elastic Block Store (EBS)&lt;/code&gt; 是 Amazon Web Services (AWS) 提供的一项块存储服务，它允许用户创建和管理持久性块存储卷，并将这些卷附加到 Amazon Elastic Compute Cl</summary>
      
    
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>什么是AWS EC2 Hibernation</title>
    <link href="https://stonefishy.github.io/2022/04/08/shi-yao-shi-aws-ec2-hibernation/"/>
    <id>https://stonefishy.github.io/2022/04/08/shi-yao-shi-aws-ec2-hibernation/</id>
    <published>2022-04-08T09:00:59.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<p><code>EC2 Hibernation</code> 是 Amazon Elastic Compute Cloud (EC2) 服务的一个功能，它允许您将 EC2 实例从运行状态转换为休眠状态，然后再次唤醒它，而不会丢失实例的内存中的数据。这个功能非常适合那些需要保持应用程序状态或长时间运行进程的工作负载。<br><img src="/assets/images/aws/aws-ec2-hibernation-flow.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ec2-hibernation-flow.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br>这里详细说明 EC2 Hibernation 的<strong>工作原理</strong></p><span id="more"></span><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><strong>1.启用 Hibernation：</strong> 要使用 EC2 Hibernation，首先需要在 EC2 实例上启用它。这可以通过使用支持 Hibernation 的实例类型，并在启动时启用 Hibernation 选项来完成。并且EBS卷必须要开启加密。<br><img src="/assets/images/aws/aws-ec2-hibernation-enable.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ec2-hibernation-enable.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>2.创建 Hibernation 快照：</strong> 在启用 Hibernation 后，EC2 实例的内存状态将被定期保存到 Amazon Elastic Block Store (EBS) 卷上的 Hibernation 快照中。这确保了在实例休眠时不会丢失内存中的数据。</p><p><strong>3.休眠实例：</strong> 一旦 Hibernation 启用并创建了快照，您可以通过执行 hibernate 命令或使用 AWS 管理控制台将实例转换为休眠状态。在休眠期间，实例的状态和数据将保存在 EBS 卷上。</p><p><strong>4.唤醒实例：</strong> 当您希望恢复实例的运行状态时，只需执行唤醒命令或使用控制台，EC2 实例将从 Hibernation 快照中还原内存状态，并继续运行。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>EC2 Hibernation 可以应用于多种使用场景，包括但不限于：</p><p><strong>长时间运行的进程：</strong> 如果您的 EC2 实例运行有状态的应用程序或长时间运行的进程，您可以使用 Hibernation 将实例休眠，以节省计算成本，而无需中断应用程序。</p><p><strong>工作负载保持状态：</strong> 某些工作负载需要保持状态，例如内存中的会话数据或数据库连接。通过 Hibernation，您可以在需要时恢复工作负载，而无需重新创建状态。</p><p><strong>成本优化：</strong> 对于不需要全天候运行的工作负载，您可以使用 Hibernation 在闲置时降低成本，然后在需要时快速恢复。</p><p><strong>实例维护：</strong> 在 EC2 实例需要进行操作系统更新或其他维护操作时，可以使用 Hibernation 将实例休眠，然后在完成维护后唤醒它，以减少维护期间的停机时间。</p><p>&#x3D;&#x3D;请注意&#x3D;&#x3D;，<u>不是所有的 EC2 实例类型都支持 Hibernation</u>，您需要选择支持该功能的实例类型并启用它。此外，<u>使用 Hibernation 可能会产生额外的 EBS 存储费用，因为需要存储 Hibernation 快照</u>。所以，在使用 Hibernation 时，需要权衡成本和性能需求。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;EC2 Hibernation&lt;/code&gt; 是 Amazon Elastic Compute Cloud (EC2) 服务的一个功能，它允许您将 EC2 实例从运行状态转换为休眠状态，然后再次唤醒它，而不会丢失实例的内存中的数据。这个功能非常适合那些需要保持应用程序状态或长时间运行进程的工作负载。&lt;br&gt;&lt;img src=&quot;/assets/images/aws/aws-ec2-hibernation-flow.webp&quot;&gt;&lt;br&gt;这里详细说明 EC2 Hibernation 的&lt;strong&gt;工作原理&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>AWS EC2的主要特点和工作方式以及计费模式</title>
    <link href="https://stonefishy.github.io/2022/03/02/aws-ec2de-xiang-xi-jie-shao-he-ji-fei-mo-shi/"/>
    <id>https://stonefishy.github.io/2022/03/02/aws-ec2de-xiang-xi-jie-shao-he-ji-fei-mo-shi/</id>
    <published>2022-03-02T03:28:07.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<p>Amazon Elastic Compute Cloud（Amazon EC2）是Amazon Web Services（AWS）提供的一项基于云的可伸缩性、弹性、安全性和监控的计算服务，它允许用户租用虚拟服务器（称为EC2实例）来运行应用程序。我们从主要特点，工作方式以及计价模式来介绍下EC2<br><img src="/assets/images/aws/aws-ec2-intro.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-ec2-intro.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><span id="more"></span><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><p><strong>可伸缩性 (Scalability)</strong><br>EC2 允许用户根据需要快速扩展或缩减实例数量。这种可伸缩性使您能够适应不断变化的工作负载，确保您的应用程序始终具备所需的计算资源。</p><p><strong>多样性的实例类型 (Diverse Instance Types)</strong><br>AWS 提供多种不同类型的 EC2 实例，以满足各种计算需求。这些类型包括计算优化、内存优化、存储优化、GPU 实例等，每种类型都针对不同类型的工作负载进行了优化。</p><p><strong>弹性IP地址 (Elastic IP Addresses)</strong><br>您可以分配弹性 IP 地址给 EC2 实例，确保即使实例停止和重新启动，IP 地址也能保持不变。这有助于确保应用程序的连通性。</p><p><strong>安全组和网络 ACL (Security Groups and Network ACLs)</strong><br>EC2 允许您配置安全组和网络 ACL，以控制实例的入站和出站流量。这提供了一层网络安全性，以确保只有授权的流量可以访问实例。</p><p><strong>Amazon Machine Images (AMIs)</strong><br>AMIs 是虚拟机镜像，包含了操作系统、应用程序和配置信息。您可以使用标准 AMIs 或创建自定义 AMIs 来启动 EC2 实例，从而简化部署。</p><p><strong>多个操作系统支持 (Multiple OS Support)</strong><br>EC2 支持多种操作系统，包括各种 Linux 发行版、Windows Server 和其他操作系统。这使您可以选择适合您应用程序的操作系统。</p><p><strong>自动化和托管选项 (Automation and Managed Options)</strong><br>EC2 实例可以与其他 AWS 服务集成，如 AWS Auto Scaling、Elastic Load Balancing 和 AWS Elastic Beanstalk，以实现自动化部署和托管。</p><p><strong>监控和警报 (Monitoring and Alerts)</strong><br>EC2 实例集成了 Amazon CloudWatch，可监控实例的性能和状态，并配置警报以及自动响应性能问题。</p><p><strong>可靠性和容错性 (Reliability and Fault Tolerance)</strong><br>EC2 提供高可用性和容错性，实例可以在不同的可用性区域和可用性域中运行，以确保服务的连续性。</p><p><strong>身份和访问管理 (Identity and Access Management)</strong><br>EC2 实例可以与 AWS Identity and Access Management (IAM) 集成，以进行身份验证和授权，使您能够控制对实例和资源的访问权限。</p><p><strong>多种定价选项 (Pricing Options)</strong><br>EC2 提供多种不同的定价选项，包括按需实例、预留实例、定期实例、Spot 实例等，以满足不同的预算和使用需求。</p><h3 id="工作方式："><a href="#工作方式：" class="headerlink" title="工作方式："></a>工作方式：</h3><p><strong>选择实例类型</strong><br>在使用 EC2 之前，您首先需要选择适合您工作负载需求的 EC2 实例类型。不同类型的实例提供不同的计算、内存、存储和网络性能。您可以根据您的需求来选择。</p><p><strong>启动实例</strong><br>一旦选择了实例类型，您可以使用 Amazon Machine Image（AMI）启动 EC2 实例。AMI 是一个预配置的虚拟机镜像，它包含了操作系统、应用程序和配置信息。您可以选择 AWS 提供的标准 AMI，也可以创建自己的自定义 AMI。</p><p><strong>安全组和密钥对</strong><br>在启动实例时，您可以选择一个或多个安全组，这些安全组定义了实例的入站和出站流量规则，以确保安全性。您还可以选择密钥对，以便安全地访问您的 EC2 实例。</p><p><strong>运行实例</strong><br>一旦实例启动，它将在 AWS 的数据中心中的物理服务器上运行。您可以通过 SSH（对于 Linux 实例）或 RDP（对于 Windows 实例）等远程协议连接到实例。</p><p><strong>管理实例</strong><br>一旦运行，您可以随时管理 EC2 实例。这包括启动、停止、重启、终止实例，以及更改实例的配置，如调整实例大小、添加存储卷等。</p><p><strong>存储和快照</strong><br>EC2 实例通常附带 Elastic Block Store（EBS）卷，您可以使用这些卷来存储数据。您还可以创建 EBS 快照，以备份数据或复制数据到其他地方。</p><p><strong>监控和伸缩</strong><br>AWS 提供了 Amazon CloudWatch，它可以用于监视 EC2 实例的性能指标，如 CPU 使用率、网络流量等。您可以设置警报以响应性能问题，并根据需要配置自动伸缩策略，以自动调整实例数量。</p><p><strong>安全性和身份验证</strong><br>EC2 实例可以与 AWS Identity and Access Management（IAM）集成，以实现身份验证和授权。您可以为实例分配 IAM 角色，以便它们可以访问其他 AWS 服务或资源，而无需硬编码的凭据。</p><h3 id="计费模式"><a href="#计费模式" class="headerlink" title="计费模式"></a>计费模式</h3><p><strong>按需实例 (On-Demand Instances)</strong><br>按需实例是一种灵活的计费方式，您只需为您实际使用的计算资源付费，没有长期合同或预付费。这意味着您可以随时启动或停止实例，只支付实际的运行时间。</p><p>适用于需要灵活性的工作负载，如开发和测试、临时工作负载、突发性工作负载。</p><p><strong>预留实例 (Reserved Instances)</strong><br>预留实例是一种合同制度，您提前支付一定费用，获得对特定实例类型的一定时期内的折扣，通常为1年或3年。这通常比按需实例更经济。</p><p>适用于长期工作负载，可以预测的、稳定的使用情况，例如生产服务器。</p><p><strong>可用性区域保留实例 (Reserved Instances for Availability Zones)</strong><br>这是预留实例的一种变种，允许您为特定的可用性区域（AZ）购买预留容量。这对于需要在特定区域内保留容量的应用程序非常有用。</p><p>适用于需要确保在特定可用性区域内拥有计算资源的工作负载。</p><p><strong>可调整实例 (Convertible Reserved Instances)</strong><br>这是一种预留实例，允许在合同期内更改实例类型，以适应不同的工作负载需求。</p><p>适用于工作负载需求可能会变化的情况，但仍然希望获得折扣。</p><p><strong>定期实例 (Scheduled Instances)</strong><br>定期实例允许您按预定的时间启动 EC2 实例。您可以在每天的特定时间、每周某个时间或其他预定时间启动实例。</p><p>适用于周期性的、预定的工作负载，如每天备份、批处理处理等。</p><p><strong>批量实例 (Spot Instances)</strong><br>Spot 实例基于竞价定价模式，您可以设定愿意支付的价格，当市场价格低于您的出价时，您可以获得实例。但它们可能随时被终止。</p><p>适用于可以容忍实例随时中断的工作负载，如大规模数据分析和渲染任务。</p><p><strong>Dedicated Hosts（专用主机）</strong><br>专用主机允许您在 AWS 的物理服务器上运行 EC2 实例，这些服务器专门为您的账户保留。这提供了硬件级别的隔离，适用于具有特殊合规性要求的工作负载。</p><p>适用于需要硬件隔离的工作负载，例如合规性要求非常高的应用程序，或者需要将许多实例部署到同一物理服务器上的场景。</p><p><strong>Dedicated Instances（专用实例）</strong><br>专用实例是 EC2 实例，它们在共享的物理服务器上运行，但只与您的账户中的其他实例共享。这提供了实例级别的隔离。</p><p>适用于需要实例级别隔离的工作负载，但不需要物理主机级别的隔离的场景。</p><p><strong>Free Tier（免费层级）</strong><br>AWS 提供了一定程度的免费使用，即免费层级，对于新用户以及AWS账户中的某些服务和资源，提供有限的免费额度，通常为12个月。这是用于学习、试验和小型项目的好方法，以降低成本。</p><p>适用于学习 AWS、开发和测试小型应用程序，或者初期的小规模项目。</p><p>这些计费模式为不同的使用情况提供了各种选择。您可以根据您的需求和预算来选择适合您的模式。请注意，AWS定期更新其价格和计费模式，因此建议查看官方文档以获取最新的信息。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Amazon Elastic Compute Cloud（Amazon EC2）是Amazon Web Services（AWS）提供的一项基于云的可伸缩性、弹性、安全性和监控的计算服务，它允许用户租用虚拟服务器（称为EC2实例）来运行应用程序。我们从主要特点，工作方式以及计价模式来介绍下EC2&lt;br&gt;&lt;img src=&quot;/assets/images/aws/aws-ec2-intro.webp&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>AWS IAM原理以及如何使用</title>
    <link href="https://stonefishy.github.io/2022/02/17/aws-iamyuan-li-yi-ji-ru-he-shi-yong/"/>
    <id>https://stonefishy.github.io/2022/02/17/aws-iamyuan-li-yi-ji-ru-he-shi-yong/</id>
    <published>2022-02-17T15:22:57.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<p>AWS Identity and Access Management（<code>IAM</code>）是Amazon Web Services（AWS）提供的身份和访问管理服务，用于安全地管理对AWS资源的访问权限。IAM使您能够精细控制用户、组、角色等实体对AWS服务和资源的访问权限，以确保安全性和合规性。</p><h3 id="IAM的原理"><a href="#IAM的原理" class="headerlink" title="IAM的原理"></a>IAM的原理</h3><p>IAM基于一些核心概念：</p><p><strong>用户（Users）：</strong> 代表实际的个人用户，可以分配安全凭证（如访问密钥、密码）来访问AWS资源。<br><img src="/assets/images/aws/aws-iam-users.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-iam-users.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><span id="more"></span><p><strong>组（Groups）：</strong> 用于将一组用户组合在一起，并将一组权限分配给该组，从而简化权限管理。<br><img src="/assets/images/aws/aws-iam-groups.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-iam-groups.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>角色（Roles）：</strong> 类似于用户，但不是直接分配给人，而是分配给AWS资源（例如EC2实例）。角色可以用于临时授权。<br><img src="/assets/images/aws/aws-iam-roles.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-iam-roles.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>权限策略（Permissions Policies）：</strong><br>定义了用户、组或角色可以执行的特定操作的权限。AWS提供了许多预定义的权限策略，同时也可以创建自定义策略。<br><img src="/assets/images/aws/aws-iam-policies.webp" class="lazyload placeholder" data-srcset="/assets/images/aws/aws-iam-policies.webp" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><h3 id="如何使用IAM"><a href="#如何使用IAM" class="headerlink" title="如何使用IAM"></a>如何使用IAM</h3><p><strong>创建用户和组：</strong> 在IAM中，您可以创建用户，并将用户组合成组。然后，为用户分配安全凭证和权限。</p><p><strong>定义和分配权限：</strong> 您可以使用AWS提供的预定义权限策略，也可以创建自定义策略，然后将这些策略附加到用户、组或角色上，以控制他们对资源的访问。</p><p><strong>使用角色：</strong> 如果您的应用程序需要访问AWS服务，可以创建角色，并将这些角色附加到您的应用程序或服务中。这样，您可以避免将敏感的凭证嵌入到应用程序代码中。</p><p><strong>多因素认证（MFA）：</strong> 您可以启用多因素认证来增加账户的安全性，要求用户在登录时提供额外的身份验证信息。</p><p><strong>访问审计：</strong> IAM提供了日志记录功能，可记录用户在AWS资源上执行的操作，以便进行审计和安全分析。</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>在使用IAM时，建议采用以下最佳实践，例如：</p><p><strong>最小权限原则：</strong> 为用户和角色提供所需的最小权限，以减少潜在的安全风险。</p><p><strong>使用身份提供商：</strong> 将身份提供商（如企业目录）与IAM集成，以便集中管理用户和权限。</p><p><strong>定期审查权限：</strong> 定期审查用户、组和角色的权限，确保权限保持最新且合规。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;AWS Identity and Access Management（&lt;code&gt;IAM&lt;/code&gt;）是Amazon Web Services（AWS）提供的身份和访问管理服务，用于安全地管理对AWS资源的访问权限。IAM使您能够精细控制用户、组、角色等实体对AWS服务和资源的访问权限，以确保安全性和合规性。&lt;/p&gt;
&lt;h3 id=&quot;IAM的原理&quot;&gt;&lt;a href=&quot;#IAM的原理&quot; class=&quot;headerlink&quot; title=&quot;IAM的原理&quot;&gt;&lt;/a&gt;IAM的原理&lt;/h3&gt;&lt;p&gt;IAM基于一些核心概念：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户（Users）：&lt;/strong&gt; 代表实际的个人用户，可以分配安全凭证（如访问密钥、密码）来访问AWS资源。&lt;br&gt;&lt;img src=&quot;/assets/images/aws/aws-iam-users.webp&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://stonefishy.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="AWS" scheme="https://stonefishy.github.io/tags/AWS/"/>
    
  </entry>
  
  <entry>
    <title>聊聊前端优化手段防抖</title>
    <link href="https://stonefishy.github.io/2017/03/16/liao-liao-qian-duan-you-hua-shou-duan-fang-dou/"/>
    <id>https://stonefishy.github.io/2017/03/16/liao-liao-qian-duan-you-hua-shou-duan-fang-dou/</id>
    <published>2017-03-16T08:29:09.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<p>在前端开发中，<strong>防抖（Debouncing）</strong> 是一种常用的优化技术，用于处理频繁触发的事件，如浏览器窗口的resize、input输入等。<strong>防抖的目标是在事件被触发后，等待一段时间，只执行一次事件处理函数，以避免频繁的重复操作</strong>。</p><p><strong>防抖的原理</strong>很简单：当一个事件被触发时，立即设置一个定时器，在规定的时间内没有再次触发该事件时，执行事件处理函数。如果在定时器规定的时间内再次触发了事件，那么就清除前一个定时器，并重新设置新的定时器。这样，只有在事件停止触发一段时间后，才会执行事件处理函数。</p><p>以下是一个防抖的基本实现示例（使用 JavaScript）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 每次执行时，清除之前的定时器</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">//设置新的定时器</span></span><br><span class="line">            func.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debounceFunction = <span class="title function_">debounce</span>(<span class="function">(<span class="params">args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Debounce function called&quot;</span>, args);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, debounceFunction);</span><br></pre></td></tr></table></figure><span id="more"></span><p>在上面的示例中，debounce 函数接受两个参数：<strong>要执行的事件处理函数</strong>和<strong>延迟时间</strong>（规定的等待时间）。在事件被触发时，debounce 返回一个新的函数，该函数会设置一个定时器来等待延迟时间，然后执行事件处理函数。</p><p>防抖的实现可以根据需要进行适当的调整，例如增加立即执行选项，即在事件触发时立即执行一次事件处理函数，然后再进入防抖模式。这样可以在事件触发的瞬间即时响应，同时仍然保留了后续的防抖效果。</p><p>现在在上面防抖的基础上多增加一个参数，<strong>immediate</strong>， 参数值为true时，函数立即执行，为false时延时执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, delay, immediate</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;    <span class="comment">// immediate为true，立即执行</span></span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args); <span class="comment">// 立即执行一次事件处理函数</span></span><br><span class="line">        &#125;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            timer = <span class="literal">null</span>; <span class="comment">// delay时间到后，将计时器设置null，下一次立即执行</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">//immediate为false，延时执行</span></span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            func.<span class="title function_">apply</span>(context, args); <span class="comment">// 在延迟时间后执行事件处理函数</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用防抖处理事件，第一次触发立即执行，之后每次触发等待300毫秒后执行</span></span><br><span class="line"><span class="keyword">const</span> debouncedFunction = <span class="title function_">debounce</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Debounce function called.&quot;</span>);</span><br><span class="line">&#125;, <span class="number">500</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, debouncedFunction);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总的来说，防抖是一种有效的优化手段，可以帮助减少频繁触发的事件造成的重复操作，提升前端应用的性能和用户体验。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前端开发中，&lt;strong&gt;防抖（Debouncing）&lt;/strong&gt; 是一种常用的优化技术，用于处理频繁触发的事件，如浏览器窗口的resize、input输入等。&lt;strong&gt;防抖的目标是在事件被触发后，等待一段时间，只执行一次事件处理函数，以避免频繁的重复操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;防抖的原理&lt;/strong&gt;很简单：当一个事件被触发时，立即设置一个定时器，在规定的时间内没有再次触发该事件时，执行事件处理函数。如果在定时器规定的时间内再次触发了事件，那么就清除前一个定时器，并重新设置新的定时器。这样，只有在事件停止触发一段时间后，才会执行事件处理函数。&lt;/p&gt;
&lt;p&gt;以下是一个防抖的基本实现示例（使用 JavaScript）：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;debounce&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;func, delay&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; timer = &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; context = &lt;span class=&quot;variable language_&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; args = &lt;span class=&quot;variable language_&quot;&gt;arguments&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;clearTimeout&lt;/span&gt;(timer); &lt;span class=&quot;comment&quot;&gt;// 每次执行时，清除之前的定时器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        timer = &lt;span class=&quot;built_in&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &amp;#123; &lt;span class=&quot;comment&quot;&gt;//设置新的定时器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            func.&lt;span class=&quot;title function_&quot;&gt;apply&lt;/span&gt;(context, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;, delay);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; debounceFunction = &lt;span class=&quot;title function_&quot;&gt;debounce&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;args&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable language_&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;title function_&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Debounce function called&amp;quot;&lt;/span&gt;, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable language_&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;title function_&quot;&gt;addEventListener&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;#x27;resize&amp;#x27;&lt;/span&gt;, debounceFunction);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Frontend" scheme="https://stonefishy.github.io/categories/Frontend/"/>
    
    
    <category term="JavaScript" scheme="https://stonefishy.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>一个免费高质量的图片分享平台</title>
    <link href="https://stonefishy.github.io/2017/02/23/yi-ge-mian-fei-gao-zhi-liang-de-tu-pian-fen-xiang-ping-tai/"/>
    <id>https://stonefishy.github.io/2017/02/23/yi-ge-mian-fei-gao-zhi-liang-de-tu-pian-fen-xiang-ping-tai/</id>
    <published>2017-02-23T10:02:19.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<p>很多时候在写文章或者制作PPT时需要用到一些图片资源，最近刚好发现了一个实用的高分辨率的免费资源平台Unspash, 跟大家分享一下。<br><img src="/assets/images/ziyuan/laptop-1.png" class="lazyload placeholder" data-srcset="/assets/images/ziyuan/laptop-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"><br><a href="https://unsplash.com/" title="免费高质量的图片分享平台">Unsplash.com</a> 是一个知名的免费高质量图片分享平台，提供各种类型的高分辨率摄影图片供用户免费下载和使用。这些图片可以用于个人、商业、创意和学术项目，包括网站、博客、社交媒体、演示文稿等。</p><span id="more"></span><p>这个平台的特点包括：</p><p><strong>高质量图片：</strong> Unsplash 上的图片质量往往很高，包括风景、人物、食物、建筑等多种主题。这些图片通常由专业摄影师拍摄，因此在设计和内容创作中具有很大的价值。<br><img src="/assets/images/ziyuan/fengjing-1.png" class="lazyload placeholder" data-srcset="/assets/images/ziyuan/fengjing-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>免费使用：</strong> Unsplash 的图片都是免费提供的，无需付费或订阅。用户可以自由下载、编辑和使用这些图片，而不需要担心版权问题。<br><img src="/assets/images/ziyuan/coding-1.png" class="lazyload placeholder" data-srcset="/assets/images/ziyuan/coding-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>简单的许可：</strong> Unsplash 使用的是创作共用许可（Creative Commons Zero License），这意味着用户可以自由使用这些图片，甚至可以用于商业目的，无需给予作者署名。<br><img src="/assets/images/ziyuan/license-1.png" class="lazyload placeholder" data-srcset="/assets/images/ziyuan/license-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>搜索和浏览功能：</strong> Unsplash 网站提供搜索功能和浏览不同主题的图片集合，帮助用户快速找到符合自己需求的图片。<br><img src="/assets/images/ziyuan/search-1.png" class="lazyload placeholder" data-srcset="/assets/images/ziyuan/search-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p><strong>社区和创作者：</strong> Unsplash 构建了一个活跃的摄影师社区，用户可以查看摄影师的个人主页，了解他们的作品，并选择关注自己喜欢的创作者。<br><img src="/assets/images/ziyuan/community-1.png" class="lazyload placeholder" data-srcset="/assets/images/ziyuan/community-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>总的来说，Unsplash.com 是一个受欢迎的图片资源平台，适用于需要高质量图片的个人和商业项目。真的是一个很棒的资源平台！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很多时候在写文章或者制作PPT时需要用到一些图片资源，最近刚好发现了一个实用的高分辨率的免费资源平台Unspash, 跟大家分享一下。&lt;br&gt;&lt;img src=&quot;/assets/images/ziyuan/laptop-1.png&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://unsplash.com/&quot; title=&quot;免费高质量的图片分享平台&quot;&gt;Unsplash.com&lt;/a&gt; 是一个知名的免费高质量图片分享平台，提供各种类型的高分辨率摄影图片供用户免费下载和使用。这些图片可以用于个人、商业、创意和学术项目，包括网站、博客、社交媒体、演示文稿等。&lt;/p&gt;</summary>
    
    
    
    <category term="Resources" scheme="https://stonefishy.github.io/categories/Resources/"/>
    
    
    <category term="高清图片" scheme="https://stonefishy.github.io/tags/%E9%AB%98%E6%B8%85%E5%9B%BE%E7%89%87/"/>
    
    <category term="资源" scheme="https://stonefishy.github.io/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>最短子数组之和</title>
    <link href="https://stonefishy.github.io/2016/03/01/minimum-size-subarray-sum/"/>
    <id>https://stonefishy.github.io/2016/03/01/minimum-size-subarray-sum/</id>
    <published>2016-03-01T09:18:50.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<p>一个常见的最短子数组算法题是 “Minimum Size Subarray Sum”。在这个问题中，给定一个正整数数组和一个目标值，要找到数组中一个连续子数组，使得子数组的元素和大于等于目标值，并且子数组的长度最小。</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入： </span><br><span class="line">数组: [5, 3, 4, 2, 8, 5];  目标值: 10</span><br><span class="line">输出：</span><br><span class="line">[2, 8]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入： </span><br><span class="line">数组: [5, 3, 4, 2, 8, 5];  目标值: 28</span><br><span class="line">输出：</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入： </span><br><span class="line">数组: [5, 3, 4, 2, 8, 5];  目标值: 4</span><br><span class="line">输出：</span><br><span class="line">[5]</span><br></pre></td></tr></table></figure><p>这个问题可以使用双指针来解决窗口的滑动问题，核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] minSizeSubArray(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>, p2 = <span class="number">0</span>; <span class="comment">//定义两个指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minLeft</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 最小子数组的左边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> Integer.MAX_VALUE; <span class="comment">// 最小子数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//子数组元素和</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p2 = <span class="number">0</span>; p2 &lt; numbers.length; p2++) &#123;</span><br><span class="line">        sum += numbers[p2]; <span class="comment">// 将右指针的元素加入子数组</span></span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123; <span class="comment">// 如果子数组的和大于等于目标值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">curLen</span> <span class="operator">=</span> p2 - p1 + <span class="number">1</span>; <span class="comment">// 获取当前子数组长度</span></span><br><span class="line">            <span class="keyword">if</span> (minLen &gt; curLen) &#123; <span class="comment">// 如果子数组长度比上次还更小</span></span><br><span class="line">                minLen = curLen; <span class="comment">// 更新子数组最小长度</span></span><br><span class="line">                minLeft = p1;   <span class="comment">// 更新子数组的左边界</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum -= numbers[p1]; <span class="comment">// 将左指针的元素从子数组中移除</span></span><br><span class="line">            p1++;   <span class="comment">//移动左指针，缩小子数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minLen == Integer.MAX_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];  <span class="comment">// 没有找到匹配的子数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//根据子数组的左边界以及长度，返回子数组</span></span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[minLen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; minLen; i++) &#123;</span><br><span class="line">            result[i] = numbers[i + minLeft];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用了两个指针 p1 和 p2，分别表示子数组的左右边界。我们在数组上使用滑动窗口来寻找满足条件的最短子数组。当子数组的和大于等于目标值时，我们移动左指针，并更新最小长度。如果发现有更小的数组长度，则更新最小数组长度以及数组的左边界值，当子数组的和不足以满足条件时，我们移动右指针，并继续扩展子数组。</p><p>测试结果如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] numbers = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    printArray(minSizeSubArray(numbers, <span class="number">10</span>)); <span class="comment">// [2, 8]</span></span><br><span class="line">    printArray(minSizeSubArray(numbers, <span class="number">28</span>)); <span class="comment">// []</span></span><br><span class="line">    printArray(minSizeSubArray(numbers, <span class="number">4</span>)); <span class="comment">// [5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    sb.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">        sb.append(numbers[i]).append(i == numbers.length - <span class="number">1</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;, &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sb.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个常见的最短子数组算法题是 “Minimum Size Subarray Sum”。在这个问题中，给定一个正整数数组和一个目标值，要找到数组中一个连续子数组，使得子数组的元素和大于等于目标值，并且子数组的长度最小。&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;数组: [5, 3, 4, 2, 8, 5];  目标值: 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[2, 8]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;数组: [5, 3, 4, 2, 8, 5];  目标值: 28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法" scheme="https://stonefishy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://stonefishy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://stonefishy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>双指针算法之两数之和</title>
    <link href="https://stonefishy.github.io/2016/02/05/shuang-zhi-zhen-suan-fa-zhi-liang-shu-zhi-he/"/>
    <id>https://stonefishy.github.io/2016/02/05/shuang-zhi-zhen-suan-fa-zhi-liang-shu-zhi-he/</id>
    <published>2016-02-05T01:51:39.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇中，我们讲到了双指针算法的几种使用场景，这里具体举例，以经典的两数之和为例。</p><p>给定一个有序数字的数组和一个目标值，在有序数组中找到两个数字之和等于该目标值，返回包含两个数字的数组，如果没有找到返回包含两个-1值的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">找到的情况</span><br><span class="line">输入： </span><br><span class="line">有序数组: [2, 4, 5, 6, 12];  目标值: 10</span><br><span class="line">输出：</span><br><span class="line">[4, 6]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">找不到的情况</span><br><span class="line">输入： </span><br><span class="line">有序数组: [2, 4, 5, 6, 12];  目标值: 3</span><br><span class="line">输出：</span><br><span class="line">[-1, -1]</span><br></pre></td></tr></table></figure><span id="more"></span><p>直接代码走起，下面以Java代码为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findNumbers(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pLeft</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 左指针初始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pRight</span> <span class="operator">=</span> numbers.length - <span class="number">1</span>; <span class="comment">// 右指针初始位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pLeft &lt; pRight) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[pLeft] + numbers[pRight];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;numbers[pLeft], numbers[pRight]&#125;; <span class="comment">// 返回匹配的元素</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                pLeft++; <span class="comment">// 和小于目标值，左指针右移</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pRight--; <span class="comment">// 和大于目标值，右指针左移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] results = findNumbers(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">12</span>&#125;, <span class="number">10</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;[%d, %d]%n&quot;</span>, results[<span class="number">0</span>], results[<span class="number">1</span>]); <span class="comment">// 输出 [4, 6]</span></span><br><span class="line"></span><br><span class="line">        results = findNumbers(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">12</span>&#125;, <span class="number">3</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;[%d, %d]%n&quot;</span>, results[<span class="number">0</span>], results[<span class="number">1</span>]); <span class="comment">// 输出 [-1, -1]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用了两个指针 pLeft 和 pRight 分别指向有序数组的两端。然后，我们计算 numbers[pLeft] 和 numbers[pRight] 的和，并与目标值进行比较。根据和与目标值的大小关系，我们移动左指针或右指针，直到找到符合条件的元素对，或者指针重合没有找到。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一篇中，我们讲到了双指针算法的几种使用场景，这里具体举例，以经典的两数之和为例。&lt;/p&gt;
&lt;p&gt;给定一个有序数字的数组和一个目标值，在有序数组中找到两个数字之和等于该目标值，返回包含两个数字的数组，如果没有找到返回包含两个-1值的数组。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;找到的情况&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;有序数组: [2, 4, 5, 6, 12];  目标值: 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[4, 6]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;找不到的情况&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;有序数组: [2, 4, 5, 6, 12];  目标值: 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[-1, -1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="算法" scheme="https://stonefishy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://stonefishy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://stonefishy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>双指针算法</title>
    <link href="https://stonefishy.github.io/2016/01/25/shuang-zhi-zhen-suan-fa/"/>
    <id>https://stonefishy.github.io/2016/01/25/shuang-zhi-zhen-suan-fa/</id>
    <published>2016-01-25T01:09:24.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<p>双指针算法（Two Pointer Algorithm）是一种常见的算法技巧，通常用于数组、链表等数据结构中解决一些问题。双指针算法的核心思想是使用两个指针在不同的位置上移动，以达到解决问题的目的。这两个指针可以朝着相同的方向移动，也可以朝着相反的方向移动，视问题而定。</p><p>双指针算法的常见应用场景和实现方法：</p><p><strong>对撞指针（Two Sum、Three Sum）：</strong> 在有序数组中查找满足特定条件的元素对或元素组合。使用两个指针分别从数组的两端开始，向中间逼近，根据元素之间的大小关系，调整指针的位置。</p><p><strong>快慢指针（环形链表判断、链表中间节点）：</strong> 在链表中判断是否存在环或找到链表的中间节点。使用两个指针，一个快指针每次移动两步，一个慢指针每次移动一步，根据指针的移动速度判断链表的性质。</p><span id="more"></span><p><strong>滑动窗口（子数组问题、字符串问题）：</strong> 用于解决一些窗口内的问题，例如找到最短子数组、找到最长连续子数组等。使用两个指针表示窗口的左右边界，移动窗口进行计算。</p><p><strong>夹逼法（容器装水问题、三数最接近问题）：</strong> 在一维数组中寻找满足特定条件的元素对。使用两个指针从两端开始，逐渐向中间夹逼，根据元素之间的大小关系，调整指针的位置。</p><p><strong>多指针法（四数之和问题、删除排序数组中的重复项）：</strong> 在一维或二维数组中寻找满足特定条件的元素组合。使用多个指针在数组中移动，根据问题需要，进行相应的指针调整。</p><p>双指针算法的优势在于它可以在O(N)的时间复杂度内解决一些复杂的问题，而不需要使用额外的空间。它在数组和链表等数据结构上都有广泛的应用，常用于解决数组遍历、查找、排序和操作等问题。这种算法可以帮助简化问题的解决过程，提高代码效率。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;双指针算法（Two Pointer Algorithm）是一种常见的算法技巧，通常用于数组、链表等数据结构中解决一些问题。双指针算法的核心思想是使用两个指针在不同的位置上移动，以达到解决问题的目的。这两个指针可以朝着相同的方向移动，也可以朝着相反的方向移动，视问题而定。&lt;/p&gt;
&lt;p&gt;双指针算法的常见应用场景和实现方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对撞指针（Two Sum、Three Sum）：&lt;/strong&gt; 在有序数组中查找满足特定条件的元素对或元素组合。使用两个指针分别从数组的两端开始，向中间逼近，根据元素之间的大小关系，调整指针的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;快慢指针（环形链表判断、链表中间节点）：&lt;/strong&gt; 在链表中判断是否存在环或找到链表的中间节点。使用两个指针，一个快指针每次移动两步，一个慢指针每次移动一步，根据指针的移动速度判断链表的性质。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://stonefishy.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://stonefishy.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://stonefishy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>How to fix Gem FilePermissionError</title>
    <link href="https://stonefishy.github.io/2016/01/12/how-to-fix-gem-filepermissionerror/"/>
    <id>https://stonefishy.github.io/2016/01/12/how-to-fix-gem-filepermissionerror/</id>
    <published>2016-01-12T15:31:35.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<p>Sometimes we face the erorr “Gem::FilePermissionError: You don’t have write permissions for the &#x2F;Library&#x2F;Ruby&#x2F;Gems&#x2F;x.x.x directory”. This error message indicates that the user doesn’t have the necessary permissions to install Ruby gems system-wide. This is because the system Ruby installation requires administrative privileges to modify its gem directory.</p><p>To resolve this issue, there is a few options:</p><h3 id="1-Use-a-Ruby-Version-Manager-Recommended"><a href="#1-Use-a-Ruby-Version-Manager-Recommended" class="headerlink" title="1. Use a Ruby Version Manager (Recommended)"></a>1. Use a Ruby Version Manager (Recommended)</h3><p>Instead of installing gems globally, consider using a Ruby version manager like <code>rbenv</code> or <code>RVM</code>. These tools allow you to manage multiple Ruby versions and gems without requiring administrative permissions.</p><h4 id="Using-rbenv"><a href="#Using-rbenv" class="headerlink" title="Using rbenv"></a>Using rbenv</h4><pre><code>1. Install rbenv if you haven&#39;t already.2. Install the desired version of Ruby using rbenv.3. Install gems without needing elevated permissions.</code></pre><h4 id="Using-RVM"><a href="#Using-RVM" class="headerlink" title="Using RVM"></a>Using RVM</h4><pre><code>1. Install RVM if you haven&#39;t already.2. Install the desired version of Ruby using RVM.3. Use the installed Ruby version without needing elevated permissions to install gems.</code></pre><span id="more"></span><h3 id="2-Install-Gems-Locally"><a href="#2-Install-Gems-Locally" class="headerlink" title="2. Install Gems Locally"></a>2. Install Gems Locally</h3><p>If you want to install gems for the system Ruby without using a version manager, you’ll need administrative privileges. You can use the sudo command to install gems as the superuser:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install gem_name</span><br></pre></td></tr></table></figure><p>However, keep in mind that modifying the system Ruby environment might affect other applications, and it’s generally recommended to use a version manager to manage Ruby environments.</p><h3 id="3-Use-–user-install-Option"><a href="#3-Use-–user-install-Option" class="headerlink" title="3. Use –user-install Option"></a>3. Use –user-install Option</h3><p>If you want to install gems locally without administrative privileges, you can use the <strong>–user-install</strong> option:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install gem_name --user-install</span><br></pre></td></tr></table></figure><p>This installs the gem in your user’s home directory, avoiding the need for system-wide modifications.</p><h3 id="4-Install-to-Custom-Directory"><a href="#4-Install-to-Custom-Directory" class="headerlink" title="4. Install to Custom Directory"></a>4. Install to Custom Directory</h3><p>You can configure gems to be installed in a specific directory where you have write permissions. This involves configuring the <strong>GEM_HOME</strong> and <strong>GEM_PATH</strong> environment variables:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GEM_HOME=<span class="variable">$HOME</span>/gems</span><br><span class="line"><span class="built_in">export</span> GEM_PATH=<span class="variable">$GEM_HOME</span>:/path/to/system/gems</span><br><span class="line">gem install gem_name</span><br></pre></td></tr></table></figure><p>Make sure to adjust the paths according to your preferences.</p><p>In general, using a Ruby version manager like <strong>rbenv</strong> or <strong>RVM</strong> is recommended, as it provides a more flexible and isolated way to manage Ruby versions and gems without affecting system-wide configurations or requiring administrative permissions.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Sometimes we face the erorr “Gem::FilePermissionError: You don’t have write permissions for the &amp;#x2F;Library&amp;#x2F;Ruby&amp;#x2F;Gems&amp;#x2F;x.x.x directory”. This error message indicates that the user doesn’t have the necessary permissions to install Ruby gems system-wide. This is because the system Ruby installation requires administrative privileges to modify its gem directory.&lt;/p&gt;
&lt;p&gt;To resolve this issue, there is a few options:&lt;/p&gt;
&lt;h3 id=&quot;1-Use-a-Ruby-Version-Manager-Recommended&quot;&gt;&lt;a href=&quot;#1-Use-a-Ruby-Version-Manager-Recommended&quot; class=&quot;headerlink&quot; title=&quot;1. Use a Ruby Version Manager (Recommended)&quot;&gt;&lt;/a&gt;1. Use a Ruby Version Manager (Recommended)&lt;/h3&gt;&lt;p&gt;Instead of installing gems globally, consider using a Ruby version manager like &lt;code&gt;rbenv&lt;/code&gt; or &lt;code&gt;RVM&lt;/code&gt;. These tools allow you to manage multiple Ruby versions and gems without requiring administrative permissions.&lt;/p&gt;
&lt;h4 id=&quot;Using-rbenv&quot;&gt;&lt;a href=&quot;#Using-rbenv&quot; class=&quot;headerlink&quot; title=&quot;Using rbenv&quot;&gt;&lt;/a&gt;Using rbenv&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1. Install rbenv if you haven&amp;#39;t already.
2. Install the desired version of Ruby using rbenv.
3. Install gems without needing elevated permissions.
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;Using-RVM&quot;&gt;&lt;a href=&quot;#Using-RVM&quot; class=&quot;headerlink&quot; title=&quot;Using RVM&quot;&gt;&lt;/a&gt;Using RVM&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1. Install RVM if you haven&amp;#39;t already.
2. Install the desired version of Ruby using RVM.
3. Use the installed Ruby version without needing elevated permissions to install gems.
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="Backend" scheme="https://stonefishy.github.io/categories/Backend/"/>
    
    
    <category term="Tool" scheme="https://stonefishy.github.io/tags/Tool/"/>
    
    <category term="Ruby" scheme="https://stonefishy.github.io/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Ruby修炼之道(18)</title>
    <link href="https://stonefishy.github.io/2015/12/28/ruby-practice-18/"/>
    <id>https://stonefishy.github.io/2015/12/28/ruby-practice-18/</id>
    <published>2015-12-28T02:59:48.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>Ruby程序在启动后会预先分配3个<strong>IO</strong>对象:<br>标准输入 - 预定义常量(<strong>STDIN</strong>), 全局变量(<strong>$stdin</strong>)<br>标准输出 - 预定义常量(<strong>STDOUT</strong>), 全局变量(<strong>$stdout</strong>)<br>标准错误输出 - 预定义常量(<strong>STDERR</strong>), 全局变量(<strong>$stderr</strong>)</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$stdout</span>.print <span class="string">&quot;output something from $stdout\n&quot;</span></span><br><span class="line"><span class="variable constant_">STDERR</span>.print <span class="string">&quot;output something from $stderr\n&quot;</span></span><br></pre></td></tr></table></figure><p>IO对象是否与控制台关联，我们可以通过**tty?**方法来判断。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="variable">$stdin</span>.tty?</span><br><span class="line">  print <span class="string">&quot;stdin is a tty&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  print <span class="string">&quot;stdin is not a tty&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h5><p>通过File.open方法或open方法打开文件并获取新的IO对象，</p><pre><code>io = File.open(file, mode)io = open(file, mode)</code></pre><p>mode为文件的读写方法，缺省情况下为只读模式(r).</p><p>r  - 只读模式<br>r+ - 读写模式<br>w  - 只写模式，如果文件不存在则创建新文件，如果文件存在，则清空文件<br>w+ - 读写模式，其余同w<br>a  - 追加模式，文件不存在则创建新文件<br>a+ - 读取、追加模式，文件不存在则创建新文件    </p><p>io.<strong>close</strong><br>使用<strong>close</strong>方法关闭已打开的文件。File.open方法使用块，则文件会在使用完毕后自动关闭，io变量会被作为块变量传递给块。并且使用io.closed?方法可以检查是否关闭。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">File</span>.open(<span class="string">&quot;tty.rb&quot;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  <span class="keyword">while</span> line = io.gets</span><br><span class="line">    print line</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<strong>File.read</strong>可以一次性读取文件的内容。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data = <span class="title class_">File</span>.read(<span class="string">&quot;tty.rb&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="基本输入"><a href="#基本输入" class="headerlink" title="基本输入"></a>基本输入</h5><p>io.<strong>gets</strong>(rs)<br>io.<strong>each</strong>(rs)<br>io.<strong>each_line</strong>(rs)<br>io.<strong>readlines</strong>(rs)<br>从IO类的对象中读取一行数据，用参数<strong>rs</strong>的字符串分行，缺省模式下为换行符。</p><p>使用**eof?**可以检查输入是否已经完毕。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">io = <span class="title class_">File</span>.open(<span class="string">&quot;tty.rb&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> line = io.gets</span><br><span class="line">  line.chomp!</span><br><span class="line">  print line</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">p io.eof?     <span class="comment">#=&gt; true</span></span><br><span class="line">io.close      <span class="comment">#=&gt; close file</span></span><br><span class="line">p io.closed?   <span class="comment">#=&gt; true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用<strong>readlines</strong>方法可以一次性读取所有数据，并返回将每行数据作为元素封装的数组.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">io = <span class="title class_">File</span>.open(<span class="string">&quot;tty.rb&quot;</span>)</span><br><span class="line">ary = io.readlines</span><br><span class="line">io.close</span><br><span class="line">ary.each <span class="keyword">do</span> |<span class="params">line</span>|</span><br><span class="line">  line.chomp!</span><br><span class="line">  print line</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>io.<strong>lineno</strong><br>使用gets方法，each_line方法逐行读取文件时，io会自动记录读取的行数，可以通过<strong>io.lineno</strong>来获取当前行数。   </p><p>io.<strong>each_char</strong><br>逐个字符读取io对象中的数据,并启动块。   </p><p>io.<strong>each_byte</strong><br>逐个字节读取io对象中的数据，并启动块。    </p><p>io.<strong>getc</strong><br>只读取io对象中的一个字符。<br>io.<strong>ungetc(ch)</strong><br>将参数ch指定的字符退回到io得缓冲流中   </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">File</span>.open(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  io.write(<span class="string">&quot;Hello Ruby&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="title class_">File</span>.open(<span class="string">&quot;hello.txt&quot;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  p io.getc       <span class="comment">#=&gt; H</span></span><br><span class="line">  io.ungetc(<span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">  p io.gets       <span class="comment">#=&gt; Hello Ruby</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">File</span>.delete(<span class="string">&quot;hello.txt&quot;</span>)</span><br></pre></td></tr></table></figure><p>io.<strong>getbyte</strong>, io.<strong>ungetbyte</strong>的使用方法同上，不同之处在于此处是字节。    </p><p>io.<strong>read</strong>(size)<br>读取参数size指定大小的数据，如果没指定，则一次性读取所有数据。    </p><h5 id="输出操作"><a href="#输出操作" class="headerlink" title="输出操作"></a>输出操作</h5><p>io.<strong>puts</strong>(str0, str1, …)<br>指定多个字符串时，会在每个字符串后面添加换行符。   </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$stdout</span>.puts <span class="string">&quot;hi&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hey&quot;</span><span class="comment">#=&gt; hi\nhello\nhey\n</span></span><br></pre></td></tr></table></figure><p>io.<strong>putc</strong>(ch)<br>输出指定参数ch字符，如果参数为字符串，则输出首个字符    </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$stdout</span>.putc(<span class="string">&#x27;H&#x27;</span>)       <span class="comment">#=&gt; H</span></span><br><span class="line"><span class="variable">$stdout</span>.putc(<span class="string">&#x27;Hello&#x27;</span>)   <span class="comment">#=&gt; H</span></span><br><span class="line"><span class="variable">$stdout</span>.putc(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p>io.<strong>print</strong>(str0, str1, …)<br>输出参数指定的字符串，不会在每个字符串后面追加换行符    </p><p>io.<strong>printf</strong>(fmt, arg0, arg1, …)<br>按照指定格式输出字符串。    </p><p>io.<strong>write</strong>(str)<br>输出参数str指定的字符串，方法返回值为输出的字节数    </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="variable">$stdout</span>.write(<span class="string">&quot;Hello&quot;</span>)<span class="comment">#=&gt; Hello</span></span><br><span class="line">p size<span class="comment">#=&gt; 5</span></span><br></pre></td></tr></table></figure><h5 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h5><p>用文件指针或者当前文件偏移量来表示IO对象指向文件的位置。    </p><p>io.<strong>pos</strong><br>io.<strong>pos</strong>&#x3D;position<br>通过<strong>pos</strong>方法获取文件指针位置，改变文件指针使用**pos&#x3D;**方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">File</span>.open(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  io.write(<span class="string">&quot;Hello Ruby&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="title class_">File</span>.open(<span class="string">&quot;hello.txt&quot;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  p io.read(<span class="number">5</span>)      <span class="comment">#=&gt; Hello</span></span><br><span class="line">  io.pos = <span class="number">0</span></span><br><span class="line">  p io.gets         <span class="comment">#=&gt; Hello Ruby</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>io.<strong>seek</strong>(offset, whence)<br>offset为指定位置的整数，whence为指定offset如何移动， 以下为whence的值:<br>IO::SEEK_SET - 将文件指针移动到指定offset指定的位置<br>IO::SEEK_CUR - 将offset视为相对于当前位置的偏移位置来移动文件指针<br>IO::SEEK_END - 将offset视为相对于文件末尾的偏移位置  </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">File</span>.open(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  io.write(<span class="string">&quot;Hello Ruby&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="title class_">File</span>.open(<span class="string">&quot;hello.txt&quot;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  p io.read(<span class="number">5</span>)      <span class="comment">#=&gt; Hello</span></span><br><span class="line">  io.seek(-<span class="number">5</span>, <span class="variable constant_">IO</span><span class="symbol">:</span><span class="symbol">:SEEK_CUR</span>)</span><br><span class="line">  p io.gets         <span class="comment">#=&gt; Hello Ruby</span></span><br><span class="line">  io.seek(<span class="number">0</span>, <span class="variable constant_">IO</span><span class="symbol">:</span><span class="symbol">:SEEK_SET</span>)</span><br><span class="line">  p io.gets         <span class="comment">#=&gt; Hello Ruby</span></span><br><span class="line">  io.seek(-<span class="number">4</span>, <span class="variable constant_">IO</span><span class="symbol">:</span><span class="symbol">:SEEK_END</span>)</span><br><span class="line">  p io.gets         <span class="comment">#=&gt; Ruby</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>io.<strong>rewind</strong><br>将文件指针重置到文件开始处，结果同以下两个操作:    </p><pre><code>io.pos = 0   io.seek(0, IO::SEEK_SET)</code></pre><p>io.<strong>truncate</strong>(size)<br>按照参数size指定的大小截断文件。</p><p>*注，新的IO对象默认为文本模式，可以通过io.<strong>binmode</strong>将其转为二进制模式*   </p><h5 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h5><p>IO对象在输出数据时，结果并不一定会马上输出出来，程序会在内部开辟一个缓冲空间来缓存输出，当空间满的时候再输出来。但是标准错误输出不会使用缓冲，如果有错误信息，则立刻输出。所以标准错误输出一般用于输出警告、错误之类的信息，能够立刻输出数据    </p><p>io.<strong>flush</strong><br>强制输出缓冲中的数据。</p><p>io.<strong>sync</strong><br>io.<strong>sync</strong>&#x3D;state<br>通过io.sync &#x3D; true, 程序写入缓冲时flush方法会被自动调用。    </p><h5 id="与命令行交互"><a href="#与命令行交互" class="headerlink" title="与命令行交互"></a>与命令行交互</h5><p>IO.<strong>popen</strong>(command, mode)<br>command为相关的命令    </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pattern = <span class="title class_">Regexp</span>.new(<span class="variable constant_">ARGV</span>[<span class="number">0</span>])</span><br><span class="line">filename = <span class="variable constant_">ARGV</span>[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> /.gz<span class="variable">$/</span> =~ filename</span><br><span class="line">  file = <span class="variable constant_">IO</span>.popen(<span class="string">&quot;gunzip -c <span class="subst">#&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  file = <span class="title class_">File</span>.open(filename)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">file.close</span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">**open**(&quot;|command&quot;, mode)   </span></span><br><span class="line"><span class="string">将带有管道符号的命令传递给open方法的效果与使用IO.popen方法是一样的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> ruby</span><br><span class="line">filename = <span class="variable constant_">ARGV</span>[<span class="number">0</span>]</span><br><span class="line">open(<span class="string">&quot;|gunzip -c <span class="subst">#&#123;filename&#125;</span>&quot;</span>) <span class="keyword">do</span> |<span class="params">io</span>|</span><br><span class="line">  io.each_line <span class="keyword">do</span> |<span class="params">line</span>|</span><br><span class="line">    print line</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;IO&quot;&gt;&lt;a href=&quot;#IO&quot; class=&quot;headerlink&quot; title=&quot;IO&quot;&gt;&lt;/a&gt;IO&lt;/h4&gt;&lt;p&gt;Ruby程序在启动后会预先分配3个&lt;strong&gt;IO&lt;/strong&gt;对象:&lt;br&gt;标准输入 - 预定义常量(&lt;strong&gt;STDIN&lt;/strong&gt;), 全局变量(&lt;strong&gt;$stdin&lt;/strong&gt;)&lt;br&gt;标准输出 - 预定义常量(&lt;strong&gt;STDOUT&lt;/strong&gt;), 全局变量(&lt;strong&gt;$stdout&lt;/strong&gt;)&lt;br&gt;标准错误输出 - 预定义常量(&lt;strong&gt;STDERR&lt;/strong&gt;), 全局变量(&lt;strong&gt;$stderr&lt;/strong&gt;)&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable&quot;&gt;$stdout&lt;/span&gt;.print &lt;span class=&quot;string&quot;&gt;&amp;quot;output something from $stdout&#92;n&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;variable constant_&quot;&gt;STDERR&lt;/span&gt;.print &lt;span class=&quot;string&quot;&gt;&amp;quot;output something from $stderr&#92;n&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;IO对象是否与控制台关联，我们可以通过**tty?**方法来判断。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$stdin&lt;/span&gt;.tty?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  print &lt;span class=&quot;string&quot;&gt;&amp;quot;stdin is a tty&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  print &lt;span class=&quot;string&quot;&gt;&amp;quot;stdin is not a tty&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Backend" scheme="https://stonefishy.github.io/categories/Backend/"/>
    
    
    <category term="Ruby" scheme="https://stonefishy.github.io/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Ruby修炼之道(17)</title>
    <link href="https://stonefishy.github.io/2015/12/17/ruby-practice-17/"/>
    <id>https://stonefishy.github.io/2015/12/17/ruby-practice-17/</id>
    <published>2015-12-17T01:46:29.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<h4 id="正则表达式-Regexp"><a href="#正则表达式-Regexp" class="headerlink" title="正则表达式(Regexp)"></a>正则表达式(Regexp)</h4><p>Ruby中的正则表达式用<strong>Regexp</strong>类来表示，正则表达式描述的是一种模式，该模式用于匹配字符串。</p><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><p>其创建方式有多种：<br>1.使用**&#x2F; &#x2F;** 把字符串括起来，可以简单地创建出正则表达式</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg1 = <span class="regexp">/Ruby/</span></span><br><span class="line">puts reg1.<span class="keyword">class</span>       <span class="comment">#=&gt; Regexp</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>2.使用**Regexp.new(“字符串”)**创建正则表达式</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reg = <span class="title class_">Regexp</span>.new(<span class="string">&quot;Ruby&quot;</span>)</span><br><span class="line">puts reg.<span class="keyword">class</span>       <span class="comment">#=&gt; Regexp</span></span><br></pre></td></tr></table></figure><p>3.使用**%r**创建正则表达式</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">reg = <span class="regexp">%r(Ruby)</span></span><br><span class="line">puts reg.<span class="keyword">class</span>       <span class="comment">#=&gt; Regexp</span></span><br><span class="line"></span><br><span class="line">reg = %r&lt;<span class="title class_">Ruby</span>&gt;</span><br><span class="line">puts reg.<span class="keyword">class</span>       <span class="comment">#=&gt; Regexp</span></span><br><span class="line"></span><br><span class="line">reg = %r|<span class="params">Ruby</span>|</span><br><span class="line">puts reg.<span class="keyword">class</span>       <span class="comment">#=&gt; Regexp</span></span><br><span class="line"></span><br><span class="line">reg = <span class="regexp">%r!Ruby!</span></span><br><span class="line">puts reg.<span class="keyword">class</span>       <span class="comment">#=&gt; Regexp</span></span><br></pre></td></tr></table></figure><h5 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h5><p>Ruby的正则表达式匹配使用**&#x3D;~**符号，如果匹配成功返回匹配字符串的位置，否则返回nil。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">reg = <span class="regexp">/R..y/</span></span><br><span class="line">str = <span class="string">&quot;regexp of Ruby&quot;</span></span><br><span class="line"></span><br><span class="line">matched = reg =~ str</span><br><span class="line">puts matched        <span class="comment">#=&gt; 10</span></span><br><span class="line"></span><br><span class="line">unmatched = reg =~ <span class="string">&quot;test&quot;</span></span><br><span class="line">p unmatched         <span class="comment">#=&gt; nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> matched</span><br><span class="line">  puts <span class="string">&quot;matched&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  puts <span class="string">&quot;unmatched&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>此处并不过多的介绍正则表达式的语法规则，具体详细语法请参见<a href="http://regexlib.com/CheatSheet.aspx">http://regexlib.com/CheatSheet.aspx</a></p><h5 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h5><p>对特殊字符的转义方式有两种，使用<strong>\</strong>字符和使用<strong>Regexp#quote</strong>方法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#using \ symbol</span></span><br><span class="line">reg = <span class="regexp">/ruby\*regexp/</span></span><br><span class="line">puts reg =~ <span class="string">&quot;ruby*regexp&quot;</span>     <span class="comment">#=&gt; 0</span></span><br><span class="line">p reg =~ <span class="string">&quot;rubyregexp&quot;</span>          <span class="comment">#=&gt; nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#using Regexp#quote method</span></span><br><span class="line">reg1 = <span class="regexp">%r(ruby*regexp)</span></span><br><span class="line">reg2 = <span class="title class_">Regexp</span>.new(<span class="title class_">Regexp</span>.quote(<span class="string">&quot;ruby*regexp&quot;</span>))</span><br><span class="line">str = <span class="string">&quot;ruby*regexp&quot;</span></span><br><span class="line"></span><br><span class="line">p reg1 =~ str         <span class="comment">#=&gt; nil</span></span><br><span class="line">p reg2 =~ str         <span class="comment">#=&gt; 0</span></span><br></pre></td></tr></table></figure><h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><p>在正则表达式的后面添加特定的字符如<strong>i</strong>, <strong>x</strong>, <strong>m</strong>等时，匹配后的规则会有点变化</p><p><strong>i</strong> Regexp::IGNORECASE  忽略字符串大小写<br><strong>x</strong>Regexp::EXTENDED忽略字符串中的空白字符<br><strong>m</strong>Regexp::MULTILINE匹配多行字符串    </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#using i optional symbol to ignore the cap</span></span><br><span class="line">reg1 = <span class="regexp">/test String/i</span></span><br><span class="line">reg2 = <span class="title class_">Regexp</span>.new(<span class="string">&quot;test string&quot;</span>, <span class="title class_">Regexp</span><span class="symbol">:</span><span class="symbol">:IGNORECASE</span>)</span><br><span class="line">puts reg1 =~ <span class="string">&quot;test string&quot;</span>     <span class="comment">#=&gt; 0</span></span><br><span class="line">puts reg1 =~ <span class="string">&quot;test string&quot;</span>     <span class="comment">#=&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#using x optional symbol to ignore the white space symbol</span></span><br><span class="line">reg1 = <span class="regexp">/test string/x</span></span><br><span class="line">reg2 = <span class="title class_">Regexp</span>.new(<span class="string">&quot;test string&quot;</span>, <span class="title class_">Regexp</span><span class="symbol">:</span><span class="symbol">:EXTENDED</span>)</span><br><span class="line">puts reg1 =~ <span class="string">&quot;teststring&quot;</span>      <span class="comment">#=&gt; 0</span></span><br><span class="line">puts reg1 =~ <span class="string">&quot;teststring&quot;</span>      <span class="comment">#=&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#using m optional symbol to match multiline</span></span><br><span class="line">reg1 = <span class="regexp">/test\nstring/m</span></span><br><span class="line">reg2 = <span class="title class_">Regexp</span>.new(<span class="string">&quot;test\nstring&quot;</span>, <span class="title class_">Regexp</span><span class="symbol">:</span><span class="symbol">:MULTILINE</span>)</span><br><span class="line">puts reg1 =~ <span class="string">&quot;test\nstring&quot;</span></span><br><span class="line">puts reg1 =~ <span class="string">&quot;test\nstring&quot;</span>      <span class="comment">#=&gt; 0</span></span><br></pre></td></tr></table></figure><h5 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h5><p>捕获，就是从正则表达式的匹配部分中提取某部分字符，通过”<strong>$数字</strong>“这种形式的变量获取匹配了正则表达式中的用**()**括住的字符。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reg = <span class="regexp">/(.)(C.)(.)/</span></span><br><span class="line">str = <span class="string">&quot;ABCDE&quot;</span></span><br><span class="line">reg =~ str</span><br><span class="line"></span><br><span class="line">puts <span class="variable">$1</span>   <span class="comment">#=&gt; B</span></span><br><span class="line">puts <span class="variable">$2</span>   <span class="comment">#=&gt; CD</span></span><br><span class="line">puts <span class="variable">$3</span>   <span class="comment">#=&gt; E</span></span><br></pre></td></tr></table></figure><p>使用”<strong>(?: )</strong>“可以过滤掉不需要捕获的模式.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reg = <span class="regexp">/(.)(?:C.)(.)/</span></span><br><span class="line">str = <span class="string">&quot;ABCDE&quot;</span></span><br><span class="line">reg =~ str</span><br><span class="line"></span><br><span class="line">puts <span class="variable">$1</span>   <span class="comment">#=&gt; B</span></span><br><span class="line">puts <span class="variable">$2</span>   <span class="comment">#=&gt; E</span></span><br></pre></td></tr></table></figure><p>Ruby中也可以使用**$&#96;**, <strong>$&amp;</strong>, **$’**分别代表匹配部分前的字符串、匹配部分的字符串、匹配部分后的字符串。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reg = <span class="regexp">/(C.)/</span></span><br><span class="line">str = <span class="string">&quot;ABCDE&quot;</span></span><br><span class="line">reg =~ str</span><br><span class="line"></span><br><span class="line">puts <span class="variable">$`</span>     <span class="comment">#=&gt; AB</span></span><br><span class="line">puts <span class="variable">$&amp;</span>     <span class="comment">#=&gt; CD</span></span><br><span class="line">puts <span class="variable">$&#x27;</span>     <span class="comment">#=&gt; E</span></span><br></pre></td></tr></table></figure><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p><strong>sub</strong>和<strong>gsub</strong>方法的作用是用指定的字符置换字符串中的某部分字符。<strong>sub</strong>方法只置换首次匹配的部分，而<strong>gsub</strong>则会置换所有匹配的部分.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reg = <span class="regexp">/\s+/</span></span><br><span class="line">str = <span class="string">&quot;This is test string&quot;</span></span><br><span class="line"></span><br><span class="line">puts str.sub(reg, <span class="string">&#x27;-&#x27;</span>)   <span class="comment">#=&gt; &quot;This-is test string&quot;</span></span><br><span class="line">puts str.gsub(reg, <span class="string">&#x27;-&#x27;</span>)   <span class="comment">#=&gt; &quot;This-is-test-string&quot;</span></span><br></pre></td></tr></table></figure><p>sub和gsub方法同样支持block块模式，针对匹配到的字符做处理</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">reg =<span class="regexp">/i/</span></span><br><span class="line">str = <span class="string">&quot;This is test string&quot;</span></span><br><span class="line"></span><br><span class="line">result = str.sub(reg) <span class="keyword">do</span> |<span class="params">matched</span>|</span><br><span class="line">  matched.upcase</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">puts result     <span class="comment">#=&gt; ThIs is test string</span></span><br><span class="line"></span><br><span class="line">result = str.gsub(reg) <span class="keyword">do</span> |<span class="params">matched</span>|</span><br><span class="line">  matched.upcase</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">puts result     <span class="comment">#=&gt; ThIs Is test strIng</span></span><br></pre></td></tr></table></figure><p><strong>scan</strong>方法和<strong>gsub</strong>方法类似，都可以获取到所有匹配到的字符，但是不能置换。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">reg = <span class="regexp">/(r)(.)/</span></span><br><span class="line">str = <span class="string">&quot;racrtrhrdra&quot;</span></span><br><span class="line">str.scan(reg) <span class="keyword">do</span> |<span class="params">matched</span>|</span><br><span class="line">  p matched</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#[&quot;r&quot;, &quot;a&quot;]</span></span><br><span class="line"><span class="comment">#[&quot;r&quot;, &quot;t&quot;]</span></span><br><span class="line"><span class="comment">#[&quot;r&quot;, &quot;h&quot;]</span></span><br><span class="line"><span class="comment">#[&quot;r&quot;, &quot;d&quot;]</span></span><br><span class="line"><span class="comment">#[&quot;r&quot;, &quot;a&quot;]</span></span><br><span class="line"></span><br><span class="line">str.scan(reg) <span class="keyword">do</span> |<span class="params">val1, val2</span>|</span><br><span class="line">  p val1 + <span class="string">&quot;-&quot;</span> + val2</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#&quot;r-a&quot;</span></span><br><span class="line"><span class="comment">#&quot;r-t&quot;</span></span><br><span class="line"><span class="comment">#&quot;r-h&quot;</span></span><br><span class="line"><span class="comment">#&quot;r-d&quot;</span></span><br><span class="line"><span class="comment">#&quot;r-a&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;正则表达式-Regexp&quot;&gt;&lt;a href=&quot;#正则表达式-Regexp&quot; class=&quot;headerlink&quot; title=&quot;正则表达式(Regexp)&quot;&gt;&lt;/a&gt;正则表达式(Regexp)&lt;/h4&gt;&lt;p&gt;Ruby中的正则表达式用&lt;strong&gt;Regexp&lt;/strong&gt;类来表示，正则表达式描述的是一种模式，该模式用于匹配字符串。&lt;/p&gt;
&lt;h5 id=&quot;创建&quot;&gt;&lt;a href=&quot;#创建&quot; class=&quot;headerlink&quot; title=&quot;创建&quot;&gt;&lt;/a&gt;创建&lt;/h5&gt;&lt;p&gt;其创建方式有多种：&lt;br&gt;1.使用**&amp;#x2F; &amp;#x2F;** 把字符串括起来，可以简单地创建出正则表达式&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;reg1 = &lt;span class=&quot;regexp&quot;&gt;/Ruby/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;puts reg1.&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;       &lt;span class=&quot;comment&quot;&gt;#=&amp;gt; Regexp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Backend" scheme="https://stonefishy.github.io/categories/Backend/"/>
    
    
    <category term="Ruby" scheme="https://stonefishy.github.io/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Using Nginx in Mac OS X</title>
    <link href="https://stonefishy.github.io/2015/12/05/using-nginx-in-mac-os-x/"/>
    <id>https://stonefishy.github.io/2015/12/05/using-nginx-in-mac-os-x/</id>
    <published>2015-12-05T03:51:04.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p><strong>Nginx</strong> is a open source quite lightweight HTTP server which is written by Russian <em>Igor Sysoev</em>, the pronunciation is “engine X”. It’s a high performance HTTP and reverse proxy server, and also it is a IMAP&#x2F;POP3&#x2F;SMTP proxy server。</p><p>There are lots of website using Nginx in China, like Sina, Tencent, 163, Discuz and so on. The Nginx has a very high performance due to event driven way, and also it is a high performance reverse proxy, load balancing.</p><span id="more"></span><p>The features of Nginx Http server are below:</p><p>1.dealing with static file, indexing file and also automatically indexing.</p><p>2.accelerating reverse proxy server,load balancing</p><p>3.FastCGI, Caching, Security</p><p>4.Support SSL and TLS</p><p>From investigation, the Nginx can support about 50,000 concurrence request connection, and also support hot deploy, even running 7*24 hours uninterrupted.   </p><h4 id="Installing"><a href="#Installing" class="headerlink" title="Installing"></a>Installing</h4><p>So, how to install it on Mac OS X. Let’s assume you have installed the <em>Home brew</em>, using brew to install the nginx with command:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure><h4 id="Starting-And-Runing"><a href="#Starting-And-Runing" class="headerlink" title="Starting And Runing"></a>Starting And Runing</h4><p>After install, we can use below command to run it:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx</span><br></pre></td></tr></table></figure><p>If you get the failed message which is “[emerg] bind() to 0.0.0.0:8080 failed (48: Address already in use)”. You have to kill the progress which is running with that address, it usually is Apache. And also there is another way, changing the port number, we will introduce later.</p><p>The nginx running success, you will get the below page when you access the <a href="http://localhost:8080/">http://localhost:8080</a></p><p><img src="/assets/images/legacy/nginx-welcome.png" class="lazyload placeholder" data-srcset="/assets/images/legacy/nginx-welcome.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="nginx, devops"></p><p>There are several commands to start, stop nginx and reload configuration.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop #=&gt; fast shutdown</span><br><span class="line"></span><br><span class="line">nginx -s quit#=&gt; graceful shutdown</span><br><span class="line"></span><br><span class="line">nginx -s reload#=&gt; reloading the configuration file</span><br><span class="line"></span><br><span class="line">nginx -s reopen#=&gt; reopening the log files</span><br></pre></td></tr></table></figure><h4 id="Simple-Configuration"><a href="#Simple-Configuration" class="headerlink" title="Simple Configuration"></a>Simple Configuration</h4><p>The default place of nginx.conf on Mac after installing with brew is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><p>Let’s change the port number in this file. First, we need to stop the nginx.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx -s stop</span><br></pre></td></tr></table></figure><p>And then open that file, you will see the below server configuration section. It includes the listen, server_name, location&#x2F;root, location&#x2F;index. location&#x2F;root is your website root folder, and index is your website first page file.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen       8080;</span><br><span class="line">server_name  localhost;</span><br><span class="line"></span><br><span class="line">#access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>okay, let’s change the port number from 8080 to 80, and then run it again</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nginx</span><br></pre></td></tr></table></figure><p>Access it with <a href="http://localhost/">http://localhost</a>, the 80 port number is http default port number, so we don’t need to append it into url.</p><p>Now, let’s put our blog website in the nginx, to do so, we need to reference the location&#x2F;root to our blog website folder.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen       80;</span><br><span class="line">server_name  localhost;</span><br><span class="line"></span><br><span class="line">#access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    root   /Users/yushi/Codes/Blog/stonefishy.github.io/public;;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>let’s running it again with clicking <a href="http://localhost/">http://localhost</a>. Woow, cool, very nice, we can access our blog with nignx.</p><p>This is a just simple usage of nginx, we will talk about more later.</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Nginx&lt;/strong&gt; is a open source quite lightweight HTTP server which is written by Russian &lt;em&gt;Igor Sysoev&lt;/em&gt;, the pronunciation is “engine X”. It’s a high performance HTTP and reverse proxy server, and also it is a IMAP&amp;#x2F;POP3&amp;#x2F;SMTP proxy server。&lt;/p&gt;
&lt;p&gt;There are lots of website using Nginx in China, like Sina, Tencent, 163, Discuz and so on. The Nginx has a very high performance due to event driven way, and also it is a high performance reverse proxy, load balancing.&lt;/p&gt;</summary>
    
    
    
    <category term="Tools" scheme="https://stonefishy.github.io/categories/Tools/"/>
    
    
    <category term="MacOS" scheme="https://stonefishy.github.io/tags/MacOS/"/>
    
    <category term="Nginx" scheme="https://stonefishy.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>代码审查之Pull Request</title>
    <link href="https://stonefishy.github.io/2015/11/22/code-review-with-pull-request/"/>
    <id>https://stonefishy.github.io/2015/11/22/code-review-with-pull-request/</id>
    <published>2015-11-22T05:54:34.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<p>代码审查(Code Review)一直是一个高效团队里面必备的流程，团队成员可以通过它达到技术交流，相互学习以及提升自身编码水平的目的。当然它的目的并不止于此，我们在做某一件事的过程中，所用的技能和工具不外乎都是为了能使结果更符合我们的期望，就拿建筑工程来说，质量控制就是其把控最严的一关，有专门的质量管理领导小组、质量组织管理体系制度来贯穿这个过程，其最终目的就是为了使这栋建筑坚固牢稳，避免随时有可能崩塌的危险。</p><span id="more"></span><p>软件开发也一样，代码审查的另外一个目的就是为了保证软件的质量，避免系统中存在较多的Bug（软件中Bug是无法避免的，此处意思是尽量减少Bug出现的几率）。在我们以往的代码审查过程中，采用的主要形式是开发人员围在一起查看今天是否有哪些代码提交，然后针对提交的代码过一遍，发现有好的实践就相互学习，针对待提升的代码讨论后由Owner自己下去修改。这个过程看似很正常，其实里面存在较多的问题：</p><ul><li>其一，好的实践并没有在代码中标明，以及为什么是个好的实践，而且当想回顾查找的时候很困难；  </li><li>其二，每个开发人员对同一个提交的想法和见解可能不一样，但是这些想法和见解却并没有被记录下来；    </li><li>其三，也是最重要的一个，没有载体去记录哪些代码须改进，那么在下次Review的过程中，并不是所有人都记得上次有哪些代码是否已经改进了，这就会导致代码的质量没有受到监管。</li></ul><p>任何一种工作方法，如果有工具的辅助，就可以大大提高其效率。Pull Request就是代码审查的一种工作流工具，它并不是DVCS(Distributed Version Control System)比如git的一个特性，通过它可以使代码审查更有效率。而我们大多项目现在都是用Stash（现在已更名为Bitbucket）或Github作为代码仓库，两者均提供了这种方式来确保代码质量。</p><p>那么如何通过Pull Request来体现我们的代码质量管理过程呢？首先代码质量管理小组需要由项目中比较资深的研发人员构成，他们是Pull Request的Reviewer不可缺少的成员，用于把控提交的代码是否可以通过，当然，最好是全体研发人员一起加入。而代码质量管理体系制度其实也就是我们常说的一些规范和实践，包括项目统一的编码风格、代码的可读性、可维护性、合理的单元测试以及提倡的一些最佳实践等等。Reviewer可以通过此类体系来鉴别所提交的代码质量是否可以过关。</p><p>在此处我们并不阐述如何创建一个Pull Request，我们的焦点在于用它来解决之前遇到的问题。以我们现在项目中用的Stash为例，当Pull Request已创建并通知Reviewer后，Reviewer可以查看其提交代码，做出以下Action:</p><ul><li>针对好的实践代码或设计可以在其位置标注上注释，以备后续回顾查找时容易找到。</li><li>建议被添加为Reviewer的开发人员均要在此次的Pull Request中留下自己的意见，这样在后续的集体Code Review中可以查看到相互的见解。</li><li>如果发现代码存在问题的，可以及时在代码中留下注释。如果代码提交者对这个注释也赞同，可当即修改并更新Pull Request，这样可以保证代码是已经修正过的。</li></ul><p><img src="/assets/images/legacy/stash-pull-request.png" class="lazyload placeholder" data-srcset="/assets/images/legacy/stash-pull-request.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="stash-pull-request.png"></p><p>当一个Pull Request相关问题都已修改后或不存在任何问题时，就可以直接Approve并Merge到CodeBase中去，这样能够很好的确保CodeBase中的代码是经过监管控制过的。而且在Stash的Pull Request中，还可以设置当须不少于指定个数的Reviewer同意代码提交通过后，提交者才有权限Merge到CodeBase中。这样也能极大的确保项目的代码质量规范是整体开发人员认同的。</p><p>总之，Pull Request工作流程的方式可以很大的提高代码审查的质量以及效率，有工具，为何不加以合理使用呢？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;代码审查(Code Review)一直是一个高效团队里面必备的流程，团队成员可以通过它达到技术交流，相互学习以及提升自身编码水平的目的。当然它的目的并不止于此，我们在做某一件事的过程中，所用的技能和工具不外乎都是为了能使结果更符合我们的期望，就拿建筑工程来说，质量控制就是其把控最严的一关，有专门的质量管理领导小组、质量组织管理体系制度来贯穿这个过程，其最终目的就是为了使这栋建筑坚固牢稳，避免随时有可能崩塌的危险。&lt;/p&gt;</summary>
    
    
    
    <category term="Others" scheme="https://stonefishy.github.io/categories/Others/"/>
    
    
    <category term="Git" scheme="https://stonefishy.github.io/tags/Git/"/>
    
    <category term="Collaboration" scheme="https://stonefishy.github.io/tags/Collaboration/"/>
    
  </entry>
  
  <entry>
    <title>Ruby修炼之道(16)</title>
    <link href="https://stonefishy.github.io/2015/11/18/ruby-practice-16/"/>
    <id>https://stonefishy.github.io/2015/11/18/ruby-practice-16/</id>
    <published>2015-11-18T02:49:41.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<h4 id="散列类"><a href="#散列类" class="headerlink" title="散列类"></a>散列类</h4><p>散列(<strong>Hash</strong>)和数组一样，都是表示对象集合的对象，不同之处在于，数组使用索引来取得元素，而散列则是用键key，key可以是任何对象，而索引则不能，只能是整数。</p><h5 id="散列的创建"><a href="#散列的创建" class="headerlink" title="散列的创建"></a>散列的创建</h5><p>1.使用 <strong>{}</strong></p><pre><code>    &#123;key=&gt;value&#125;    或    &#123;key:value&#125;</code></pre><span id="more"></span><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash1 = &#123;<span class="string">&quot;key1&quot;</span>=&gt;<span class="string">&quot;value1&quot;</span>, <span class="string">&quot;key2&quot;</span>=&gt;<span class="string">&quot;value2&quot;</span>&#125;</span><br><span class="line">p hash1[<span class="string">&quot;key1&quot;</span>]<span class="comment">#=&gt; &quot;value1&quot;</span></span><br><span class="line"></span><br><span class="line">hash2 = &#123;<span class="symbol">key1:</span><span class="string">&quot;value1&quot;</span>, <span class="symbol">key2:</span><span class="string">&quot;value2&quot;</span>&#125;</span><br><span class="line">p hash2[<span class="symbol">:key1</span>]<span class="comment">#=&gt; &quot;value1&quot;</span></span><br></pre></td></tr></table></figure><p>2.使用<strong>Hash.new</strong></p><p>Hash.new()可带参数，当带参数的时候表示该参数为默认值，即当键不存在时，所得的值为该默认值；不带参数情况下，其默认值为nil</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash1 = <span class="title class_">Hash</span>.new</span><br><span class="line">hash2 = <span class="title class_">Hash</span>.new(<span class="string">&quot;ruby&quot;</span>)</span><br><span class="line"></span><br><span class="line">p hash1[<span class="string">&quot;key&quot;</span>]<span class="comment">#=&gt; nil</span></span><br><span class="line">p hash2[<span class="string">&quot;key&quot;</span>]<span class="comment">#=&gt; &quot;ruby&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>散列的键可以是任意对象，一般推荐使用下列类型的对象来作为键：字符串(String), 数值(Numberic), 符号(Symbol), 日期(Date).</p><h5 id="散列值的设置和获取"><a href="#散列值的设置和获取" class="headerlink" title="散列值的设置和获取"></a>散列值的设置和获取</h5><p>一般情况下，我们大多使用最普通的方法来给散列赋值或取值, 如果键不存在，则返回nil</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#common set and get</span></span><br><span class="line">hash = <span class="title class_">Hash</span>.new</span><br><span class="line">hash[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;first&quot;</span></span><br><span class="line"></span><br><span class="line">p hash[<span class="string">&quot;a&quot;</span>]<span class="comment">#=&gt; &quot;first&quot;</span></span><br><span class="line">p hash[<span class="string">&quot;abc&quot;</span>]<span class="comment">#=&gt; nil</span></span><br></pre></td></tr></table></figure><p>Ruby还提供了<strong>store</strong>方法来存储值，使用<strong>fetch</strong>方法来获取值</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#store and fetch</span></span><br><span class="line">hash = <span class="title class_">Hash</span>.new</span><br><span class="line"></span><br><span class="line">hash.store(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;ruby&quot;</span>)</span><br><span class="line"></span><br><span class="line">p hash.fetch(<span class="string">&quot;key&quot;</span>)<span class="comment">#=&gt; &quot;ruby&quot;</span></span><br></pre></td></tr></table></figure><p>但<strong>fetch</strong>方法与[]不同之处在于，如果hash对象中不存在键时，使用此方法将会出错</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash = <span class="title class_">Hash</span>.new</span><br><span class="line"></span><br><span class="line">hash.store(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;ruby&quot;</span>)</span><br><span class="line"></span><br><span class="line">hash.fetch(<span class="string">&quot;abc&quot;</span>)<span class="comment">#=&gt; KeyError</span></span><br></pre></td></tr></table></figure><p><strong>fetch</strong>方法同样可以返回一个默认值，当它指定第2个参数时或者带块时</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash = <span class="title class_">Hash</span>.new</span><br><span class="line"></span><br><span class="line">p hash.fetch(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;default value&quot;</span>)<span class="comment">#=&gt; &quot;default value&quot;</span></span><br><span class="line"></span><br><span class="line">p hash.fetch(<span class="string">&quot;abc&quot;</span>) &#123;<span class="string">&quot;a_&quot;</span>+ <span class="title class_">String</span>.new(<span class="string">&quot;bc&quot;</span>)&#125;<span class="comment">#=&gt;&quot;a_bc&quot;</span></span><br></pre></td></tr></table></figure><p>通过<strong>keys</strong>和<strong>values</strong>方法可以得到所有的键和值，而且<strong>to_a</strong>方法可以键值组合的数组。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">get all keys <span class="keyword">and</span> values</span><br><span class="line">hash = &#123;<span class="string">&quot;a&quot;</span>=&gt;<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>=&gt;<span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">p hash.keys<span class="comment">#=&gt; [&quot;a&quot;, &quot;c&quot;]</span></span><br><span class="line">p hash.values<span class="comment">#=&gt; [&quot;b&quot;, &quot;d&quot;]</span></span><br><span class="line">p hash.to_a<span class="comment">#=&gt; [[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;]]</span></span><br></pre></td></tr></table></figure><p>Ruby也支持了Hash对象的迭代遍历</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hash = &#123;<span class="string">&quot;a&quot;</span>=&gt;<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>=&gt;<span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">hash.each_key <span class="keyword">do</span> |<span class="params">key</span>|</span><br><span class="line">puts key</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">hash.each_value <span class="keyword">do</span> |<span class="params">value</span>|</span><br><span class="line">puts value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">hash.each <span class="keyword">do</span> |<span class="params">key, value</span>|</span><br><span class="line">puts <span class="string">&quot;<span class="subst">#&#123;key&#125;</span>=&gt;<span class="subst">#&#123;value&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="散列的默认值"><a href="#散列的默认值" class="headerlink" title="散列的默认值"></a>散列的默认值</h5><p>散列的默认值设置有三种方式<br>1.使用Hash.new带参数作为默认值</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash = <span class="title class_">Hash</span>.new(<span class="string">&quot;ruby&quot;</span>)</span><br><span class="line">p hash[<span class="string">&quot;a&quot;</span>] <span class="comment">#=&gt; &quot;ruby&quot;</span></span><br></pre></td></tr></table></figure><p>2.使用块指定默认值</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash = <span class="title class_">Hash</span>.new <span class="keyword">do</span> |<span class="params">hash, key</span>|</span><br><span class="line">hash[key] = key.upcase</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p hash[<span class="string">&quot;a&quot;</span>]<span class="comment">#=&gt; &quot;A&quot;</span></span><br><span class="line">p hash[<span class="string">&quot;B&quot;</span>]<span class="comment">#=&gt; &quot;B&quot;</span></span><br></pre></td></tr></table></figure><p>3.使用fetch方法指定默认值</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash = <span class="title class_">Hash</span>.new <span class="keyword">do</span> |<span class="params">hash, key</span>|</span><br><span class="line">hash[key] = key.upcase</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p hash.fetch(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;abc&quot;</span>)<span class="comment">#=&gt; &quot;abc&quot;</span></span><br></pre></td></tr></table></figure><p><em>注：当Hash.new方法指定了默认值或块时，fetch方法的第二个参数指定的默认值的优先级是最高的，且看上例</em></p><h5 id="散列其他方法"><a href="#散列其他方法" class="headerlink" title="散列其他方法"></a>散列其他方法</h5><p>1.查看指定对象是否为散列的键<br>h.<strong>key?</strong>(key)<br>h.<strong>has_key?</strong>(key)<br>h.<strong>include?</strong>(key)<br>h.<strong>member?</strong>(key)   </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hash = &#123;<span class="string">&quot;a&quot;</span> =&gt; <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>=&gt; <span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">p hash.key?(<span class="string">&quot;a&quot;</span>)    <span class="comment">#=&gt; true</span></span><br><span class="line">p hash.key?(<span class="string">&quot;x&quot;</span>)    <span class="comment">#=&gt; false</span></span><br><span class="line">p hash.has_key?(<span class="string">&quot;c&quot;</span>)  <span class="comment">#=&gt; true</span></span><br><span class="line">p hash.<span class="keyword">include</span>?(<span class="string">&quot;a&quot;</span>)  <span class="comment">#=&gt; true</span></span><br><span class="line">p hash.member?(<span class="string">&quot;x&quot;</span>)   <span class="comment">#=&gt; false</span></span><br></pre></td></tr></table></figure><p>2.查看指定对象是否为散列的值<br>h.<strong>value?</strong>(val)<br>h.<strong>has_value?</strong>(val)    </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hash = &#123;<span class="string">&quot;a&quot;</span>=&gt;<span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>=&gt;<span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">p hash.value?(<span class="string">&quot;a&quot;</span>)        <span class="comment">#=&gt; true</span></span><br><span class="line">p hash.has_value?(<span class="string">&quot;x&quot;</span>)    <span class="comment">#=&gt; false</span></span><br></pre></td></tr></table></figure><p>3.获取散列的大小<br>hash.<strong>length</strong><br>hash.<strong>size</strong>    </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hash = &#123;<span class="symbol">:a</span> =&gt; <span class="string">&quot;b&quot;</span>, <span class="symbol">:c</span> =&gt; <span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">p hash.length   <span class="comment">#=&gt; 2</span></span><br><span class="line">p hash.size   <span class="comment">#=&gt; 2</span></span><br></pre></td></tr></table></figure><p>4.判断散列是否为空<br>hash.<strong>empty?</strong>    </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash = &#123;<span class="symbol">:a=&gt;<span class="string">&quot;b&quot;</span></span>&#125;</span><br><span class="line">p hash.empty?     <span class="comment">#=&gt; false</span></span><br><span class="line"></span><br><span class="line">hash = <span class="title class_">Hash</span>.new</span><br><span class="line">p hash.empty?     <span class="comment">#=&gt; true</span></span><br></pre></td></tr></table></figure><p>6.删除键值<br>h.<strong>delete</strong>(key)<br>h.<strong>delete_if</strong>{|key,val| …}<br>h.<strong>reject!</strong>{|key, val| …}    </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hash = &#123;<span class="symbol">:a</span> =&gt; <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">p hash[<span class="symbol">:a</span>]    <span class="comment">#=&gt; &quot;b&quot;</span></span><br><span class="line"></span><br><span class="line">hash.delete(<span class="symbol">:a</span>)</span><br><span class="line">p hash[<span class="symbol">:a</span>]    <span class="comment">#=&gt; nil</span></span><br><span class="line"></span><br><span class="line">hash = &#123;<span class="symbol">:a</span> =&gt; <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">p hash.delete(<span class="symbol">:x</span>) &#123; |<span class="params">key</span>| <span class="string">&quot;no <span class="subst">#&#123;key&#125;</span> in this hash object&quot;</span>&#125;   <span class="comment">#=&gt;&quot;no x in this hash object&quot;</span></span><br><span class="line"></span><br><span class="line">hash = &#123;<span class="symbol">:a</span> =&gt; <span class="string">&quot;b&quot;</span>, <span class="symbol">:c</span> =&gt; <span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">p hash.delete_if &#123;|<span class="params">key, val</span>| key == <span class="symbol">:a</span> &#125;     <span class="comment">#=&gt; &#123;:c=&gt;&quot;d&quot;&#125;</span></span><br><span class="line">p hash.delete_if &#123;|<span class="params">key, val</span>| key == <span class="symbol">:b</span> &#125;     <span class="comment">#=&gt; &#123;:c=&gt;&quot;d&quot;&#125;</span></span><br><span class="line"></span><br><span class="line">hash = &#123;<span class="symbol">:a</span> =&gt; <span class="string">&quot;b&quot;</span>, <span class="symbol">:c</span> =&gt; <span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">p hash.reject! &#123;|<span class="params">key, val</span>| key == <span class="symbol">:a</span>&#125;       <span class="comment">#=&gt; &#123;:c=&gt;&quot;d&quot;&#125;</span></span><br><span class="line">p hash.reject! &#123;|<span class="params">key, val</span>| key == <span class="symbol">:b</span>&#125;       <span class="comment">#=&gt; nil</span></span><br></pre></td></tr></table></figure><p>delete方法带块时，如果不存在指定的键, 则返回块中的结果。<strong>delete_if</strong>方法和**reject!**功能一样，区别在于如果不满足条件是，delete_if返回的是散列对象本身，而reject！则返回nil。</p><p>7.初始化散列<br>h.<strong>clear</strong><br>用<strong>clear</strong>方法清空使用过的散列</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hash = &#123;<span class="symbol">a:</span><span class="string">&quot;b&quot;</span>, <span class="symbol">c:</span><span class="string">&quot;d&quot;</span>&#125;</span><br><span class="line">p hash.size     <span class="comment">#=&gt; 2</span></span><br><span class="line"></span><br><span class="line">hash.clear</span><br><span class="line">p hash.size     <span class="comment">#=&gt; 0</span></span><br></pre></td></tr></table></figure><h5 id="关于散列的键"><a href="#关于散列的键" class="headerlink" title="关于散列的键"></a>关于散列的键</h5><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hash = <span class="title class_">Hash</span>.new</span><br><span class="line">key1 = <span class="number">1</span></span><br><span class="line">key2 = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">p key1 == key2      <span class="comment">#=&gt; true</span></span><br><span class="line"></span><br><span class="line">hash[key1] = <span class="string">&quot;ruby&quot;</span></span><br><span class="line">p hash.key?(key1)     <span class="comment">#=&gt; true</span></span><br><span class="line">p hash.has_key?(key2)   <span class="comment">#=&gt; false</span></span><br></pre></td></tr></table></figure><p>注：在散列内部，程序会将散列获取值时指定的键，与将值保存到散列时指定的键做比较，判断两者是否一致。具体来说就是，如果两个键key1，key2，当key1.hash与key2.hash得到的整数值相同，并且key1.eql?(key2)为true时，就会认为这两个键是一致的。</p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;散列类&quot;&gt;&lt;a href=&quot;#散列类&quot; class=&quot;headerlink&quot; title=&quot;散列类&quot;&gt;&lt;/a&gt;散列类&lt;/h4&gt;&lt;p&gt;散列(&lt;strong&gt;Hash&lt;/strong&gt;)和数组一样，都是表示对象集合的对象，不同之处在于，数组使用索引来取得元素，而散列则是用键key，key可以是任何对象，而索引则不能，只能是整数。&lt;/p&gt;
&lt;h5 id=&quot;散列的创建&quot;&gt;&lt;a href=&quot;#散列的创建&quot; class=&quot;headerlink&quot; title=&quot;散列的创建&quot;&gt;&lt;/a&gt;散列的创建&lt;/h5&gt;&lt;p&gt;1.使用 &lt;strong&gt;{}&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    &amp;#123;key=&amp;gt;value&amp;#125;
    或
    &amp;#123;key:value&amp;#125;
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="Backend" scheme="https://stonefishy.github.io/categories/Backend/"/>
    
    
    <category term="Ruby" scheme="https://stonefishy.github.io/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Ruby修炼之道(15)</title>
    <link href="https://stonefishy.github.io/2015/11/17/ruby-practice-15/"/>
    <id>https://stonefishy.github.io/2015/11/17/ruby-practice-15/</id>
    <published>2015-11-17T08:15:17.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<h5 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h5><p>Ruby中比较字符串是否相同也是用**&#x3D;&#x3D;<strong>和</strong>!&#x3D;**等运算符</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#whether two strings are equal</span></span><br><span class="line">puts <span class="string">&quot;aaa&quot;</span> == <span class="string">&quot;aab&quot;</span> <span class="comment">#=&gt; false</span></span><br><span class="line">puts <span class="string">&quot;aaa&quot;</span> != <span class="string">&quot;aab&quot;</span><span class="comment">#=&gt; true</span></span><br></pre></td></tr></table></figure><p>如果是判断两字符串是否相似，采用正则表达式匹配更加简单。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#whether two strings are similar</span></span><br><span class="line">reg = <span class="title class_">Regexp</span>.new(<span class="string">&quot;^a+b$&quot;</span>)</span><br><span class="line">p <span class="string">&quot;aaa&quot;</span> =~ reg <span class="comment">#=&gt; nil (not similar)</span></span><br><span class="line">p <span class="string">&quot;ab&quot;</span> =~ reg <span class="comment">#=&gt; 0 (similar)</span></span><br><span class="line">p <span class="string">&quot;aab&quot;</span> =~ reg <span class="comment">#=&gt; 0 (similar)</span></span><br><span class="line">p <span class="string">&quot;acb&quot;</span> =~ reg <span class="comment">#=&gt; nil (not similar)</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>字符串大小由字符编码的顺序决定，可以通过调用<strong>String#ord</strong>方法获取字符编码的码位。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#compare two strings, which is bigger</span></span><br><span class="line">puts <span class="string">&quot;aaa&quot;</span> &gt; <span class="string">&quot;aab&quot;</span><span class="comment">#=&gt; false</span></span><br><span class="line">puts <span class="string">&quot;aaa&quot;</span> &lt;= <span class="string">&quot;aab&quot;</span><span class="comment">#=&gt; true</span></span><br></pre></td></tr></table></figure><p><em>注：Windows平台下的中文字符使用GBK编码，但非Windows平台下的中文字符使用UTF-8编码</em></p><h5 id="字符串的分割"><a href="#字符串的分割" class="headerlink" title="字符串的分割"></a>字符串的分割</h5><p>用特定字符分割字符串时可以使用<strong>split</strong>方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#split string with a special character</span></span><br><span class="line">str = <span class="string">&quot;This is a string&quot;</span></span><br><span class="line">p str.split(<span class="string">&quot; &quot;</span>) <span class="comment">#=&gt; [&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;string&quot;]</span></span><br></pre></td></tr></table></figure><h5 id="字符串的换行符"><a href="#字符串的换行符" class="headerlink" title="字符串的换行符"></a>字符串的换行符</h5><p>用<strong>each_line</strong>方法从标准输入读取字符串时，字符串后面肯定有换行符。在操作字符串时，我们可能不需要换行符。此时可以使用<strong>chomp</strong>和**chomp!**方法来删除字符串行末的换行符。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#delete the line break character from a string</span></span><br><span class="line">str = <span class="string">&quot;hello ruby\n&quot;</span></span><br><span class="line">p str  <span class="comment">#=&gt; &quot;hello ruby\n&quot;</span></span><br><span class="line">p str.chomp <span class="comment">#=&gt; &quot;hello ruby&quot;</span></span><br><span class="line">p str.chomp!<span class="comment">#=&gt; &quot;hello ruby&quot;</span></span><br><span class="line">p str <span class="comment">#=&gt; &quot;hello ruby&quot;</span></span><br></pre></td></tr></table></figure><p>如果说只想移除字符串行末的最后一个任意字符，可以通过是用<strong>chop</strong>和**chop!**方法来实现</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#delete the last character from a string</span></span><br><span class="line">str = <span class="string">&quot;hello ruby&quot;</span></span><br><span class="line">puts str.chop<span class="comment">#=&gt; hello rub</span></span><br><span class="line">puts str <span class="comment">#=&gt; hello ruby</span></span><br><span class="line">puts str.chop!<span class="comment">#=&gt; hello rub</span></span><br><span class="line">puts str<span class="comment">#=&gt; hello rub</span></span><br></pre></td></tr></table></figure><h5 id="字符串的索引"><a href="#字符串的索引" class="headerlink" title="字符串的索引"></a>字符串的索引</h5><p>使用<strong>index</strong>和<strong>rindex</strong>方法可以获取某个字符串在另一个字符串中得索引位置，如果不在，则返回nil。<strong>index</strong>方法从左向右检索，<strong>rindex</strong>从右向左检索。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#get the index which a string in another string</span></span><br><span class="line">str1 = <span class="string">&quot;aaabbbbbb&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;bb&quot;</span></span><br><span class="line"></span><br><span class="line">puts str1.index(str2)   <span class="comment">#=&gt; 3</span></span><br><span class="line">puts str1.rindex(str2)  <span class="comment">#=&gt; 7</span></span><br></pre></td></tr></table></figure><p>如果只想判断某个字符串中是否包含另一个字符串时，使用**include?**方法更佳。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#a string whether contains another string</span></span><br><span class="line">str1 = <span class="string">&quot;abc&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;ab&quot;</span></span><br><span class="line">puts str1.<span class="keyword">include</span>?(str2) <span class="comment">#=&gt; true</span></span><br></pre></td></tr></table></figure><h5 id="字符串的置换"><a href="#字符串的置换" class="headerlink" title="字符串的置换"></a>字符串的置换</h5><p>字符串的置换可以通过调用<strong>sub</strong>和<strong>gsub</strong>来实现。<strong>sub</strong>方法仅替换第一个出现的匹配字符，而<strong>gsub</strong>则会替换所有的匹配字符。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#the replacing of string</span></span><br><span class="line">puts <span class="string">&quot;hello&quot;</span>.sub(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)<span class="comment">#=&gt; he*lo</span></span><br><span class="line">puts <span class="string">&quot;hello&quot;</span>.gsub(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)<span class="comment">#=&gt; he**o</span></span><br></pre></td></tr></table></figure><p>字符串的置换还可以通过像替换数组中元素的方式来实现，即索引</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">str[<span class="number">2</span>] = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">puts str <span class="comment">#=&gt; he*lo</span></span><br><span class="line"></span><br><span class="line">str[<span class="number">2</span>..<span class="number">3</span>] = <span class="string">&#x27;**&#x27;</span>       </span><br><span class="line">puts str      <span class="comment">#=&gt; he**o</span></span><br><span class="line"></span><br><span class="line">str[<span class="number">1</span>, <span class="number">3</span>]= <span class="string">&#x27;***&#x27;</span>  </span><br><span class="line">puts str <span class="comment">#=&gt; h***o</span></span><br></pre></td></tr></table></figure><h5 id="字符串与数组相同的方法"><a href="#字符串与数组相同的方法" class="headerlink" title="字符串与数组相同的方法"></a>字符串与数组相同的方法</h5><p>字符串的很多方法都与数组相同，主要分为以下三大类：    </p><ul><li>与索引操作相关的方法   </li><li>与<strong>Enumerable</strong>模块相关的方法    </li><li>与连接、反转相关的方法</li></ul><p>删除字符串中的一部分字符并返回，可使用<strong>slice</strong>方法    </p><p><strong>slice(n)</strong><br><strong>slice(n..m)</strong><br><strong>slice(n, m)</strong><br><strong>slice!(n)</strong><br><strong>slice!(n..m)</strong><br><strong>slice!(n, m)</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#the slice of string</span></span><br><span class="line">str = <span class="string">&quot;hello ruby&quot;</span></span><br><span class="line">puts str.slice(<span class="number">1</span>)<span class="comment">#=&gt; e</span></span><br><span class="line">puts str.slice(<span class="number">1</span>..<span class="number">3</span>)<span class="comment">#=&gt; ell</span></span><br><span class="line">puts str.slice(<span class="number">2</span>, <span class="number">3</span>)<span class="comment">#=&gt; llo</span></span><br></pre></td></tr></table></figure><p>不带块的情况下，大部分原生的迭代器在调用时都会返回<strong>Enumberable</strong>对象。因此我们可以对<strong>each_line</strong>, <strong>each_byte</strong>， <strong>each_char</strong>等方法的返回值继续使用像<strong>map</strong>， <strong>collect</strong>等方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#the enumerable of string</span></span><br><span class="line">str = <span class="string">&lt;&lt;EOB</span></span><br><span class="line"><span class="string">hello</span></span><br><span class="line"><span class="string">ruby</span></span><br><span class="line"><span class="string">EOB</span></span><br><span class="line"></span><br><span class="line">p str <span class="comment">#=&gt; &quot;hello\nruby\n&quot;</span></span><br><span class="line"><span class="comment">#return enumerable</span></span><br><span class="line">p str.each_line <span class="comment">#=&gt; #&lt;Enumerator: &quot;hello\nruby\n&quot;:each_line&gt;</span></span><br><span class="line"></span><br><span class="line">p str.each_line.map &#123; |<span class="params">e</span>| e.chomp  &#125;   <span class="comment">#=&gt; [&quot;hello&quot;, &quot;ruby&quot;]</span></span><br><span class="line"></span><br><span class="line">p str.each_line.collect &#123; |<span class="params">e</span>| e.chomp.upcase&#125; <span class="comment">#=&gt; [&quot;HELLO&quot;, &quot;RUBY&quot;]</span></span><br></pre></td></tr></table></figure><p><strong>delete(str)</strong><br><strong>delete!(str)</strong><br>删除字符串中指定的字符串，并返回删除后的字符</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#delete the specific string from another string</span></span><br><span class="line">str = <span class="string">&quot;hello\n ruby\n&quot;</span></span><br><span class="line">p str.delete(<span class="string">&quot;\n&quot;</span>)      <span class="comment">#=&gt; &quot;hello ruby&quot;</span></span><br><span class="line">p str <span class="comment">#=&gt; &quot;hello\n ruby\n&quot;</span></span><br><span class="line"></span><br><span class="line">p str.delete!(<span class="string">&quot;\n&quot;</span>)<span class="comment">#=&gt; &quot;hello ruby&quot;</span></span><br><span class="line">p str <span class="comment">#=&gt; &quot;hello ruby&quot;</span></span><br></pre></td></tr></table></figure><p><strong>reverse(str)</strong><br><strong>reverse!(str)</strong><br>反转字符串，包括破坏方法与非破坏方法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#reverse a string</span></span><br><span class="line">str = <span class="string">&quot;hello ruby&quot;</span></span><br><span class="line">p str.reverse <span class="comment">#=&gt; &quot;ybur olleh&quot;</span></span><br></pre></td></tr></table></figure><p><strong>str.strip</strong><br><strong>str.strip!</strong><br>删除字符串str中行首和行尾的空白字符    </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#remove the white space at the begin and end of string</span></span><br><span class="line">str = <span class="string">&quot; hello ruby &quot;</span></span><br><span class="line">p str <span class="comment">#=&gt; &quot; hello ruby&quot;</span></span><br><span class="line">p str.strip     <span class="comment">#=&gt; &quot;hello ruby&quot;</span></span><br></pre></td></tr></table></figure><p><strong>str.upcase&#x2F;str.upcase!</strong><br><strong>str.downcase&#x2F;str.downcase!</strong><br><strong>str.swapcase&#x2F;str.swapcase!</strong><br><strong>str.capitalize&#x2F;str.capitalize!</strong><br>字符串大小写的转换系列方法, <strong>swapcase</strong>方法是将字符串中的大小写相互转换。而<strong>capitalize</strong>方法则是将字符串的首个字符大写，其余的均改为小写    </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#text transform</span></span><br><span class="line">str = <span class="string">&quot;Hello RUBY&quot;</span></span><br><span class="line">p str.upcase <span class="comment">#=&gt; &quot;HELLO RUBY&quot;</span></span><br><span class="line">p str.downcase<span class="comment">#=&gt; &quot;hello ruby&quot;</span></span><br><span class="line">p str.swapcase          <span class="comment">#=&gt; &quot;hELLO ruby&quot;</span></span><br><span class="line">p str.capitalize<span class="comment">#=&gt; &quot;Hello ruby&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;字符串比较&quot;&gt;&lt;a href=&quot;#字符串比较&quot; class=&quot;headerlink&quot; title=&quot;字符串比较&quot;&gt;&lt;/a&gt;字符串比较&lt;/h5&gt;&lt;p&gt;Ruby中比较字符串是否相同也是用**&amp;#x3D;&amp;#x3D;&lt;strong&gt;和&lt;/strong&gt;!&amp;#x3D;**等运算符&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#whether two strings are equal&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;puts &lt;span class=&quot;string&quot;&gt;&amp;quot;aaa&amp;quot;&lt;/span&gt; == &lt;span class=&quot;string&quot;&gt;&amp;quot;aab&amp;quot;&lt;/span&gt; 		&lt;span class=&quot;comment&quot;&gt;#=&amp;gt; false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;puts &lt;span class=&quot;string&quot;&gt;&amp;quot;aaa&amp;quot;&lt;/span&gt; != &lt;span class=&quot;string&quot;&gt;&amp;quot;aab&amp;quot;&lt;/span&gt;			&lt;span class=&quot;comment&quot;&gt;#=&amp;gt; true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果是判断两字符串是否相似，采用正则表达式匹配更加简单。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#whether two strings are similar&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;reg = &lt;span class=&quot;title class_&quot;&gt;Regexp&lt;/span&gt;.new(&lt;span class=&quot;string&quot;&gt;&amp;quot;^a+b$&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p &lt;span class=&quot;string&quot;&gt;&amp;quot;aaa&amp;quot;&lt;/span&gt; =~ reg 			&lt;span class=&quot;comment&quot;&gt;#=&amp;gt; nil (not similar)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p &lt;span class=&quot;string&quot;&gt;&amp;quot;ab&amp;quot;&lt;/span&gt; =~ reg 			&lt;span class=&quot;comment&quot;&gt;#=&amp;gt; 0 (similar)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p &lt;span class=&quot;string&quot;&gt;&amp;quot;aab&amp;quot;&lt;/span&gt; =~ reg 			&lt;span class=&quot;comment&quot;&gt;#=&amp;gt; 0 (similar)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p &lt;span class=&quot;string&quot;&gt;&amp;quot;acb&amp;quot;&lt;/span&gt; =~ reg 			&lt;span class=&quot;comment&quot;&gt;#=&amp;gt; nil (not similar)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Backend" scheme="https://stonefishy.github.io/categories/Backend/"/>
    
    
    <category term="Ruby" scheme="https://stonefishy.github.io/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Ruby修炼之道(14)</title>
    <link href="https://stonefishy.github.io/2015/11/12/ruby-practice-14/"/>
    <id>https://stonefishy.github.io/2015/11/12/ruby-practice-14/</id>
    <published>2015-11-12T09:09:35.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<h4 id="字符串的创建"><a href="#字符串的创建" class="headerlink" title="字符串的创建"></a>字符串的创建</h4><h5 id="普通创建"><a href="#普通创建" class="headerlink" title="普通创建"></a>普通创建</h5><p>Ruby中使用**” “<strong>或</strong>‘ ‘<strong>符号来创建字符串，在字符串中也可以包含表达式</strong>#{}**，这个表达式被称之为内嵌表达式。如果字符串中需要包含””或者’’等字符时，则可以通过转义字符\来实现。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;this is a string&quot;</span></span><br><span class="line">puts str</span><br><span class="line"></span><br><span class="line">str = <span class="string">&#x27;this is also a string&#x27;</span></span><br><span class="line">puts str</span><br><span class="line"></span><br><span class="line">args = <span class="string">&quot;string with argument&quot;</span></span><br><span class="line">puts <span class="string">&quot;this is a <span class="subst">#&#123;args&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">&quot;Hello &#x27;string&#x27;&quot;</span></span><br><span class="line">puts str</span><br><span class="line"></span><br><span class="line">str = <span class="string">&quot;Hello \&quot;string\&quot;&quot;</span></span><br><span class="line">puts str</span><br></pre></td></tr></table></figure><span id="more"></span><h5 id="Q或-q创建"><a href="#Q或-q创建" class="headerlink" title="%Q或%q创建"></a>%Q或%q创建</h5><p>针对字符串中包含””或’’等字符的，建议采用**%Q<strong>或者</strong>%q<strong>来创建字符串，这样更加清晰明了。使用</strong>%Q<strong>相当于</strong>“ “<strong>创建字符串，</strong>%q<strong>相当于</strong>‘ ‘**创建字符.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">puts <span class="string">%Q(this string created by %Q)</span></span><br><span class="line"></span><br><span class="line">puts <span class="string">%q(this string created by %q)</span></span><br><span class="line"></span><br><span class="line">puts <span class="string">%Q(contains &#x27;special&#x27; &quot;character&quot; directly)</span></span><br><span class="line"></span><br><span class="line">puts <span class="string">%q(contains &#x27;special&#x27; &quot;character&quot; directly)</span></span><br></pre></td></tr></table></figure><h5 id="Here-Document创建，"><a href="#Here-Document创建，" class="headerlink" title="Here Document创建，"></a>Here Document创建，</h5><p>对于字符串中包含换行符的字符串，使用Here Document语法来创建极为方便。Here Document是Unix中使用Shell的一种语法，通常用**&lt;&lt;**来创建字符串。其语法结构如下：</p><pre><code>&lt;&lt;&quot;结束标识符&quot;字符串内容结束标识符</code></pre><p><em>注意：结束标识符可以使用” “或’ ‘来定义，使用” “时，字符串内可以使用转义字符和内嵌表达式，而’ ‘则不会，只会原封不动的显示所有字符。</em>   </p><p>一般使用*EOF(End of File)<em>或</em>EOB(End of Block)*等作为结束标识符。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&lt;&lt;EOB</span></span><br><span class="line"><span class="string">the first string</span></span><br><span class="line"><span class="string">the second string in a new line</span></span><br><span class="line"><span class="string">ok, I also get the third string</span></span><br><span class="line"><span class="string">EOB</span></span><br><span class="line"></span><br><span class="line">print str<span class="comment">#=&gt;the string has three lines, just like defined.</span></span><br></pre></td></tr></table></figure><p>如果字符串中存在缩进，可以使用**&lt;&lt;-<strong>来替代</strong>&lt;&lt;**，这样将会保持字符串定义中的缩进。</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用 "></a>使用<code> </code></h5><p>通过使用<strong>`命令`</strong>, 可以创建命令的标准输出并将其转换为字符串对象。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">`ls -l`</span></span><br><span class="line"></span><br><span class="line">puts str </span><br><span class="line"><span class="comment">#=&gt; </span></span><br><span class="line">total <span class="number">8</span></span><br><span class="line">-rw-r--r--  <span class="number">1</span> yushi  staff  <span class="number">634</span> <span class="title class_">Nov</span> <span class="number">16</span> <span class="number">17</span><span class="symbol">:</span><span class="number">12</span> string_create.rb</span><br></pre></td></tr></table></figure><h5 id="使用printf和sprintf"><a href="#使用printf和sprintf" class="headerlink" title="使用printf和sprintf"></a>使用printf和sprintf</h5><p><strong>printf</strong>与<strong>sprintf</strong>均是可以输出指定格式的字符串，不同之处在于printf会将字符串直接输出在控制台上，而sprintf则会将字符串转为为字符串对象。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="number">123</span></span><br><span class="line">printf(<span class="string">&quot;%d\n&quot;</span>, number)<span class="comment">#=&gt; 123</span></span><br><span class="line">printf(<span class="string">&quot;%4d\n&quot;</span>, number)<span class="comment">#=&gt;  123</span></span><br><span class="line">printf(<span class="string">&quot;%04d\n&quot;</span>, number)    <span class="comment">#=&gt; 0123</span></span><br><span class="line">printf(<span class="string">&quot;%+d\n&quot;</span>, number)<span class="comment">#=&gt; +123</span></span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;Ruby&quot;</span></span><br><span class="line">p sprintf(<span class="string">&quot;Hello,%s&quot;</span>, name)<span class="comment">#=&gt; &quot;Hello,Ruby&quot;</span></span><br><span class="line">p sprintf(<span class="string">&quot;Hello,%8s&quot;</span>, name)<span class="comment">#=&gt; &quot;Hello,    Ruby&quot;</span></span><br><span class="line">p sprintf(<span class="string">&quot;Hello,%-8s&quot;</span>, name)<span class="comment">#=&gt; &quot;Hello,Ruby    &quot;</span></span><br></pre></td></tr></table></figure><h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><p>用<strong>length</strong>方法和<strong>size</strong>方法获取字符串长度。<strong>bytesize</strong>方法可以获取字节长度。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;This is a string&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;字符串&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#get the length of a string object</span></span><br><span class="line">puts str.length<span class="comment">#=&gt; 16</span></span><br><span class="line">puts str.size<span class="comment">#=&gt; 16</span></span><br><span class="line">puts str2.length<span class="comment">#=&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#get the bytesize of a string </span></span><br><span class="line">puts str.bytesize<span class="comment">#=&gt; 16</span></span><br><span class="line">puts str2.bytesize<span class="comment">#=&gt; 9</span></span><br></pre></td></tr></table></figure><p>判断字符串是否为空，可用**empty?**方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#judge the string if is empty</span></span><br><span class="line">puts <span class="string">&quot;&quot;</span>.empty?<span class="comment">#=&gt; true</span></span><br><span class="line">puts <span class="string">&quot;string&quot;</span>.empty?<span class="comment">#=&gt; false</span></span><br></pre></td></tr></table></figure><p><em>字符串的索引与数组的索引用法一样，可参照使用</em></p><h5 id="字符串的连接"><a href="#字符串的连接" class="headerlink" title="字符串的连接"></a>字符串的连接</h5><p>字符串的连接有以下两种情况：   </p><ul><li>将字符串合并为一个新的字符串   </li><li>扩展原有字符串</li></ul><p>使用**+**可以合并两个字符串时，会创建一个新的字符串。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#using &#x27;+&#x27;, will create a new string object</span></span><br><span class="line">str1 = <span class="string">&quot;hello &quot;</span></span><br><span class="line">str2 = <span class="string">&quot;world&quot;</span></span><br><span class="line">str3 = str1</span><br><span class="line"></span><br><span class="line">puts str1 + str2 <span class="comment">#=&gt; hello world</span></span><br><span class="line">puts str1<span class="comment">#=&gt; hello</span></span><br><span class="line"></span><br><span class="line">puts str1 = str1 + str2 <span class="comment">#=&gt; hello world</span></span><br><span class="line">puts str1<span class="comment">#=&gt; hello world</span></span><br><span class="line">puts str3<span class="comment">#=&gt; hello</span></span><br></pre></td></tr></table></figure><p>如果只想扩展原有字符串，可以使用**&lt;&lt;<strong>或</strong>concat**方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#using &#x27;&lt;&lt;&#x27;, will change the original string object</span></span><br><span class="line">str1 = <span class="string">&quot;hello &quot;</span></span><br><span class="line">str2 = <span class="string">&quot;world&quot;</span></span><br><span class="line">str3 = str1</span><br><span class="line"></span><br><span class="line">puts str1<span class="string">&lt;&lt;str2#=&gt; hello world</span></span><br><span class="line"><span class="string">puts str1#=&gt; hello world</span></span><br><span class="line"><span class="string">puts str3#=&gt; hello world</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#using &#x27;concat&#x27; method, also will change the original string object</span></span><br><span class="line"><span class="string">str1 = &quot;hello &quot;</span></span><br><span class="line"><span class="string">str2</span> = <span class="string">&quot;world&quot;</span></span><br><span class="line">str3 = str1</span><br><span class="line"></span><br><span class="line">puts str1.concat str2<span class="comment">#=&gt; hello world</span></span><br><span class="line">puts str1<span class="comment">#=&gt; hello world</span></span><br><span class="line">puts str3<span class="comment">#=&gt; hello world</span></span><br></pre></td></tr></table></figure><p><em>注意：一般情况下使用</em>*&lt;&lt;<strong>和</strong>concat*<em>方法更有效率，但是也可以根据情况而定</em></p>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;字符串的创建&quot;&gt;&lt;a href=&quot;#字符串的创建&quot; class=&quot;headerlink&quot; title=&quot;字符串的创建&quot;&gt;&lt;/a&gt;字符串的创建&lt;/h4&gt;&lt;h5 id=&quot;普通创建&quot;&gt;&lt;a href=&quot;#普通创建&quot; class=&quot;headerlink&quot; title=&quot;普通创建&quot;&gt;&lt;/a&gt;普通创建&lt;/h5&gt;&lt;p&gt;Ruby中使用**” “&lt;strong&gt;或&lt;/strong&gt;‘ ‘&lt;strong&gt;符号来创建字符串，在字符串中也可以包含表达式&lt;/strong&gt;#{}**，这个表达式被称之为内嵌表达式。如果字符串中需要包含””或者’’等字符时，则可以通过转义字符&#92;来实现。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;str = &lt;span class=&quot;string&quot;&gt;&amp;quot;this is a string&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;puts str&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str = &lt;span class=&quot;string&quot;&gt;&amp;#x27;this is also a string&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;puts str&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;args = &lt;span class=&quot;string&quot;&gt;&amp;quot;string with argument&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;puts &lt;span class=&quot;string&quot;&gt;&amp;quot;this is a &lt;span class=&quot;subst&quot;&gt;#&amp;#123;args&amp;#125;&lt;/span&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str = &lt;span class=&quot;string&quot;&gt;&amp;quot;Hello &amp;#x27;string&amp;#x27;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;puts str&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;str = &lt;span class=&quot;string&quot;&gt;&amp;quot;Hello &#92;&amp;quot;string&#92;&amp;quot;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;puts str&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Backend" scheme="https://stonefishy.github.io/categories/Backend/"/>
    
    
    <category term="Ruby" scheme="https://stonefishy.github.io/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>How to make the octopress adapt OS X EI Capitan</title>
    <link href="https://stonefishy.github.io/2015/11/11/how-to-make-the-octopress-adapt-os-x-ei-capitan/"/>
    <id>https://stonefishy.github.io/2015/11/11/how-to-make-the-octopress-adapt-os-x-ei-capitan/</id>
    <published>2015-11-11T14:46:35.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<p>Octopress was broken after I upgraded Mac to OS X EI Capitan 10.11.1 in these days. The details of the problem is below.</p><p>Octopress is work well in Mac10.10. but when I upgraded to Mac10.11.1(OS X EI Capitan). And put <em>rake preview</em> in terminal to see the blog what looks like, got following error.</p><pre><code>Starting to watch source with Jekyll and Compass. Starting Rack on port 4000rake aborted!Errno::ENOENT: No such file or directory - compass/Users/user/git/octopress/Rakefile:85:in spawn/Users/user/git/octopress/Rakefile:85:in block in &lt;top (required)&gt;Tasks: TOP =&gt; preview(See full trace by running task with --trace)</code></pre><span id="more"></span><p>Why we get this error, this error caused by rake command, so that means maybe it is ruby version problem. let’s take a look it.</p><pre><code>~-&gt; $ ruby -v~-&gt; ruby 2.0.0p645 (2015-04-13 revision 50299) [universal.x86_64-darwin15]</code></pre><p>The ruby newest version is 2.2.3. Ok, let’s upgrade it. There are two ways to do it.</p><h4 id="Using-rbenv"><a href="#Using-rbenv" class="headerlink" title="Using rbenv"></a>Using rbenv</h4><p>If you don’t have rbenv in your local machine. You need to install it firstly.<br>1.Go to <a href="https://github.com/sstephenson/rbenv">https://github.com/sstephenson/rbenv</a> to get it.<br>2.install ruby-2.2.3</p><pre><code>rbenv install 2.2.3</code></pre><p>3.In the root of your octopress blog, put below commands</p><pre><code>rbenv local 2.2.3gem install bundlerbundle install</code></pre><h4 id="Using-RVM"><a href="#Using-RVM" class="headerlink" title="Using RVM"></a>Using RVM</h4><p>1.Clear git cache</p><pre><code>rm -rf /usr/local/.git</code></pre><p>2.Install RVM</p><pre><code>curl -L https://get.rvm.io | bash -s stable --ruby</code></pre><p>3.Install Ruby 2.2.3</p><pre><code>rvm install ruby-2.2.3rvm use 2.2.3rvm rubygems latest</code></pre><p>After these steps, make sure you’re using Ruby 2.2.3<br>4.Go to the root of the your octopress blog</p><pre><code>gem install bundlerbundle install</code></pre><p>Both ways can bring octopress back.</p><p><em>Reference: <a href="https://github.com/imathis/octopress/issues/1749">https://github.com/imathis/octopress/issues/1749</a></em></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Octopress was broken after I upgraded Mac to OS X EI Capitan 10.11.1 in these days. The details of the problem is below.&lt;/p&gt;
&lt;p&gt;Octopress is work well in Mac10.10. but when I upgraded to Mac10.11.1(OS X EI Capitan). And put &lt;em&gt;rake preview&lt;/em&gt; in terminal to see the blog what looks like, got following error.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Starting to watch source with Jekyll and Compass. Starting Rack on port 4000
rake aborted!
Errno::ENOENT: No such file or directory - compass
/Users/user/git/octopress/Rakefile:85:in spawn
/Users/user/git/octopress/Rakefile:85:in block in &amp;lt;top (required)&amp;gt;
Tasks: TOP =&amp;gt; preview
(See full trace by running task with --trace)
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="Backend" scheme="https://stonefishy.github.io/categories/Backend/"/>
    
    
    <category term="Tool" scheme="https://stonefishy.github.io/tags/Tool/"/>
    
    <category term="Ruby" scheme="https://stonefishy.github.io/tags/Ruby/"/>
    
    <category term="MacOS" scheme="https://stonefishy.github.io/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>Ruby修炼之道(13)</title>
    <link href="https://stonefishy.github.io/2015/10/26/ruby-practice-13/"/>
    <id>https://stonefishy.github.io/2015/10/26/ruby-practice-13/</id>
    <published>2015-10-26T14:13:32.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<h4 id="替换数组内的元素"><a href="#替换数组内的元素" class="headerlink" title="替换数组内的元素"></a>替换数组内的元素</h4><p>根据指定规则替换数组中的元素，Ruby也提供了以下方法:</p><p>ary.<strong>collect</strong> { |item| …}<br>ary.<strong>collect!</strong> { |item| …}<br>ary.<strong>map</strong> { |item| …}<br>ary.<strong>map!</strong> { |item| …}   </p><p>将数组ary中的各元素item传递给块做处理。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ary1 = ary.collect <span class="keyword">do</span> |<span class="params">item</span>|</span><br><span class="line">    item*<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p ary1<span class="comment">#=&gt; [ 2, 4, 6]</span></span><br><span class="line"></span><br><span class="line">ary2 = ary.map <span class="keyword">do</span> |<span class="params">item</span>|</span><br><span class="line">    <span class="keyword">if</span> item % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p ary2<span class="comment">#=&gt; [1, 0, 1]</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>ary.<strong>fill</strong>(value)<br>ary.<strong>fill</strong>(value, begin)<br>ary.<strong>fill</strong>(value, begin, len)<br>ary.<strong>fill</strong>(vlaue, n..m)<br>将数组ary的元素替换为value。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].fill(<span class="number">0</span>)<span class="comment">#=&gt; [0, 0, 0]</span></span><br><span class="line">p [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].fill(<span class="number">0</span>, <span class="number">1</span>)<span class="comment">#=&gt; [1, 0, 0]</span></span><br><span class="line">p [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].fill(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>)<span class="comment">#=&gt; [0, 0 ,3]</span></span><br><span class="line">p [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].fill(<span class="number">0</span>, <span class="number">1</span>..<span class="number">2</span>)<span class="comment">#=&gt; [1, 0, 0]</span></span><br><span class="line"></span><br><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ary.fill(<span class="number">0</span>)</span><br><span class="line">p ary<span class="comment">#=&gt; [0, 0, 0]</span></span><br></pre></td></tr></table></figure><p>*注意，此方法会修改原对象的值。即为破坏方法。</p><p>ary.<strong>flatten</strong><br>ary.<strong>flatten</strong><br>平坦化数组ary，所谓平坦化是指展开嵌套数组变为一个大数组。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]]</span><br><span class="line">p ary.flatten  <span class="comment">#=&gt; [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>ary.<strong>reverse</strong><br>ary.<strong>reverse!</strong><br>反转数组ary的元素顺序</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">p ary.reverse<span class="comment">#=&gt; [3, 2, 1]</span></span><br></pre></td></tr></table></figure><p>ary.<strong>sort</strong><br>ary.<strong>sort!</strong><br>ary.<strong>sort</strong>{|i, j| … }<br>ary.<strong>sort!</strong>{|i, j| …}<br>ary.<strong>sort_by</strong> {|i| …}   </p><p>对数组ary中进行排序，排序方法可以由块指定。没有块时，使用*&lt;&#x3D;&gt;*运算符比较。其中<strong>sort_by</strong>方法中排序是根据块的运行结果来对数组的所有元素进行排序。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>]</span><br><span class="line">p ary.sort<span class="comment">#=&gt; [4, 5, 9]</span></span><br><span class="line">ary.sort! &#123; |<span class="params">i, j</span>|</span><br><span class="line">i % <span class="number">3</span> &lt;=&gt; j % <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">p ary <span class="comment">#=&gt; [9, 4, 5]</span></span><br><span class="line"></span><br><span class="line">p [<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>].sort_by &#123; |<span class="params">i</span>| -i &#125;  <span class="comment">#=&gt; [4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure><h4 id="数组的迭代"><a href="#数组的迭代" class="headerlink" title="数组的迭代"></a>数组的迭代</h4><p><strong>each</strong>方法并不知道元素的索引值。当需要指定索引值时，可以使用<strong>each_with_index</strong>方法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">23</span>, <span class="number">54</span>, <span class="number">14</span>]</span><br><span class="line">ary.each &#123; |<span class="params">item</span>| print <span class="string">&quot;<span class="subst">#&#123;item&#125;</span> &quot;</span> &#125;<span class="comment">#=&gt; 23 54 14</span></span><br><span class="line"></span><br><span class="line">ary.each_with_index <span class="keyword">do</span> |<span class="params">item, index</span>|</span><br><span class="line">print <span class="string">&quot;The &quot;</span>, index+<span class="number">1</span>, <span class="string">&quot; element is :&quot;</span>, item, <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果数组内各元素全部处理完毕后该数组就不需要了，此时可以通过逐个删除数组元素使数组变空这样的手段来实现循环。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> item = ary.pop</span><br><span class="line"><span class="comment">## the handle of the item</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>数组中的各个元素也可以是数组，也就是数组的数组。可以用它来表示矩阵。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ary = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line">p ary[<span class="number">1</span>][<span class="number">1</span>]<span class="comment">#=&gt; 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3个元素引用的是同一个数组对象</span></span><br><span class="line">ary = <span class="title class_">Array</span>.new(<span class="number">3</span>, [<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">ary[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">p ary  <span class="comment">#=&gt; [[0, 1], [0, 1], [0, 1]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#避免引用同一个数组对象，在块中，重复创建新的对象</span></span><br><span class="line">ary = <span class="title class_">Array</span>.new(<span class="number">3</span>) <span class="keyword">do</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ary[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">p ary  <span class="comment">#=&gt; [[0, 1], [0, 0], [0, 0]]</span></span><br></pre></td></tr></table></figure><p>使用*Array.new(length, array)*创建二维数组。创建的所有元素引用的都是同一个对象array，修改其中一个元素的值，其他元素也会变化。如上示例代码。如何避免？可在创建数组的块中重复创建新对象。</p><p>ary.<strong>zip</strong>(ary1, ary2, …)<br><strong>zip</strong>方法会将接收器和参数传来的数组元素逐一取出，而且每次都会启动块。参数可以是一个或多个。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ary1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ary2 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">ary3 = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"></span><br><span class="line">result = []</span><br><span class="line">ary1.zip(ary2, ary3) <span class="keyword">do</span> |<span class="params">a, b, c</span>|</span><br><span class="line">result &lt;&lt; a + b + c</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p result<span class="comment">#=&gt; [111, 222, 333]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;替换数组内的元素&quot;&gt;&lt;a href=&quot;#替换数组内的元素&quot; class=&quot;headerlink&quot; title=&quot;替换数组内的元素&quot;&gt;&lt;/a&gt;替换数组内的元素&lt;/h4&gt;&lt;p&gt;根据指定规则替换数组中的元素，Ruby也提供了以下方法:&lt;/p&gt;
&lt;p&gt;ary.&lt;strong&gt;collect&lt;/strong&gt; { |item| …}&lt;br&gt;ary.&lt;strong&gt;collect!&lt;/strong&gt; { |item| …}&lt;br&gt;ary.&lt;strong&gt;map&lt;/strong&gt; { |item| …}&lt;br&gt;ary.&lt;strong&gt;map!&lt;/strong&gt; { |item| …}   &lt;/p&gt;
&lt;p&gt;将数组ary中的各元素item传递给块做处理。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ary = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ary1 = ary.collect &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |&lt;span class=&quot;params&quot;&gt;item&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    item*&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p ary1					&lt;span class=&quot;comment&quot;&gt;#=&amp;gt; [ 2, 4, 6]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ary2 = ary.map &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |&lt;span class=&quot;params&quot;&gt;item&lt;/span&gt;|&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; item % &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p ary2					&lt;span class=&quot;comment&quot;&gt;#=&amp;gt; [1, 0, 1]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Backend" scheme="https://stonefishy.github.io/categories/Backend/"/>
    
    
    <category term="Ruby" scheme="https://stonefishy.github.io/tags/Ruby/"/>
    
  </entry>
  
  <entry>
    <title>Ruby修炼之道(12)</title>
    <link href="https://stonefishy.github.io/2015/10/13/ruby-practice-12/"/>
    <id>https://stonefishy.github.io/2015/10/13/ruby-practice-12/</id>
    <published>2015-10-13T02:25:41.000Z</published>
    <updated>2023-09-03T08:07:31.121Z</updated>
    
    <content type="html"><![CDATA[<p>数组(<strong>Array</strong>)也是Ruby中表现一组数据的对象</p><h4 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h4><p>创建方式有一下几种：<br>1.使用<strong>Array.new</strong><br>Array#new方法可带两个可选参数，第1个参数表示数组中得个数，第2个参数表示每个元素初始值。如果没有指定第2个参数，其元素的初始值为<strong>nil</strong>。如果不带参数则会创建一个空数组。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不带参数c</span></span><br><span class="line">ary = <span class="title class_">Array</span>.new</span><br><span class="line">p ary<span class="comment">#=&gt; []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#带1个参数</span></span><br><span class="line">ary = <span class="title class_">Array</span>.new(<span class="number">3</span>)</span><br><span class="line">p ary<span class="comment">#=&gt; [nil, nil, nil]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#带2个参数</span></span><br><span class="line">ary = <span class="title class_">Array</span>.new(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">p ary<span class="comment">#=&gt; [5, 5, 5]</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>2.使用**%w<strong>与</strong>%i**<br><strong>%w</strong>用于创建不包含空白的字符串数组, 使用此方法创建字符串数组更加简洁。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">%w(This is ruby)</span><span class="comment">#=&gt; [&quot;This&quot;, &quot;is&quot;, &quot;ruby&quot;]</span></span><br></pre></td></tr></table></figure><p><strong>%i</strong>用于创建符号(Symbol)数组。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%i(<span class="title class_">This</span> is ruby) <span class="comment">#=&gt; [:This, :is, :ruby]</span></span><br></pre></td></tr></table></figure><p>使用**%w<strong>和</strong>%i<strong>创建数组时用到了(). 其实还可以用很多字符来替代，不过建议使用</strong>()<strong>,</strong>&lt;&gt;<strong>,</strong>||**.</p><p>3.使用<strong>to_a</strong>方法</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash=&#123;<span class="symbol">name:</span> <span class="string">&quot;yu&quot;</span>, <span class="symbol">gender:</span> <span class="string">&quot;male&quot;</span>&#125;<span class="comment">#=&gt; &#123;:name=&gt;&quot;yu&quot;, :gender=&gt;&quot;male&quot;&#125;</span></span><br><span class="line">hash.to_a<span class="comment">#=&gt; [[:name, &quot;yu&quot;], [:gender, &quot;male&quot;]]</span></span><br></pre></td></tr></table></figure><p>4.使用<strong>split</strong>方法<br>对逗号或空白字符间隔的字符串可以使用split方法来创建数组</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;this is ruby&quot;</span>.split()<span class="comment">#=&gt; [&quot;this&quot;, &quot;is&quot;, &quot;ruby&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h4><p>获取元素的方法有以下几种：   </p><p>1.使用**[]**<br>(a) <strong>ary[n]</strong>, 获取索引值为n的元素，当索引值为负数时，从数组的末尾开始获取元素。如果指定的索引值大于元素个数则返回nil。 </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">ary[<span class="number">1</span>]<span class="comment">#=&gt; 2</span></span><br><span class="line">ary[-<span class="number">1</span>]<span class="comment">#=&gt; 5</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(b) **ary[n..m]**, 获取从a[n]到a[m]的元素，并返回新的数组。如果m大于数组的长度，返回的结果与指定数组最后一个元素是一样的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> ruby</span><br><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">ary[<span class="number">1</span>..<span class="number">3</span>]<span class="comment">#=&gt; [2, 3, 4]</span></span><br><span class="line">ary[<span class="number">1</span>..<span class="number">7</span>]<span class="comment">#=&gt; [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>(c) <strong>ary[n…m]</strong>, 获取从a[n]到a[m-1]的元素，并返回新数组    </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">ary[<span class="number">1</span>...<span class="number">3</span>]<span class="comment">#=&gt; [2, 3]</span></span><br><span class="line">ary[<span class="number">1</span>...<span class="number">7</span>]<span class="comment">#=&gt; [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>(d) <strong>ary[n, len]</strong>, 获取从a[n]开始之后的len个元素，并返回新数组. 如果len的长度大于从n开始后数组的剩余长度，则返回的结果与指定数组最后一个元素是一样的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">ary[<span class="number">1</span>, <span class="number">3</span>]<span class="comment">#=&gt; [2, 3, 4]</span></span><br><span class="line">ary[<span class="number">2</span>, <span class="number">7</span>]<span class="comment">#=&gt; [3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>2.使用<strong>at</strong>方法<br>ary.at(n)与ary[n]等价    </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">ary.at(<span class="number">1</span>)<span class="comment">#=&gt; 2</span></span><br><span class="line">ary[<span class="number">1</span>]<span class="comment">#=&gt; 2</span></span><br></pre></td></tr></table></figure><p>3.使用<strong>slice</strong>方法<br>ary.slice(n..m)与ary[n..m]等价，ary.slice(n…m)与ary[n…m]等价，ary.slice(n, len)与ary[n, len]等价   </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">ary.slice(<span class="number">1</span>..<span class="number">3</span>)<span class="comment">#=&gt; [2, 3, 4]</span></span><br><span class="line">ary.slice(<span class="number">1</span>...<span class="number">3</span>)<span class="comment">#=&gt; [2, 3]</span></span><br><span class="line">ary.slice(<span class="number">1</span>, <span class="number">3</span>)<span class="comment">#=&gt; [2, 3, 4]</span></span><br></pre></td></tr></table></figure><p>4.使用<strong>values_at</strong>方法<br>可以通过此方法来获取多个索引的元素, 其用法如下</p><pre><code>ary.values_at(n1, n2, ...)</code></pre><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">ary.values_at(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>)<span class="comment">#=&gt; [1, 3, 5]</span></span><br><span class="line">ary.values_at(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>)<span class="comment">#=&gt; [2, 4, nil]</span></span><br></pre></td></tr></table></figure><h4 id="元素赋值"><a href="#元素赋值" class="headerlink" title="元素赋值"></a>元素赋值</h4><p>使用[],at,slice方法还可以给元素赋值</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">ary[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span><span class="comment">#=&gt; [&quot;a&quot;, 2, 3, 4, 5]</span></span><br><span class="line">ary[<span class="number">1</span>...<span class="number">3</span>] = [<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>]<span class="comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 4, 5]</span></span><br><span class="line">ary[<span class="number">3</span>..<span class="number">3</span>] = <span class="string">&quot;d&quot;</span><span class="comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 5]</span></span><br><span class="line">ary[<span class="number">4</span>, <span class="number">1</span>] = <span class="string">&quot;e&quot;</span><span class="comment">#=&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="元素插入"><a href="#元素插入" class="headerlink" title="元素插入"></a>元素插入</h4><p>插入元素其实就是对0个元素进行赋值，因此指定[n, 0]后，就会在索引值为n的元素前插入新元素。   </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">ary[<span class="number">2</span>, <span class="number">0</span>] = <span class="number">10</span><span class="comment">#=&gt; [1, 2, 10, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><h4 id="数组作为集合使用"><a href="#数组作为集合使用" class="headerlink" title="数组作为集合使用"></a>数组作为集合使用</h4><p>交集：取出同时属于两个集合的元素，并创建新的集合</p><pre><code>ary = ary1 &amp; ary2</code></pre><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ary1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ary2 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">ary = ary1 &amp; ary2<span class="comment">#=&gt; [1, 3]</span></span><br></pre></td></tr></table></figure><p>并集：取出两个集合中的所有元素，并创建新的集合</p><pre><code>ary = ary1 | ary2</code></pre><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ary1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ary2 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">ary = ary1 |<span class="params"> ary2#=&gt; [1, 2, 3, 5]</span></span><br></pre></td></tr></table></figure><p>集合的差：把某个集合中属于另外一个集合的元素删除，并创建新的集合</p><pre><code>ary = ary1 - ary2</code></pre><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ary1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ary2 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">ary = ary1 - ary2<span class="comment">#=&gt; [2]</span></span><br></pre></td></tr></table></figure><p><em>注意：连接数组除了可以使用</em>*|<strong>外还可以使用</strong>+*<em>。但是这两种方法返回的结果是不一样的。即使用|相同的元素只有一个，使用+相同的元素会重复存在</em></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ary1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ary2 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">ary = ary1 |<span class="params"> ary2#=&gt; [1, 2, 3, 5]</span></span><br><span class="line"><span class="params">ary = ary1 + ary2#=&gt; [1, 2, 3, 1, 3, 5]</span></span><br></pre></td></tr></table></figure><h4 id="数组作为队列和栈"><a href="#数组作为队列和栈" class="headerlink" title="数组作为队列和栈"></a>数组作为队列和栈</h4><table><thead><tr><th></th><th align="right">对数组开始元素的操作</th><th>对数组末尾元素的操作</th></tr></thead><tbody><tr><td>追加元素</td><td align="right">unshift</td><td>push</td></tr><tr><td>删除元素</td><td align="right">shift</td><td>pop</td></tr><tr><td>引用元素</td><td align="right">first</td><td>last</td></tr></tbody></table><p>使用<strong>push</strong>方法和<strong>shift</strong>方法可以实现队列。使用<strong>push</strong>方法和<strong>pop</strong>方法可以实现栈。</p><p><strong>shift</strong>方法和<strong>pop</strong>方法不只是获取数组元素，还会把该元素从数组中删除。如果只是想单纯地引用元素，应该是用<br><strong>first</strong>和<strong>last</strong>方法。</p><p>1.ary.<strong>unshift</strong>(item)<br>将item元素添加到数组的开头   </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ary.unshift(<span class="number">0</span>)<span class="comment">#=&gt; [0, 1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>2.ary.<strong>push</strong>(item), ary <strong>&lt;&lt;</strong> item<br><strong>&lt;&lt;<strong>与</strong>push</strong>是等价的方法，在数组的末尾添加新元素item   </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ary.push(<span class="number">4</span>)<span class="comment">#=&gt; [1, 2, 3, 4]</span></span><br><span class="line">ary &lt;&lt; <span class="number">5</span><span class="comment">#=&gt; [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>3.ary1.<strong>concat</strong>(ary2)<br>连接数组ary1和数组ary2. concat是具有破坏性的方法。会将ary2的元素直接插入到ary1数组的后面。**+**也是连接两个数组的方法，但是不具破坏性，会生成新的数组。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ary1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ary2 = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">ary1.concat(ary2)</span><br><span class="line">p ary1<span class="comment">#=&gt; [1, 2, 3, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p><em>注：能够改变对象值的方法称为具有破坏性的方法，比如pop方法、shift方法等。有些方法后面加上</em>*!*<em>的也是破坏性方法</em></p><p>4.ary.<strong>compact</strong> 与ary.<strong>compact!</strong><br>从数组ary中删除所有nil元素     </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="literal">nil</span>, <span class="number">1</span>, <span class="literal">nil</span>, <span class="number">2</span>]</span><br><span class="line">ary.compact<span class="comment">#=&gt; [1, 2]</span></span><br></pre></td></tr></table></figure><p>5.ary.<strong>delete</strong>(item)和ary.<strong>delete_at</strong>(n)<br>从数组a中删除item元素。 第2个方法删除ary[n]元素。   </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ary.delete(<span class="number">2</span>)</span><br><span class="line">p ary<span class="comment">#=&gt; [1, 3]</span></span><br><span class="line">ary.delete_at(<span class="number">0</span>)</span><br><span class="line">p ary<span class="comment">#=&gt; [3]</span></span><br></pre></td></tr></table></figure><p>6.ary.<strong>delete_if</strong>{ |item| …}<br>ary.<strong>reject</strong>{ |item| …}<br>ary.<strong>reject!</strong>{ |item| ..}    </p><p>判断数组ary中的各元素item，如果块的执行结果为真，则从数组ary中删除item。<strong>delete_if</strong>和**reject!**方法都是具有破坏性的方法。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ary.delete_if &#123; |<span class="params">item</span>| item &gt; <span class="number">2</span>&#125;</span><br><span class="line">p ary<span class="comment">#=&gt; [1, 2]</span></span><br><span class="line">ary.reject! &#123; |<span class="params">item</span>| item &lt; <span class="number">2</span>&#125;</span><br><span class="line">p ary<span class="comment">#=&gt; [2]</span></span><br></pre></td></tr></table></figure><p>7.ary.<strong>slice</strong>(n)<br>ary.<strong>slice</strong>(n..m)<br>ary.<strong>slice!</strong>(n, len)<br>删除数组ary中指定的部分，并返回删除部分的值。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">p ary.slice!(<span class="number">4</span>)<span class="comment">#=&gt; 5</span></span><br><span class="line">p ary.slice!(<span class="number">2</span>..<span class="number">3</span>)<span class="comment">#=&gt; [3, 4]</span></span><br><span class="line">p ary.slice(<span class="number">1</span>, <span class="number">1</span>)<span class="comment">#=&gt; [2]</span></span><br></pre></td></tr></table></figure><p>8.ary.<strong>uniq</strong>, ary.**uniq!**删除数组ary中重复的元素。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">ary.uniq<span class="comment">#=&gt; [1, 2,3]</span></span><br></pre></td></tr></table></figure><p>9.ary.<strong>shift</strong>. 删除数组ary开头的元素，并返回删除的值。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]j</span><br><span class="line">ary.shift<span class="comment">#=&gt; 1</span></span><br><span class="line">p ary<span class="comment">#=&gt; [2, 3]</span></span><br></pre></td></tr></table></figure><p>10.ary.<strong>pop</strong>. 删除数组ary末尾的元素，并返回删除的值。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">ary.pop<span class="comment">#=&gt; 3</span></span><br><span class="line">p ary<span class="comment">#=&gt; [1, 2]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;数组(&lt;strong&gt;Array&lt;/strong&gt;)也是Ruby中表现一组数据的对象&lt;/p&gt;
&lt;h4 id=&quot;数组的创建&quot;&gt;&lt;a href=&quot;#数组的创建&quot; class=&quot;headerlink&quot; title=&quot;数组的创建&quot;&gt;&lt;/a&gt;数组的创建&lt;/h4&gt;&lt;p&gt;创建方式有一下几种：&lt;br&gt;1.使用&lt;strong&gt;Array.new&lt;/strong&gt;&lt;br&gt;Array#new方法可带两个可选参数，第1个参数表示数组中得个数，第2个参数表示每个元素初始值。如果没有指定第2个参数，其元素的初始值为&lt;strong&gt;nil&lt;/strong&gt;。如果不带参数则会创建一个空数组。&lt;/p&gt;
&lt;figure class=&quot;highlight ruby&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#不带参数c&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ary = &lt;span class=&quot;title class_&quot;&gt;Array&lt;/span&gt;.new&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p ary					&lt;span class=&quot;comment&quot;&gt;#=&amp;gt; []&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#带1个参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ary = &lt;span class=&quot;title class_&quot;&gt;Array&lt;/span&gt;.new(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p ary					&lt;span class=&quot;comment&quot;&gt;#=&amp;gt; [nil, nil, nil]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#带2个参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ary = &lt;span class=&quot;title class_&quot;&gt;Array&lt;/span&gt;.new(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p ary					&lt;span class=&quot;comment&quot;&gt;#=&amp;gt; [5, 5, 5]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Backend" scheme="https://stonefishy.github.io/categories/Backend/"/>
    
    
    <category term="Ruby" scheme="https://stonefishy.github.io/tags/Ruby/"/>
    
  </entry>
  
</feed>
