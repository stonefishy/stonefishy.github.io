<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Git | Stonefishy Blog]]></title>
  <link href="http://stonefishy.github.io/blog/categories/git/atom.xml" rel="self"/>
  <link href="http://stonefishy.github.io/"/>
  <updated>2014-12-03T00:31:39+08:00</updated>
  <id>http://stonefishy.github.io/</id>
  <author>
    <name><![CDATA[Yu SHI]]></name>
    <email><![CDATA[andrewsy@live.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Visual Git Guide (Technical Notes)]]></title>
    <link href="http://stonefishy.github.io/blog/2014/11/07/visual-git-guide-technical-notes/"/>
    <updated>2014-11-07T00:00:00+08:00</updated>
    <id>http://stonefishy.github.io/blog/2014/11/07/visual-git-guide-technical-notes</id>
    <content type="html"><![CDATA[<p><strong>Note:</strong> the original website address in <a href="http://marklodato.github.io/visual-git-guide/index-en.html?no-svg">here</a></p>

<h3>Technical notes</h3>

<p>The contents of files are not actually stored in the index (.git/index) or in commit objects. Rather, each file is stored in the object database (.git/objects) as a blob, identified by its SHA-1 hash. The index file lists the filenames along with the identifier of the associated blob, as well as some other data. For commits, there is an additional data type, a tree, also identified by its hash. Trees correspond to directories in the working directory, and contain a list of trees and blobs corresponding to each filename within that directory. Each commit stores the identifier of its top-level tree, which in turn contains all of the blobs and other trees associated with that commit.</p>

<!--more-->


<p>If you make a commit using a detached HEAD, the last commit really is referenced by something: the reflog for HEAD. However, this will expire after a while, so the commit will eventually be garbage collected, similar to commits discarded with <code>git commit --amend</code> or <code>git rebase</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visual Git Guide (Reset Command)]]></title>
    <link href="http://stonefishy.github.io/blog/2014/11/07/visual-git-guide-reset-command/"/>
    <updated>2014-11-07T00:00:00+08:00</updated>
    <id>http://stonefishy.github.io/blog/2014/11/07/visual-git-guide-reset-command</id>
    <content type="html"><![CDATA[<p><strong>Note:</strong> the original website address in <a href="http://marklodato.github.io/visual-git-guide/index-en.html?no-svg">here</a></p>

<h3>Reset command</h3>

<p><strong>The reset command moves the current branch to another position</strong>, and optionally updates the stage and the working directory. It also is used to copy files from the history to the stage without touching the working directory.</p>

<p>If a commit is given with no filenames, the current branch is moved to that commit, and then the stage is updated to match this commit. If &ndash;hard is given, the working directory is also updated. If &ndash;soft is given, neither is updated.</p>

<!--more-->


<p></p>

<p><img src="/assets/images/reset-commit.png" alt="reset-commit" /></p>

<p>If a commit is not given, it defaults to HEAD. In this case, the branch is not moved, but the stage (and optionally the working directory, if &ndash;hard is given) are reset to the contents of the last commit.</p>

<p><img src="/assets/images/reset.png" alt="reset" /></p>

<p>If a filename (and/or -p) is given, then the command works similarly to checkout with a filename, except only the stage (and not the working directory) is updated. (You may also specify the commit from which to take files, rather than HEAD.)</p>

<p><img src="/assets/images/reset-files.png" alt="reset-files" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visual Git Guide (Rebase Command)]]></title>
    <link href="http://stonefishy.github.io/blog/2014/11/07/visual-git-guide-rebase-command/"/>
    <updated>2014-11-07T00:00:00+08:00</updated>
    <id>http://stonefishy.github.io/blog/2014/11/07/visual-git-guide-rebase-command</id>
    <content type="html"><![CDATA[<p><strong>Note:</strong> the original website address in <a href="http://marklodato.github.io/visual-git-guide/index-en.html?no-svg">here</a></p>

<h3>Rebase command</h3>

<p>A rebase is an alternative to a merge for combining multiple branches. Whereas a merge creates a single commit with two parents, leaving a non-linear history, a rebase replays the commits from the current branch onto another, leaving a linear history. <em>In essence, this is an automated way of performing several cherry-picks in a row</em>.</p>

<!--more-->


<p><img src="/assets/images/rebase.png" alt="rebase" /></p>

<p>The above command takes all the commits that exist in topic but not in master (namely 169a6 and 2c33a), replays them onto master, and then moves the branch head to the new tip. Note that the old commits will be garbage collected if they are no longer referenced.</p>

<p>To limit how far back to go, use the &ndash;onto option. The following command replays onto master the most recent commits on the current branch since 169a6 (exclusive), namely 2c33a.</p>

<p><img src="/assets/images/rebase-onto.png" alt="rebase-onto" /></p>

<p>There is also <code>git rebase --interactive</code>, which allows one to do more complicated things than simply replaying commits, namely dropping, reordering, modifying, and squashing commits. There is no obvious picture to draw for this; see git-rebase(1) for more details.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visual Git Guide (Merge Command)]]></title>
    <link href="http://stonefishy.github.io/blog/2014/11/07/visual-git-guide-merge-command/"/>
    <updated>2014-11-07T00:00:00+08:00</updated>
    <id>http://stonefishy.github.io/blog/2014/11/07/visual-git-guide-merge-command</id>
    <content type="html"><![CDATA[<p><strong>Note:</strong> the original website address in <a href="http://marklodato.github.io/visual-git-guide/index-en.html?no-svg">here</a></p>

<h3>Merge command</h3>

<p>A merge creates a new commit that incorporates changes from other commits. Before merging, the stage must match the current commit. The trivial case is if the other commit is an ancestor of the current commit, in which case nothing is done. The next most simple is if the current commit is an ancestor of the other commit. This results in a fast-forward merge. The reference is simply moved, and then the new commit is checked out.</p>

<!--more-->


<p></p>

<p><img src="/assets/images/merge-ff.png" alt="merge-ff" /></p>

<p>Otherwise, a &ldquo;real&rdquo; merge must occur. You can choose other strategies, but the default is to perform a &ldquo;recursive&rdquo; merge, which basically takes the current commit (ed489 below), the other commit (33104), and their common ancestor (b325c), and performs a three-way merge. The result is saved to the working directory and the stage, and then a commit occurs, with an extra parent (33104) for the new commit.</p>

<p><img src="/assets/images/merge.png" alt="merge" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visual Git Guide (Diff Command)]]></title>
    <link href="http://stonefishy.github.io/blog/2014/11/07/visual-git-guide-diff-command/"/>
    <updated>2014-11-07T00:00:00+08:00</updated>
    <id>http://stonefishy.github.io/blog/2014/11/07/visual-git-guide-diff-command</id>
    <content type="html"><![CDATA[<p><strong>Note:</strong> the original website address is <a href="http://marklodato.github.io/visual-git-guide/index-en.html?no-svg">here</a></p>

<h3>Diff Command</h3>

<p>There are various ways to look at differences between commits. Below are some common examples. Any of these commands can optionally take extra filename arguments that limit the differences to the named files.</p>

<!--more-->


<p></p>

<p><img src="/assets/images/diff.png" alt="diff" /></p>
]]></content>
  </entry>
  
</feed>
