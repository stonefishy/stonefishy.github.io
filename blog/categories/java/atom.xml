<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Stonefishy Blog]]></title>
  <link href="http://stonefishy.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://stonefishy.github.io/"/>
  <updated>2015-06-12T18:35:08+08:00</updated>
  <id>http://stonefishy.github.io/</id>
  <author>
    <name><![CDATA[Yu]]></name>
    <email><![CDATA[andrewsy@live.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Dynamic Pointcut]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/12/spring-aop-dynamic-pointcut/"/>
    <updated>2015-06-12T16:23:30+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/12/spring-aop-dynamic-pointcut</id>
    <content type="html"><![CDATA[<p>If we want to intercept methods with dynamic pointcut, we need to override <em>matches</em> and <em>getClassFilter</em> methods of <strong>DynamicMethodMatcher</strong> abstract class. The dynamic pointcut can verify the arguments of the method at runtime. This is a difference with static pointcut.</p>

<!-- more -->


<pre><code class="java MyDynamicPointcut.java">package spring.test.aop;

import java.lang.reflect.Method;

import org.springframework.aop.ClassFilter;
import org.springframework.aop.support.DynamicMethodMatcherPointcut;

public class MyDynamicPointcut extends DynamicMethodMatcherPointcut {

    @Override
    public boolean matches(Method method, Class&lt;?&gt; targetClass, Object[] args) {
        System.out.println("Dynamic check for " + method.getName());

        if (args.length &gt; 0 &amp;&amp; (int) args[0] &gt; 10)
            return true;

        return false;
    }

    @Override
    public ClassFilter getClassFilter() {
        return new ClassFilter() {

            @Override
            public boolean matches(Class&lt;?&gt; clazz) {
                return clazz.equals(MyLogicClass.class);
            }

        };
    }

}
</code></pre>

<p>In above dynamic pointcut class, we verify the class name must be <em>MyLogicClass</em> and the value of the first argument in method must larger than 10, otherwise the method will not be intercepted.</p>

<pre><code class="java MyAroundAdvice.java">package spring.test.aop;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class MyAroundAdvice implements MethodInterceptor {

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("&gt;&gt;&gt;&gt;&gt;&gt; Invoking method "
                + invocation.getMethod().getName());

        Object result = invocation.proceed();

        System.out.println("&gt;&gt;&gt;&gt;&gt;&gt; Invoked Done");

        return result;
    }

}
</code></pre>

<p>We print some message before and after the invocation of method.</p>

<pre><code class="java MyLogicClass">package spring.test.aop;

public class MyLogicClass {

    public void methodOne() {
        System.out.println("MethodOne is Running");
    }

    public void methodTwo(int x) {
        System.out.println(String.format(
                "MethodTwo is running with argument %s", x));
    }
}
</code></pre>

<p>Here, in our logic class, there are two methods, one without argument, another with int type argument. Both method print message in console.</p>

<pre><code class="xml springConfig.xml">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;
    &lt;bean id="myAroundAdvice" class="spring.test.aop.MyAroundAdvice" /&gt;

    &lt;bean id="myLogicClass" class="spring.test.aop.MyLogicClass" /&gt;

    &lt;bean id="myDynamicPointcut" class="spring.test.aop.MyDynamicPointcut" /&gt;

    &lt;bean id="advisor" class="org.springframework.aop.support.DefaultPointcutAdvisor"&gt;
        &lt;property name="pointcut" ref="myDynamicPointcut" /&gt;
        &lt;property name="advice" ref="myAroundAdvice" /&gt;
    &lt;/bean&gt;

    &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;advisor&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>Create our <em>MyDynamicPointcut</em> bean and <em>MyAroundAdvice</em> bean and put them into <strong>DefaultPointcutAdvisor</strong> bean. Finally put the advisor and target class to the <strong>ProxyFactoryBean</strong>.</p>

<pre><code class="java App.java">package spring.test.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {
    private static ApplicationContext context;

    public static void main(String[] args) {
        context = new ClassPathXmlApplicationContext("springConfig.xml");

        MyLogicClass proxy = (MyLogicClass) context.getBean("proxyFactoryBean");

        proxy.methodOne();
        System.out.println("\n--------------------\n");
        proxy.methodTwo(1);
        System.out.println("\n--------------------\n");
        proxy.methodTwo(11);

    }
}
</code></pre>

<p>We call the <em>methodTwo</em> twice with different arguments. Let&rsquo;s see the output.</p>

<pre><code>Dynamic check for methodOne
MethodOne is Running

--------------------

Dynamic check for methodTwo
MethodTwo is running with argument 1

--------------------

Dynamic check for methodTwo
&gt;&gt;&gt;&gt;&gt;&gt; Invoking method methodTwo
MethodTwo is running with argument 11
&gt;&gt;&gt;&gt;&gt;&gt; Invoked Done
</code></pre>

<p>You see, only <em>methodTwo</em> with argument 11 (larger than 10) is intercepted.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Static Pointcut]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/11/spring-aop-static-pointcut/"/>
    <updated>2015-06-11T16:08:48+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/11/spring-aop-static-pointcut</id>
    <content type="html"><![CDATA[<p>Let&rsquo;s first to see the three very technical terms as below.</p>

<ul>
<li>Adivce - Indicate the action to take either before or after the method execution.</li>
<li>Pointcut - Indicate which method should be intercept, by method name or regular expression pattern.</li>
<li>Advisor - Group ‘Advice’ and ‘Pointcut’ into a single unit, and pass it to a proxy factory object</li>
</ul>


<!-- more -->


<h3>No pointcut example</h3>

<pre><code class="java MyLogicClass">package spring.test.aop;

public class MyLogicClass {

    public void logicMethodOne() {
        System.out.println("This is from logicMethodOne");
    }

    public void logicMethodTwo() {
        System.out.println("This is from logicMethodTwo");
    }

    public void testLogic() {
        System.out.println("This is from testLogic");
    }
}
</code></pre>

<pre><code class="java MyAroundAdvice.java">package spring.test.aop;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class MyAroundAdvice implements MethodInterceptor {

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("Before method execuation");

        Object result = invocation.proceed();

        System.out.println("After method execuation");

        return result;
    }

}
</code></pre>

<pre><code class="java App.java">package spring.test.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {

    private static ApplicationContext applicationContext;

    public static void main(String[] args) {

        applicationContext = new ClassPathXmlApplicationContext("springConfig.xml");

        MyLogicClass logicClass = (MyLogicClass)applicationContext.getBean("proxyFactoryBean");

        System.out.println("\n--------------------\n");
        logicClass.logicMethodOne();

        System.out.println("\n--------------------\n");
        logicClass.logicMethodTwo();

        System.out.println("\n--------------------\n");
        logicClass.testLogic();
        System.out.println("\n--------------------\n");

    }

}
</code></pre>

<pre><code class="xml">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;
    &lt;bean id="myAroundAdvice" class="spring.test.aop.MyAroundAdvice"/&gt;

    &lt;bean id="myLogicClass" class="spring.test.aop.MyLogicClass"/&gt;

    &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myAroundAdvice&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<pre><code class="text output">--------------------

Before method execuation
This is from logicMethodOne
After method execuation

--------------------

Before method execuation
This is from logicMethodTwo
After method execuation

--------------------

Before method execuation
This is from testLogic
After method execuation

--------------------
</code></pre>

<p>In above example, all logic methods of the class has been intercepted due to the application doesn&rsquo;t use the pointcut to specific.</p>

<h3>Name match example</h3>

<p>And now, we just want to intercept the method <em>testLogic</em>, so we need to create <strong>NameMatchMethodPointcut</strong> bean in spring config xml. and put the method name you want to intercept to the <strong>mappedName</strong> property value.</p>

<pre><code class="xml">&lt;bean id="nameMatchPointcut" class="org.springframework.aop.support.NameMatchMethodPointcut"&gt;
        &lt;property name="mappedName" value="testLogic"/&gt;
&lt;/bean&gt;
</code></pre>

<p>And also you can mapped multiple methods with <strong>mappedNames</strong>, like below.</p>

<pre><code class="xml">&lt;bean id="nameMatchPointcut" class="org.springframework.aop.support.NameMatchMethodPointcut"&gt;
        &lt;property name="mappedNames"&gt;
            &lt;list&gt;
                &lt;value&gt;logicMethodOne&lt;/value&gt;
                &lt;value&gt;logicMethodTwo&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>Then create <strong>DefaultPointcutAdvisor</strong> bean to group and associate the pointcut and advice.</p>

<pre><code class="xml">&lt;bean id="myPointcutAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor"&gt;
        &lt;property name="pointcut" ref="nameMatchPointcut"/&gt;
        &lt;property name="advice" ref="myAroundAdvice"/&gt;
&lt;/bean&gt;
</code></pre>

<p>Replace the <strong>interceptorNames</strong> of <strong>ProxyFactoryBean</strong> with the new Advisor.</p>

<pre><code class="xml">&lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myPointcutAdvisor&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
&lt;/bean&gt;
</code></pre>

<p>It&rsquo;s done, let&rsquo;s see the full spring config file and output.</p>

<pre><code class="xml springConfig.xml">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;
    &lt;bean id="myAroundAdvice" class="spring.test.aop.MyAroundAdvice"/&gt;

    &lt;bean id="myLogicClass" class="spring.test.aop.MyLogicClass"/&gt;

    &lt;bean id="nameMatchPointcut" class="org.springframework.aop.support.NameMatchMethodPointcut"&gt;
        &lt;property name="mappedName" value="testLogic"/&gt;
        &lt;!-- &lt;property name="mappedNames"&gt;
            &lt;list&gt;
                &lt;value&gt;logicMethodOne&lt;/value&gt;
                &lt;value&gt;logicMethodTwo&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt; --&gt;
    &lt;/bean&gt;

    &lt;bean id="myPointcutAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor"&gt;
        &lt;property name="pointcut" ref="nameMatchPointcut"/&gt;
        &lt;property name="advice" ref="myAroundAdvice"/&gt;
    &lt;/bean&gt;

    &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myPointcutAdvisor&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<pre><code class="text output">--------------------

This is from logicMethodOne

--------------------

This is from logicMethodTwo

--------------------

Before method execuation
This is from testLogic
After method execuation

--------------------
</code></pre>

<h3>Regular expression example</h3>

<p>Also we can use regular expression to match methods which should be intercepted. Create <strong>RegexpMethodPointcutAdvisor</strong> bean and set the <em>pattern</em> property value with regular expression and combine with advice.</p>

<pre><code class="xml ">&lt;bean id="regexPointcutAdvisor" class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"&gt;
        &lt;property name="pattern" value=".*Method.*"/&gt;

        &lt;property name="advice" ref="myAroundAdvice"/&gt;
&lt;/bean&gt;
</code></pre>

<p>And you can specific multiple patterns with <em>patterns</em> property.</p>

<pre><code class="xml ">&lt;bean id="regexPointcutAdvisor" class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"&gt;
        &lt;property name="patterns"&gt;
            &lt;list&gt;
                &lt;value&gt;.*Method.*&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;

        &lt;property name="advice" ref="myAroundAdvice"/&gt;
&lt;/bean&gt;
</code></pre>

<p>Finally pass the advisor to the <strong>ProxyFactoryBean</strong>.</p>

<pre><code class="xml">&lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;regexPointcutAdvisor&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
&lt;/bean&gt;
</code></pre>

<pre><code class="text output">--------------------

Before method execuation
This is from logicMethodOne
After method execuation

--------------------

Before method execuation
This is from logicMethodTwo
After method execuation

--------------------

This is from testLogic

--------------------
</code></pre>

<p>In practice, you can use it to manage DAO layer, where you can declare “.*DAO.*” to intercept all your DAO classes to support transaction.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Pointcut]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/10/spring-aop-pointcut/"/>
    <updated>2015-06-10T11:19:44+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/10/spring-aop-pointcut</id>
    <content type="html"><![CDATA[<p>What is <code>Pointcut</code> of Spring AOP? let&rsquo;s describe it. A <code>Pointcut</code> defines what <code>Advice</code>s are required at what <code>Join Point</code>s. In fact all business logic methods of the class are not required all services, that means each business logic method might require different service even some methods don&rsquo;t require. So Pointcut can informs IOC container that what business methods of a class needs what type of services.</p>

<!-- more -->


<p>There are two types of AOP:</p>

<ul>
<li>StaticMethodMatcherPointcut</li>
<li>DynamicMethodMatcherPointcut</li>
</ul>


<p>Pointcut verifys whether a particular method of particular class is eligible for getting the advice or not. Spring AOP has two static pointcut class.</p>

<ul>
<li>NameMatchMethodPointcut</li>
<li>RegexpMethodPointcutAdvisor</li>
</ul>


<p>In above two static pointcut class, they given by spring AOP framework. And they only verify whether the method name is matching with given condition or not, but they doesn&rsquo;t check whether the class names are matching or not. If you want to verify the class name, you can implement <code>StaticMethodMatcherPointcut</code> abstract class and override the <code>getClassFilter()</code>, <code>matches()</code> methods.</p>

<p>The dynamic pointcut is almost same with static pointcut, the only difference is that the dynamic pointcut can verify the arguments of the method at runtime, but static pointcut couldn&rsquo;t.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Join Point]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/09/spring-aop-joint-point/"/>
    <updated>2015-06-09T17:19:23+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/09/spring-aop-joint-point</id>
    <content type="html"><![CDATA[<p>In Spring AOP, while we create business logic of the method we usually need to inject the services at different places or points. So we call these places or points as <code>JoinPoint</code>.</p>

<p>At a join point place services will be injected at run time. And while executing business logic of method, the services can be injected in following 3 join points.</p>

<ul>
<li>Before business logic of method starts</li>
<li>After business logic of method complete</li>
<li>If business logic of method throws exception at run time.</li>
</ul>


<p>In a <code>join point</code>, many <code>Aspect</code>s(just name, not implementation) can be injected. Actually the <code>Advice</code>(the implementation of Aspect) is injected.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Throws Advice]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/08/spring-aop-throws-advice/"/>
    <updated>2015-06-08T14:39:43+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/08/spring-aop-throws-advice</id>
    <content type="html"><![CDATA[<p>In this type of Advice. This service executed when the logic method throws exceptions. To create Throws Advice, we should implement the interface called <code>ThrowsAdvice</code>.</p>

<p><code>ThrowsAdvice</code> is provided by <em>org.springframework.aop.*</em> package. But it has not any method we need to override.</p>

<!-- more -->


<p></p>

<p>While creating a ThrowsAdvice class in spring AOP, we should implement our services in a method called <code>afterThrowing()</code> with 1 or 4 parameter(s). In fact, this method not given in <code>ThrowsAdvice</code> interface, but we should implement our services in afterThrowing() method only because when ever an Exception is occurred in the business logic then the IOC container internally calls afterThrowing() method to apply the services.</p>

<p>Let&rsquo;s see the <code>afterThrowing()</code> method.</p>

<pre><code class="java ">package spring.test.aop;

import java.lang.reflect.Method;

import org.springframework.aop.ThrowsAdvice;

public class MyThrowsAdvice implements ThrowsAdvice {

    // just exception
    public void afterThrowing(Exception e) {

    }

    // specific null pointer exception
    public void afterThrowing(NullPointerException e) {

    }

    // with 4 parameters
    public void afterThrowing(Method method, Object[] args, Object target, Exception e) {

    }
}
</code></pre>

<p>If we write multiple afterThrowing methods in a class, then the <code>IOC</code> container will give the preference as below:</p>

<p>Specific exception > 4 parameters > just exception.</p>

<p>Let&rsquo;s take a practice.</p>

<pre><code class="java MyLogicInterface.java">package spring.test.aop;

public interface MyLogicInterface {
    void divide(int a, int b);
}
</code></pre>

<pre><code class="java MyLogicClass.java">package spring.test.aop;

public class MyLogicClass implements MyLogicInterface {

    @Override
    public void divide(int a, int b) {
        System.out.println(String.format("%s divide %s is %s\n", a, b, a / b));
    }

}
</code></pre>

<p>In our logic class. We print the message about one param divided by another one.</p>

<pre><code class="java MyThrowsAdvice.java">package spring.test.aop;

import java.lang.reflect.Method;

import org.springframework.aop.ThrowsAdvice;

public class MyThrowsAdvice implements ThrowsAdvice {

    // just exception
    public void afterThrowing(Exception e) {
        System.out.println("Exception: " + e.getMessage());
    }

    // specific exception
    public void afterThrowing(ArithmeticException e) {
        System.out.println("Specific ArithmeticException: " + e.getMessage());
    }

    // with 4 parameters
    public void afterThrowing(Method method, Object[] args, Object target, Exception e) {
        System.out.println("With 4 parameters exception: " + e.getMessage());
    }
}
</code></pre>

<p>There have three implementations of afterThrowing method. And also we can add our handle exception logic in them.</p>

<pre><code class="xml springConfig.xml">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;
    &lt;bean id="myThrowsAdvice" class="spring.test.aop.MyThrowsAdvice"/&gt;

    &lt;bean id="myLogicClass" class="spring.test.aop.MyLogicClass"/&gt;

    &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="proxyInterfaces" value="spring.test.aop.MyLogicInterface"/&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myThrowsAdvice&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<pre><code class="java App.java">package spring.test.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {

    private static ApplicationContext applicationContext;

    public static void main(String[] args) {
        applicationContext = new ClassPathXmlApplicationContext("springConfig.xml");
        MyLogicInterface myLogicInterface = (MyLogicInterface)applicationContext.getBean("proxyFactoryBean");

        myLogicInterface.divide(10, 5);

        myLogicInterface.divide(10, 0);
    }

}
</code></pre>

<p>In our client, we can see the divide method is called twice. The First one will not throw exception, but second will throw ArithmeticException.</p>

<p>Let&rsquo;s see the result of execution:</p>

<pre><code>10 divide 5 is 2

Exception in thread "main" Specific ArithmeticException: / by zero
</code></pre>

<p>We can see the specific ArithmeticException is executed. Okay, let us remove the specific exception method and run it again.</p>

<pre><code>10 divide 5 is 2

With 4 parameters exception: / by zero
</code></pre>

<p>The afterThrowing method with 4 parameters has been executed. Keep remove this method and run it.</p>

<pre><code>10 divide 5 is 2

Exception: / by zero
</code></pre>

<p>So there is only one afterThrowing method is executed when there have multiple implementation.</p>
]]></content>
  </entry>
  
</feed>
