<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Aop | Stonefishy Blog]]></title>
  <link href="http://stonefishy.github.io/blog/categories/aop/atom.xml" rel="self"/>
  <link href="http://stonefishy.github.io/"/>
  <updated>2015-06-10T18:01:34+08:00</updated>
  <id>http://stonefishy.github.io/</id>
  <author>
    <name><![CDATA[Yu]]></name>
    <email><![CDATA[andrewsy@live.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Pointcut]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/10/spring-aop-pointcut/"/>
    <updated>2015-06-10T11:19:44+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/10/spring-aop-pointcut</id>
    <content type="html"><![CDATA[<p>What is <code>Pointcut</code> of Spring AOP? let&rsquo;s describe it. A <code>Pointcut</code> defines what <code>Advice</code>s are required at what <code>Join Point</code>s. In fact all business logic methods of the class are not required all services, that means each business logic method might require different service even some methods don&rsquo;t require. So Pointcut can informs IOC container that what business methods of a class needs what type of services.</p>

<!-- more -->


<p>There are two types of AOP:</p>

<ul>
<li>StaticMethodMatcherPointcut</li>
<li>DynamicMethodMatcherPointcut</li>
</ul>


<p>Pointcut verifys whether a particular method of particular class is eligible for getting the advice or not. Spring AOP has two static pointcut class.</p>

<ul>
<li>NameMatchMethodPointcut</li>
<li>RegularExpressionMethodPointcut</li>
</ul>


<p>In above two static pointcut class, they given by spring AOP framework. And they only verify whether the method name is matching with given condition or not, but they doesn&rsquo;t check whether the class names are matching or not. If you want to verify the class name, you can implement <code>StaticMethodMatcherPointcut</code> abstract class and override the <code>getClassFilter()</code>, <code>matches()</code> methods.</p>

<p>The dynamic pointcut is almost same with static pointcut, the only difference is that the dynamic pointcut can verify the arguments of the method at runtime, but static pointcut couldn&rsquo;t.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Join Point]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/09/spring-aop-joint-point/"/>
    <updated>2015-06-09T17:19:23+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/09/spring-aop-joint-point</id>
    <content type="html"><![CDATA[<p>In Spring AOP, while we create business logic of the method we usually need to inject the services at different places or points. So we call these places or points as <code>JoinPoint</code>.</p>

<p>At a join point place services will be injected at run time. And while executing business logic of method, the services can be injected in following 3 join points.</p>

<ul>
<li>Before business logic of method starts</li>
<li>After business logic of method complete</li>
<li>If business logic of method throws exception at run time.</li>
</ul>


<p>In a <code>join point</code>, many <code>Aspect</code>s(just name, not implementation) can be injected. Actually the <code>Advice</code>(the implementation of Aspect) is injected.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Throws Advice]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/08/spring-aop-throws-advice/"/>
    <updated>2015-06-08T14:39:43+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/08/spring-aop-throws-advice</id>
    <content type="html"><![CDATA[<p>In this type of Advice. This service executed when the logic method throws exceptions. To create Throws Advice, we should implement the interface called <code>ThrowsAdvice</code>.</p>

<p><code>ThrowsAdvice</code> is provided by <em>org.springframework.aop.*</em> package. But it has not any method we need to override.</p>

<!-- more -->


<p></p>

<p>While creating a ThrowsAdvice class in spring AOP, we should implement our services in a method called <code>afterThrowing()</code> with 1 or 4 parameter(s). In fact, this method not given in <code>ThrowsAdvice</code> interface, but we should implement our services in afterThrowing() method only because when ever an Exception is occurred in the business logic then the IOC container internally calls afterThrowing() method to apply the services.</p>

<p>Let&rsquo;s see the <code>afterThrowing()</code> method.</p>

<pre><code class="java ">package spring.test.aop;

import java.lang.reflect.Method;

import org.springframework.aop.ThrowsAdvice;

public class MyThrowsAdvice implements ThrowsAdvice {

    // just exception
    public void afterThrowing(Exception e) {

    }

    // specific null pointer exception
    public void afterThrowing(NullPointerException e) {

    }

    // with 4 parameters
    public void afterThrowing(Method method, Object[] args, Object target, Exception e) {

    }
}
</code></pre>

<p>If we write multiple afterThrowing methods in a class, then the <code>IOC</code> container will give the preference as below:</p>

<p>Specific exception > 4 parameters > just exception.</p>

<p>Let&rsquo;s take a practice.</p>

<pre><code class="java MyLogicInterface.java">package spring.test.aop;

public interface MyLogicInterface {
    void divide(int a, int b);
}
</code></pre>

<pre><code class="java MyLogicClass.java">package spring.test.aop;

public class MyLogicClass implements MyLogicInterface {

    @Override
    public void divide(int a, int b) {
        System.out.println(String.format("%s divide %s is %s\n", a, b, a / b));
    }

}
</code></pre>

<p>In our logic class. We print the message about one param divided by another one.</p>

<pre><code class="java MyThrowsAdvice.java">package spring.test.aop;

import java.lang.reflect.Method;

import org.springframework.aop.ThrowsAdvice;

public class MyThrowsAdvice implements ThrowsAdvice {

    // just exception
    public void afterThrowing(Exception e) {
        System.out.println("Exception: " + e.getMessage());
    }

    // specific exception
    public void afterThrowing(ArithmeticException e) {
        System.out.println("Specific ArithmeticException: " + e.getMessage());
    }

    // with 4 parameters
    public void afterThrowing(Method method, Object[] args, Object target, Exception e) {
        System.out.println("With 4 parameters exception: " + e.getMessage());
    }
}
</code></pre>

<p>There have three implementations of afterThrowing method. And also we can add our handle exception logic in them.</p>

<pre><code class="xml springConfig.xml">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;
    &lt;bean id="myThrowsAdvice" class="spring.test.aop.MyThrowsAdvice"/&gt;

    &lt;bean id="myLogicClass" class="spring.test.aop.MyLogicClass"/&gt;

    &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="proxyInterfaces" value="spring.test.aop.MyLogicInterface"/&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myThrowsAdvice&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<pre><code class="java App.java">package spring.test.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {

    private static ApplicationContext applicationContext;

    public static void main(String[] args) {
        applicationContext = new ClassPathXmlApplicationContext("springConfig.xml");
        MyLogicInterface myLogicInterface = (MyLogicInterface)applicationContext.getBean("proxyFactoryBean");

        myLogicInterface.divide(10, 5);

        myLogicInterface.divide(10, 0);
    }

}
</code></pre>

<p>In our client, we can see the divide method is called twice. The First one will not throw exception, but second will throw ArithmeticException.</p>

<p>Let&rsquo;s see the result of execution:</p>

<pre><code>10 divide 5 is 2

Exception in thread "main" Specific ArithmeticException: / by zero
</code></pre>

<p>We can see the specific ArithmeticException is executed. Okay, let us remove the specific exception method and run it again.</p>

<pre><code>10 divide 5 is 2

With 4 parameters exception: / by zero
</code></pre>

<p>The afterThrowing method with 4 parameters has been executed. Keep remove this method and run it.</p>

<pre><code>10 divide 5 is 2

Exception: / by zero
</code></pre>

<p>So there is only one afterThrowing method is executed when there have multiple implementation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Around Advice]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/08/spring-aop-around-advice/"/>
    <updated>2015-06-08T09:42:08+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/08/spring-aop-around-advice</id>
    <content type="html"><![CDATA[<p>In this blog, let us talk about <code>Around Advice</code>. There are some few points about it.</p>

<ul>
<li><code>Around Advice</code> is combination of <code>Before Advice</code> and <code>After Advice</code>.</li>
<li>In a single <code>Around Advice</code> we can implement both <em>before</em> and <em>after</em> services.</li>
<li><strong>Note</strong>, <code>Around Advice</code> is not given by <em>spring framework</em>, it is from <em>Open Source</em> implementation called <code>AOP</code> alliance.</li>
<li><code>Around Advice</code> can be used by any framework which supports <code>AOP</code>.</li>
<li><code>Around Advice</code> can access the return value of business method and it can modify the value and it can return a different value back to the client, as return type is Object, but in the <code>After Advice</code> its not possible right, as its return type is void.</li>
</ul>


<!-- more -->


<p>In order to create <code>Around Advice</code>, we should implement an interface called <code>MethodInterceptor</code> and override the method called <code>invoke</code> which has a prarameter <code>MethodInvocation</code> type. We can use this parameter to invoke our business logic method like <code>methodInvoation.proceed()</code>. And we can add our before services before this code execution and put after services after this code.</p>

<p>Let&rsquo;s see an instance.</p>

<pre><code class="java ">package spring.test.aop;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class MyAroundAdvice implements MethodInterceptor{

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        // Adding before service in here.

        invocation.proceed();

        // Adding after service in here.
        // we can change the return value we want via below return codes.

        return null;
    }

}
</code></pre>

<p>In above codes, we can see that we put the before services before the <code>proceed()</code> method and put the after services after it. and we can change the return value of the logic method.</p>

<p>So now let us to see a full expample.</p>

<pre><code class="java MyLogicInterface.java">package spring.test.aop;

public interface MyLogicInterface {
    int add(int a, int b);
}
</code></pre>

<pre><code class="java MyLogicClass.java">package spring.test.aop;

public class MyLogicClass implements MyLogicInterface {

    @Override
    public int add(int a, int b) {
        System.out.println(String.format("The internal result of %s + %s is: %s", a, b, a + b));
        return a + b;
    }

}
</code></pre>

<p>In our logic class, we print the result value before the return of method.</p>

<pre><code class="java MyAroundAdvice.java">package spring.test.aop;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class MyAroundAdvice implements MethodInterceptor {

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        // Adding before service
        methodDescription(invocation);

        Object currentResult = invocation.proceed();

        // Adding after service.
        Object changedResult = changedReturnValue(invocation);

        return changedResult == null ? currentResult : changedResult;
    }

    private void methodDescription(MethodInvocation invocation) {
        String methodName = invocation.getMethod().getName();
        Object[] args = invocation.getArguments();

        String description = String.format("Before Services : %s(%s, %s)",
                methodName, args[0], args[1]);
        System.out.println(description);
    }

    private Object changedReturnValue(MethodInvocation invocation) {
        Object[] args = invocation.getArguments();
        int secondParam = (int) args[1];

        // changed the return value to 0 when the second parameter is less than 0.
        if (secondParam &lt; 0)
            return 0;

        return null;
    }

}
</code></pre>

<p>In this our around advice. we print the method description in our before service and changed the return value to 0 when the second parameter is less than 0 in after service.</p>

<pre><code class="xml springConfig.xml">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;
    &lt;bean id="myAroundAdvice" class="spring.test.aop.MyAroundAdvice"/&gt;

    &lt;bean id="myLogicClass" class="spring.test.aop.MyLogicClass"/&gt;

    &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="proxyInterfaces" value="spring.test.aop.MyLogicInterface"/&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myAroundAdvice&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>The spring config xml is same with before except the interceptorNames.</p>

<pre><code class="java App.java">package spring.test.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {

    private static ApplicationContext applicationContext;

    public static void main(String[] args) {
        applicationContext = new ClassPathXmlApplicationContext("springConfig.xml");
        MyLogicInterface logicInterface = (MyLogicInterface)applicationContext.getBean("proxyFactoryBean");

        int result1 = logicInterface.add(1, 10);
        System.out.println(String.format("After Advice - The result is: %s \n", result1));

        int result2 = logicInterface.add(1, -10);
        System.out.println(String.format("After Advice - The result is: %s", result2));
    }

}
</code></pre>

<p>You will notice that we pass -10 to second parameter in second times method called. Let&rsquo;s see the result:</p>

<pre><code>Before Services : add(1, 10)
The internal result of 1 + 10 is: 11
After Advice - The result is: 11 

Before Services : add(1, -10)
The internal result of 1 + -10 is: -9
After Advice - The result is: 0
</code></pre>

<p>You see, the internal result is -9, but after service, the result is changed to 0. So the return value is changed by our <code>Around Advice</code>.</p>

<p><em><strong>Note again:</strong> The <code>Around Advice</code> can change the return value of business logic method, but <code>After Advice</code> cannot.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - After Advice]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/06/spring-aop-after-advice/"/>
    <updated>2015-06-06T10:14:46+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/06/spring-aop-after-advice</id>
    <content type="html"><![CDATA[<p><code>Advice</code> is the implementation of the <code>cross-cutting</code> functionality. An <code>Adivce</code> provides the code for implementation of the service.</p>

<p>There are four types of Advice:</p>

<ul>
<li>Before Advice</li>
<li><strong>After Advice</strong></li>
<li>Around Advice</li>
<li>Throws Advice</li>
</ul>


<!-- more -->


<p><code>After Advice</code> is same as <code>Before Advice</code>. But in order to create our after advice in spring, our class should implement an interface called <code>AfterReturningAdvice</code>, this interface is given in <em>org.springframework.aop.*</em> package. And we need to override a method given by this interface called <code>afterReturning()</code>.</p>

<pre><code class="java">public class MyAfterAdvice implements AfterReturningAdvice {

    @Override
    public void afterReturning(Object returnValue, Method method,
            Object[] args, Object target) throws Throwable {
        // TODO Auto-generated method stub

    }

}
</code></pre>

<p>The <em>returnValuef</em> is the return value of the logic method, we can use it to access the return of the logic function. The <em>method</em> parameter is the logic method, we can use <em>getName()</em> to access the name of method. And the <em>args</em> parameter is arguments of logic method.</p>

<p>Let&rsquo;s see full example.</p>

<pre><code class="java ">package spring.test.aop;

public interface MyLogicInterface {
    int add(int a, int b);

    int subtract(int a, int b);
}
</code></pre>

<p>In this interface, we changed the method&rsquo;s signature, we have return value for both two method.</p>

<pre><code class="java">package spring.test.aop;

public class MyLogicClass implements MyLogicInterface {

    @Override
    public int add(int a, int b) {
        return a + b;
    }

    @Override
    public int subtract(int a, int b) {
        return a - b;
    }

}
</code></pre>

<p>In <em>MyLogicClass</em>, we implemented the two methods <em>add</em> and <em>subtract</em>, and return the value.
&#8220;` java
package spring.test.aop;</p>

<p>import java.lang.reflect.Method;</p>

<p>import org.springframework.aop.AfterReturningAdvice;</p>

<p>public class MyAfterAdvice implements AfterReturningAdvice {</p>

<pre><code>@Override
public void afterReturning(Object returnValue, Method method,
        Object[] args, Object target) throws Throwable {

    String message = String.format(
            "The result from method %s(%s, %s) is: %s", method.getName(),
            args[0], args[1], returnValue);

    System.out.println(message);

}
</code></pre>

<p>}
<code>``
We print all the messages of the logic method in our</code>After Advice`, include method name, the return value of method, the arguments etc.</p>

<p>Okay, let&rsquo;s see our spring config file.</p>

<pre><code class="java">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;
    &lt;bean id="myAfterAdvice" class="spring.test.aop.MyAfterAdvice"/&gt;

    &lt;bean id="myLogicClass" class="spring.test.aop.MyLogicClass"/&gt;

    &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="proxyInterfaces" value="spring.test.aop.MyLogicInterface"/&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myAfterAdvice&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>It is same with last spring config file of <code>Before After</code>. We just use <em>MyAfterAdvice</em> to instead of <em>MyBeforeAdvice</em>.</p>

<p>To make this application run, we should read spring config file.</p>

<pre><code class="java">package spring.test.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {

    private static ApplicationContext applicationContext;

    public static void main(String[] args) {
        applicationContext = new ClassPathXmlApplicationContext("springConfig.xml");
        MyLogicInterface myLogicInterface = (MyLogicInterface)applicationContext.getBean("proxyFactoryBean");

        myLogicInterface.add(10, 20);
        myLogicInterface.subtract(10, 5);
    }

}
</code></pre>

<p>The result of the application executioin.</p>

<pre><code>The result from method add(10, 20) is: 30
The result from method subtract(10, 5) is: 5
</code></pre>
]]></content>
  </entry>
  
</feed>
