<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Stonefishy Blog]]></title>
  <link href="http://stonefishy.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://stonefishy.github.io/"/>
  <updated>2015-09-09T23:19:15+08:00</updated>
  <id>http://stonefishy.github.io/</id>
  <author>
    <name><![CDATA[Yu]]></name>
    <email><![CDATA[andrewsy@live.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(8)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/09/06/ruby-practice-8/"/>
    <updated>2015-09-06T20:36:07+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/09/06/ruby-practice-8</id>
    <content type="html"><![CDATA[<h3>运算符</h3>

<p>以下两种运算符是等价的, op即代表操作运算符</p>

<pre><code>value1 op= value2
value1 = value1 op value2
</code></pre>

<p>利用运算符<strong>||</strong>的特性，可以简化相关的赋值代码，如下是等价的
<code>ruby 赋值方式1
name = "Ruby"
if var              #当var不是nil或false时
    name = var
end
</code></p>

<pre><code class="ruby 赋值方式2">name = var || "Ruby"
</code></pre>

<!-- more -->


<p>而利用<strong>&amp;&amp;</strong>运算符，可以避免不必要要得程序错误</p>

<pre><code class="ruby 隐藏的错误">name = ary[0]          #如果ary为nil，则此时将引发程序错误
</code></pre>

<pre><code class="ruby 使用&&避免错误">name = ary &amp;&amp; ary[0]    #避免当ary为nil时，读取ary[0]时的错误
</code></pre>

<p>使用<strong>&amp;&amp;</strong>可以在确定对象存在后再调用方法。而且代码更加简洁。</p>

<h4>范围运算符</h4>

<p>相比其他的语言如Java等，范围运算符算是一个比较特殊的运算符，范围运算符有<strong>..</strong>和<strong>&hellip;</strong>两种，其区别在于如下</p>

<ul>
<li><strong>x..y</strong>的范围是从x到y</li>
<li><strong>x&hellip;y</strong>的范围是从x到y得前一个元素</li>
</ul>


<pre><code class="ruby">(1..5).to_a             #=&gt; [1, 2, 3, 4, 5]
("a".."d").to_a         #=&gt; ["a", "b", "c", "d"]

(1...5).to_a                #=&gt; [1, 2, 3, 4]
("a"..."d").to_a            #=&gt; ["a", "b", "c"]
</code></pre>

<p>Ruby中有范围对象(Range)来表示范围对象，以下两个写法是等价的</p>

<pre><code class="ruby">ary = Range.new(1, 5)   #=&gt; 1..5
ary.class                   #=&gt; Range


ary = 1..5              #=&gt; 1..5
ary.class                   #=&gt; Range
</code></pre>

<p>在Range对象内部，可以使用<strong>succ</strong>方法根据起点值逐个生成下一值</p>

<pre><code class="ruby">a = 1
a = a.succ                  #=&gt; 2
a = a.succ                  #=&gt; 3
a.succ.succ                 #=&gt; 5
</code></pre>

<h4>运算符重定义</h4>

<p>在Ruby中有以下运算符不能重定义
::, &amp;&amp;, ||, .., &hellip;, ?:, not, =, and</p>

<p><em>二元运算符重定义</em>,如加号+、减号-</p>

<pre><code class="ruby">class Point
    attr_reader :x, :y

    def initialize(x, y)
        @x, @y = x, y
    end

    def +(other)
        self.class.new(x + other.x, y + other.y)
    end

    def -(other)
        self.class.new(x - other.x, y - other.y)
    end

    def display
        "(#{x}, #{y})"
    end
end

p1 = Point.new(1, 2)
p2 = Point.new(3, 4)
p = p1 + p2
puts p.display                  #=&gt; (4, 6)

p = p2 - p1
puts p.display                  #=&gt; (2, 2)
</code></pre>

<p><em>一元运算符</em>，如正号+，负号-等，其重定义与二元运算符不同。可定义的一元运算符有<strong>+</strong>, <strong>-</strong>, <strong>~</strong>, <strong>!</strong>4个。分别以+@， -@， ~@， !@为方法名进行方法定义。而且一元运算符都是没有参数的。</p>

<pre><code class="ruby">class Point
    attr_reader :x, :y

    def initialize(x, y)
        @x, @y = x, y
    end

    def +@
        dup
    end

    def -@
        self.class.new(-x ,-y)
    end

    def ~@
        self.class.new(-y, x)
    end

    def display
        "(#{x}, #{y})"
    end
end

p1 = Point.new(1, 2)
puts (-p1).display              #=&gt; (-1, -2)
puts (+p1).display              #=&gt; (1, 2)
</code></pre>

<h4>下标方法</h4>

<p>数组、散列中的<em>obj[i]</em>以及<em>obj[i]=x</em>这样的方法，称为下标方法。定义下标方法时的方法名分别为<strong>[]</strong>和<strong>[]=</strong>.</p>

<pre><code class="ruby">class Point
    attr_reader :x, :y

    def initialize(x, y)
        @x, @y = x, y
    end

    def [](index)
        case index
        when 0
            x
        when 1
            y
        else
            raise ArgumentError, "out of range (#{index})"
        end
    end

    def []=(index, val)
        case index
        when 0
            self.x = val
        when 1
            self.y = val
        else
            raise ArgumentError, "out of range (#{index})"
        end
    end


    def display
        "(#{x}, #{y})"
    end
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(7)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/09/01/ruby-practice-7/"/>
    <updated>2015-09-01T09:06:53+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/09/01/ruby-practice-7</id>
    <content type="html"><![CDATA[<h3>模块</h3>

<p>Ruby中的类是表现事物的属性和行为，那么模块呢？，在Ruby中<em>模块</em>表现的只是事物的行为。</p>

<p>模块与类的区别于下：</p>

<ul>
<li>模块不能拥有实例</li>
<li>模块不能被继承</li>
</ul>


<p>如何访问模块内的方法？有两种方式可以访问</p>

<p>1.使用<strong>模块名.方法名</strong>的形式来直接调用模块中定义的方法。</p>

<pre><code class="ruby">Math.sqrt(4)            #=&gt; 2.0
</code></pre>

<!-- more -->


<p>2.通过<strong>include 模块名</strong>的形式预先将模块引入到当前的命名空间，然后就可直接访问模块内的方法和常量。</p>

<pre><code class="ruby">include Math
sqrt(4)             #=&gt; 2.0
</code></pre>

<p>第二种方式也就是<strong>Mix-in</strong>扩展类的功能，将模块混合到类中。在定义类时使用<strong>include</strong>引入指定的模块后，此时该类就可以使用模块里的所有方法和常量，从而增加了该类的功能。</p>

<p><strong>Mix-in</strong>可以灵活地解决以下问题：</p>

<ul>
<li>虽然两个类拥有相似的功能，但是不希望把他们作为相同的种类（Class）来考虑的时候，此时可将相似功能封装为模块供这两个类使用</li>
<li>Ruby不支持父类的多重继承，因此无法对已经继承的类添加共同的功能的时候</li>
</ul>


<pre><code class="ruby">class Calculator
    include Math
    def my_sqrt(a, b)
        sqrt(a) + sqrt(b)           #=&gt; 调用Math模块中得sqrt方法
    end

    @@PI = PI
end

cal = Calculator.new
cal.my_sqrt(1, 4)                   #=&gt; 3.0
Calculator::PI                      #=&gt; 3.141592653589793
</code></pre>

<h4>创建模块</h4>

<p>使用<strong>module</strong>关键来创建模块，模块名的首字母必须大写</p>

<pre><code>module 模块名
    模块定义
end
</code></pre>

<pre><code class="ruby">module HelloModule
    Version = "1.0"

    def say_hello(name)
        puts "Hello #{name}"
    end

    module_function :say_hello
end

p HelloModule::Version                  #=&gt; "1.0"
HelloModule.say_hello("Ruby")           #=&gt; Hello Ruby

include HelloModule                     #=&gt; 包含模块
Version                                 #=&gt; "1.0"
say_hello("Ruby")                       #=&gt; Hello Ruby
</code></pre>

<p>在上面代码中，我们可以看到<strong>module_function</strong>方法，此方法主要用于将需要把模块函数公开给外部使用，其参数是表示方法方法名的符号，可以跟多个参数。</p>

<p><em>注：不建议在定义为模块函数的方法中使用self</em></p>

<h4>Mix-in</h4>

<p>前面提到的，在类中使用<em>include</em>引入模块，此时类的功能将得到增强。</p>

<p>如果想知道类是否包含某个模块，可以使用<strong>include？</strong>方法，如之前的Calculator类中。</p>

<pre><code class="ruby">Calculator.include?(Math)               #=&gt; true
</code></pre>

<p>Ruby中类的实例在调用方法时的顺序为，该类>包含的模块>该类的父类等这个顺序查找该方法。</p>

<pre><code class="ruby">module HelloModule
    Version = "1.0"

    def say_hello(name)
        puts "Hello #{name}"
    end
end

class HelloClass
    include HelloModule
end

hello = HelloClass.new
hello.say_hello("Ruby")                 #=&gt; Hello Ruby
</code></pre>

<p>以上代码中调用的是module中的方法。</p>

<p>用<em>ancestors</em>方法和<em>superclass</em>方法调查类的继承关系。<em>superclass</em>方法可直接返回类的父类</p>

<pre><code class="ruby">p HelloClass.ancestors                  #=&gt; [HelloClass, HelloModule, Object, Kernel, BasicObject]
p HelloClass.superclass                 #=&gt; Object
</code></pre>

<p><em>Kenerl</em>是Ruby内部的一个核心模块，Ruby程序运行时所需的共通函数都封装在此模块中。</p>

<p>单一继承的优点就是简单，不会因为过多的继承而导致类之间的关系变得复杂。所以我们需要灵活使用单一继承和Mix-in。</p>

<h4>Mix-in查找方法的规则</h4>

<ul>
<li>优先使用原来中定义的同名方法。</li>
<li>在同一个类中包含多个模块时，优先使用最后一个包含的模块。</li>
<li>嵌套include时，查找顺序也是线性的。</li>
<li>相同的模块被包含两次也上的，第2次以后的会被省略。</li>
</ul>


<h4>Object#extend方法</h4>

<p>利用Object#extend方法可以使单例类包含模块，并把模块的功能扩展到对象中。</p>

<pre><code class="ruby">module Welcome
    def welcome(name)
        "#{self} Welcome #{name}"
    end
end

str = "World"
str.extend(Welcome)                     #=&gt; 将Welcome模块扩展到str对象上
puts str.welcome("Ruby")                #=&gt; World Welcome Ruby
</code></pre>

<p><strong>include</strong>可以帮助我们突破继承的限制，通过模块扩展类的功能；而<strong>extend</strong>则可以帮助我们跨过类，直接通过模块扩展对象的功能.</p>

<p>所有类本身都是Class类的对象，类方法就是类对象的实例方法。可以把类方法理解为下:</p>

<ul>
<li><strong>Class</strong>类的实例方法</li>
<li>类对象的单例方法</li>
</ul>


<p>使用<strong>extend</strong>方法为类对象追加类方法，使用<strong>include</strong>方法追加实例方法。</p>

<pre><code class="ruby">module ClassMethod
    def class_method
        "class method"
    end
end

module InstanceMethod
    def instance_method
        "instance method"
    end
end

class MyClass
    extend ClassMethod                  #使用extend方法定义类方法
    include InstanceMethod              #使用include定义实例方法
end

p MyClass.class_method                  #=&gt; "class method"
p MyClass.new.instance_method           #=&gt; "instance method"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(5)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/08/24/ruby-practice-5/"/>
    <updated>2015-08-24T15:22:56+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/08/24/ruby-practice-5</id>
    <content type="html"><![CDATA[<h3>方法</h3>

<p>在Ruby中，调用方法时是可以省略()的</p>

<pre><code class="ruby">&gt;&gt; print("Hello world")             #=&gt;Hello world
&gt;&gt; print "Hello world"              #=&gt;Hello world
</code></pre>

<p><em>带块的方法</em>
带块的方法如time,each方法，其语法如下：</p>

<pre><code>对象.方法名(参数，...) do |变量1，...|
    块内容
end
</code></pre>

<p>Ruby中方法可归为3类：</p>

<!-- more -->


<p><em>实例方法</em>
即由对象来调用，以下数组的size方法为实例方法</p>

<pre><code class="ruby">&gt;&gt; [1, 2].size                      #=&gt;size方法即为实例方法
</code></pre>

<p><em>类方法</em>
由类本身来调用，和C#、Java中得静态方法类似，类方法不属于任何一个对象</p>

<pre><code class="ruby">&gt;&gt; Array.new
&gt;&gt; File.open("some_file")
&gt;&gt; Time.now
</code></pre>

<p>调用类方法时，可以使用<strong>::</strong>代替<strong>.</strong></p>

<p><em>函数式方法</em></p>

<pre><code class="ruby">&gt;&gt; print "hello"
&gt;&gt; sleep(10)
</code></pre>

<p>在Ruby的帮助文档中，一般使用<strong>类名#方法名</strong>来标记实例方法，用<strong>类名.方法名</strong>或者<strong>类名::方法名</strong>来标记类方法</p>

<h4>方法的定义</h4>

<p>定义方法的语句如下:</p>

<pre><code>def 方法名(参数1，参数2,...)
    希望执行的处理
end
</code></pre>

<p>可以指定默认参数给方法，当方法有多个参数时，从参数列表的右边开始依次指定默认值</p>

<pre><code class="ruby">def func(a, b = 1, c = 2)
    #some codes
end
</code></pre>

<p><em>注，只省略左边的参数或中间的某个参数是不行的</em></p>

<p>方法的返回值使用<strong>return</strong>关键字，当这个关键字省略时，方法的最后一个表达式的结果就会成为方法的返回值。</p>

<p><em>定义带块的方法</em>
在定义带块的方法时，需要使用<strong>yield</strong>关键字来定义块所在的位置。如下代码所示</p>

<pre><code class="ruby">#定义
def func
    yield
end

#调用
func do
    print "hello world"
end
</code></pre>

<p>如果<strong>yield</strong>部分有参数，程序就会将其当作块变量传到块里。快里面最后的表达式的值即为快得执行结果，同时也可以作为<strong>yield</strong>的返回值在块的外部使用。</p>

<p><em>参数个数不确定的方法</em>
通过使用<strong>*变量名</strong>的形式来定义参数个数不确定的方法。Ruby会把所有的参数封装为数组，提供方法内部使用。</p>

<pre><code class="ruby">def func(*args)
    args
end

p func(1, 2, 3)             #=&gt; [1, 2, 3]
</code></pre>

<p>当方法需要指定特定的参数，而其他参数又不确定的情况下</p>

<pre><code class="ruby ">def sum(arg1, arg2, *args)
    result = arg1 + arg2
    args.each do | arg |
        result += arg
    end
    result
end

p sum(1, 2, 3, 4)           #=&gt; 10
</code></pre>

<p>所有不确定的参数都被作为数组赋值给变量args, <strong>*变量名</strong>这种形式的参数，只能在方法定义的参数列表中出现一次。</p>

<p><em>关键字参数</em>
使用关键字参数，可以将参数名与参数值成对地传给方法内部使用，这时，调用方法的参数个数以及调用顺序就可以打乱。</p>

<pre><code>def 方法名(参数1：值1, 参数2：值2, ...)
    逻辑处理
end
</code></pre>

<p>而且还可以在方法定义时指定参数默认值</p>

<pre><code class="ruby">def sum(a: 0, b: 0)
    a + b
end

p sum(a: 10, b: 20)         #=&gt; 30
p sum(b: 20, a: 10)         #=&gt; 30  改变参数的调用顺序
p sum(b: 20)                    #=&gt; 20 省略了参数a，a默认值为0
</code></pre>

<p>使用关键字参数定义方法，如果我们传入了未定义的参数，那么程序将会报错。如何避免呢，在Ruby中可以使用<strong>**变量名</strong>的形式来接收未定义的参数。此时，Ruby会把参数列表以外的其他关键字参数以散列对象的形式保存。</p>

<pre><code class="ruby ">def sum(a: 0, b: 0, **args)
    result = a + b
    args.each do |key, value|           #=&gt; 遍历散列
        result += value
    end
    result
end

sum(a: 1, b: 2, c: 3, d: 4)         #=&gt; 10
</code></pre>

<p>当然，关键字参数也可以与普通参数一起搭配使用。</p>

<pre><code class="ruby">def sum(a, b: 1, c: 2)
    sum = a + b + c
end

sum(10, b: 20, c: 30)           #=&gt; 60
</code></pre>

<p>以关键字参数定义的方法，Ruby会自动将其封装为散列然后传递给方法内部，所以基于此，我们当然也可以利用散列的键值来将散列传递给方法</p>

<pre><code class="ruby">def sum(a: 0, b: 0, c: 0)
    sum = a + b + c
end

args = {a: 1, b: 2, c: 3}           #=&gt; 定义散列args
sum(args)                               #=&gt; 6 将散列args传递给sum方法
sum({"a"=&gt;1, "b"=&gt;2, "c"=&gt;3}）     #=&gt; 6 将散列直接传给方法
sum(c: 3, a: 1, b: 2)               #=&gt; 6 可省略{}
</code></pre>

<p><em>使用关键字参数定义方法，既可以对键进行限制，又可以定义参数的默认值，建议在实际编程中多尝试使用关键字参数</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(4)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/08/17/ruby-practice-4/"/>
    <updated>2015-08-17T17:01:35+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/08/17/ruby-practice-4</id>
    <content type="html"><![CDATA[<h3>循环</h3>

<p>对于任何一种程序设计语言，都有循环处理的方法，Ruby也一样，但是在Ruby中有两种实现循环的方法。</p>

<ul>
<li>使用循环语句，即利用Ruby提供的现有循环语句</li>
<li>使用方法实现循环，其具体做法为，将块传给方法，然后在块里面写上需要循环的处理。</li>
</ul>


<p>在Ruby中，有6种循环语句或方法：</p>

<!-- more -->


<ul>
<li>times方法</li>
<li>while语句</li>
<li>each方法</li>
<li>for语句</li>
<li>until语句</li>
<li>loop方法</li>
</ul>


<p><em>times方法</em>
用于已知道执行的次数，具体用法如下:</p>

<pre><code>循环次数.times do
    逻辑处理
end

#do ~ end部分可以用 { ~ }代替.

循环次数.times {
    逻辑处理
}
</code></pre>

<pre><code class="ruby times方法">&gt;&gt; 3.times do
&gt;&gt;      print "hello "
&gt;&gt; end
hello hello hello =&gt; 3              #=&gt; 打印3个hello，并返回循环次数
</code></pre>

<p>如果想知道当前的循环次数，则需要添加一个当前的循环次数变量:</p>

<pre><code>循环次数.times do |i|
    逻辑处理
end
</code></pre>

<pre><code class="ruby 带循环次数的times方法">&gt;&gt; 3.times do |i|
&gt;&gt;      print "hello#{i} "
&gt;&gt; end
hello0 hello1 hello2 =&gt; 3           #=&gt; 打印3个带有当前第几次循环的hello,并返回循环次数
</code></pre>

<p><em>注：<strong>times</strong>方法会返回循环次数</em></p>

<p><em>for语句</em>
与<strong>times</strong>方法不同，<strong>for</strong>并不是方法，而是循环控制语句。</p>

<pre><code>for 变量 in 开始时的数值..结束时的数值 do
    循环处理
end

#遍历对象的for语句
for 变量 in 对象 do
    循环处理
end
</code></pre>

<p><strong>for</strong>语句的循环开始值和结束值可以任意指定。</p>

<pre><code class="ruby for语句">&gt;&gt; for i in 1..3
&gt;&gt;      print "hello "
&gt;&gt; end
hello hello hello =&gt; 1..3           #=&gt; 打印3个hello，返回1..3的range


&gt;&gt; language = ["Python", "Javascript", "Ruby"]
&gt;&gt; for lan in language
&gt;&gt;      print "#{lan} "
&gt;&gt; end
Python Javascript Ruby =&gt; ["Python", "Javascript", "Ruby"]          #=&gt; 一次打印数组中的元素，并返回数组
</code></pre>

<p><em>注：..或者&hellip;都是创建范围对象时所需的符号</em></p>

<p><em>while语句</em>
之前了解到，语法如下，十分简单</p>

<pre><code>while 条件 do
    循环处理
end
</code></pre>

<pre><code class="ruby while语句">&gt;&gt; i, sum = 1, 0
&gt;&gt; while sum &lt; 50 do
&gt;&gt;      sum += i
&gt;&gt;      i += 1
&gt;&gt; end
&gt;&gt; puts sum                 #=&gt; 55
</code></pre>

<p><em>until语句</em>
和<strong>while</strong>语句刚刚相反，<strong>until</strong>语句不满足条件时才执行循环处理，知道条件满足终止。</p>

<pre><code>until 条件 do
    循环处理
end
</code></pre>

<pre><code class="ruby until语句">&gt;&gt; i, sum = 1, 0
&gt;&gt; until sum &gt;=50 do
&gt;&gt;      sum += i
&gt;&gt;      i += 1
&gt;&gt; end
&gt;&gt;  puts sum                    #=&gt; 55
</code></pre>

<p><em>each方法</em>
<strong>each</strong>方法将对象集合里的对象逐个取出，这与<strong>for</strong>语句循环取出数组元素非常相似。</p>

<pre><code>对象.each do |变量|
    循环处理
end

#与下面的for语句处理一样
for 变量 in 对象
    循环处理
end
</code></pre>

<pre><code class="ruby each方法">&gt;&gt; language = ["Python", "Javascript", "Ruby"]
&gt;&gt; language.each do |lan|
&gt;&gt;      print "#{lan} "
&gt;&gt; end
Python Javascript Ruby =&gt; ["Python", "Javascript", "Ruby"]          #=&gt; 返回对象
</code></pre>

<p><em>注：在Ruby内部，<strong>for</strong>语句是用<strong>each</strong>方法来实现的。可以使用<strong>each</strong>方法的对象，也可以用<strong>for</strong>语句</em></p>

<p><em>loop方法</em>
此循环方法没用终止循环条件，需要用得循环控制语句来控制此循环</p>

<pre><code>loop do
    循环处理
end
</code></pre>

<h3>循环控制命令</h3>

<ul>
<li>break 终止程序，跳出循环</li>
<li>next 跳到下一次循环，和其他类似Java，C#的continue一样</li>
<li>redo 在相同的条件下重复刚才的处理</li>
</ul>


<p><strong>redo</strong>与<strong>next</strong>非常像，与<strong>next</strong>的不同之处是，<strong>redo</strong>会再执行一次相同的循环。所以要注意<strong>redo</strong>的使用方法，很容易陷入死循环中。</p>

<p>*注： <strong>do ~ end</strong> 和 <strong>{ ~ }</strong> 是等价的语句块。 只不过从编码规范上来说，如果程序是跨行写的时候使用<strong>do ~ end</strong>，程序写在1行的时候用<strong>{ ~ }</strong>.</p>

<pre><code class="ruby">&gt;&gt; 3.times do |i|
&gt;&gt;      puts i
&gt;&gt; end

&gt;&gt; 3.times { |i| puts i }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(3)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/08/14/ruby-practice-3/"/>
    <updated>2015-08-14T17:47:01+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/08/14/ruby-practice-3</id>
    <content type="html"><![CDATA[<p>在Ruby中任何表现数据的基本单位都称为对象(object), 而Ruby的类(class)表示的就是这些对象的种类。</p>

<h3>变量</h3>

<p>和其他面向对象语言一样，Ruby也有多种类型的变量，但是在Ruby中，变量的类型是由变量的命名方式决定的。</p>

<p><em>局部变量(local variable)</em>
以英文字母或者_开头</p>

<pre><code class="ruby">words = "Hello Ruby"
_words = "Hello Ruby"
</code></pre>

<!--more-->


<p><em>全局变量(global variable)</em>
以$开头</p>

<pre><code class="ruby">$words="Hello Ruby"
</code></pre>

<p><em>实例变量(instance variable)</em>
以@开头</p>

<pre><code class="ruby">@words="Hello Ruby"
</code></pre>

<p><em>类变量(class variable)</em></p>

<p>以@@开头
<code>ruby
@@words = "Hello Ruby"
</code></p>

<p><em>伪变量(pseudo variable)</em>
伪变量是Ruby预先定义好的代表某个特定值的特殊变量，因此这个值是无法改变的。如，nil、true、false、self等。</p>

<p><em>注：Ruby不需要在意变量名的长度，对于多个单词组合的变量名，使用_隔开各个单词，或者单词以大写字母开头，如：my_words,或者myWords。但是在Ruby中的变量名和方法名一般使用前者，而后者主要用于类名和模块名。</em></p>

<h3>常量</h3>

<p>顾名思义，即不可修改，对已经赋值的常量再进行赋值时，Ruby会做出警告。常量均以大写字母来命名。如Ruby中预先定义好的RUBY_VERSION(运行版本)、RUBTY_PLATFORM(运行平台)、ARGV(命令行参数数组).</p>

<h3>多重赋值</h3>

<p>多重赋值是Ruby中的简化代码的一种方式，通过多重赋值可以将多个变量同时赋值。</p>

<pre><code class="ruby">&gt;&gt; a, b, c = 1, 2, 3    ##同时赋值a, b, c
&gt;&gt; p [a, b, c]          ##=&gt; [1, 2, 3]
</code></pre>

<p>这样a, b, c均被赋值了1, 2, 3。
<em>注：在使用多重赋值时，建议对彼此相关变量进行多重赋值，避免程序难读懂。</em></p>

<p>即使等号(=)左右两边列表的数量不相等，Ruby也不会报错。
<em>左边变量部分数量多时</em></p>

<pre><code class="ruby">&gt;&gt; a, b, c, d = 1, 2
&gt;&gt; p [a, b, c, d]           ##=&gt; [1, 2, nil, nil]
</code></pre>

<p>当左边变量部分数量多时，Ruby会自动将<strong>nil</strong>赋值给未被分配值的变量。如上的c, d变量。</p>

<p><em>左边变量部分数量少时</em></p>

<pre><code class="ruby">&gt;&gt; a, b, c = 1, 2, 3, 4
&gt;&gt; p [a, b, c]              ##=&gt; [1, 2, 3]
</code></pre>

<p>当变量部分比较少时，Ruby会忽略掉该值，不会分配多余的值，如上的值4。</p>

<p><em>将未被分配的值赋给指定的变量</em>
当给一个变量前加上*，表示Ruby会将未分配的值封装为数组赋值给该变量。通过这种方式，Ruby会将变量与右边的值一一匹配。</p>

<pre><code class="ruby">&gt;&gt; a, b, *c = 1, 2, 3, 4
&gt;&gt; p [a, b, c]                  ##=&gt; [1, 2, [3, 4]]

&gt;&gt; a, *b, c = 1, 2, 3, 4, 5
&gt;&gt; p [a, b, c]                  ##=&gt; [1, [2, 3, 4], 5]
</code></pre>

<p>使用多重赋值简化变量值交换：</p>

<pre><code class="ruby">&gt;&gt; a, b = 0, 1
&gt;&gt; a, b = b, a                  ##置换变量a、b的值
&gt;&gt; p [a, b]                     ##=&gt; [1, 0]
</code></pre>

<p>使用多重赋值获取数组的元素:</p>

<pre><code class="ruby">&gt;&gt; arr = [1, 2]
&gt;&gt; a, b = arr
&gt;&gt; p a                              ##=&gt; 1
&gt;&gt; p b                              ##=&gt; 2


&gt;&gt; arr = [1, [2, 3], 4]
&gt;&gt; a, b, c = arr
&gt;&gt; p a                              ##=&gt; 1
&gt;&gt; p b                              ##=&gt; [2, 3]
&gt;&gt; p c                              ##=&gt; 4


&gt;&gt; arr = [1, [2, 3], 4]
&gt;&gt; a, (b, c), d = arr
&gt;&gt; p a                              ##=&gt; 1
&gt;&gt; p b                              ##=&gt; 2
&gt;&gt; p c                              ##=&gt; 3
&gt;&gt; p d                              ##=&gt; 4
</code></pre>

<p>只要等号左边的变量结构与数组的结构一致，即使再复杂的结构，多重赋值以可以轻松对应。</p>

<h3>条件判断</h3>

<p>Ruby中条件判断有三种，if语句，unless语句，case语句。If语句我们之前讲过，这里主要涉及剩余两种。</p>

<p><em>unless语句</em>
这个判断语句刚好与if语句相反，当条件为假时才执行</p>

<pre><code>unless 条件为假 then
    逻辑处理
end

unless 条件为假
    逻辑处理1
else
    逻辑处理2
end
</code></pre>

<p><em>then</em>关键字可以省略。</p>

<p><em>case语句</em>
如果需要比较的对象只有一个，根据这个对象值的不同，执行不同的逻辑处理。</p>

<pre><code>case 比较对象
when 值1 then
    逻辑处理1
when 值2 then
    逻辑处理2
when 值3 then
    逻辑处理3
else
    逻辑处理4
end
</code></pre>

<p>当然，<em>then</em>关键字也可以省略。
<em>when</em>关键字也可以一次指定多个值。</p>

<pre><code>case 比较对象
when 值1，值2，值3 then
    逻辑处理1
else
    逻辑处理2
end
</code></pre>

<p>在<em>case</em>语句中，<em>when</em>判断值是否相等时，实际是使用<strong>===</strong>运算符来判断的。当左边是数值或者字符串时，<strong>===</strong>与<strong>==</strong>的意义是一样的。</p>

<p><em>注:Ruby中只有<strong>nil</strong>和<strong>false</strong>为假，除此之外的值全为真.</em></p>

<p>在Ruby中，所有的对象都是唯一的，可以通过<strong>object_id</strong>（或者<strong><strong>id</strong></strong>)方法获取对象的标识。</p>

<pre><code class="ruby">&gt;&gt; arr1 = []
&gt;&gt; arr2 = []
&gt;&gt; p arr1.object_id         ##=&gt; 70115564029000
&gt;&gt; p arr2.__id__                ##=&gt; 70115559585120
</code></pre>

<p>如果判断两个对象是否是同一个对象，即是否引用的是同一个ID的对象。Ruby提供了<strong>equal?</strong>方法来判断。</p>

<pre><code class="ruby">&gt;&gt; arr1 = []
&gt;&gt; arr2 = []
&gt;&gt; arr1.equal? arr2         ##=&gt; false
&gt;&gt; arr3 = arr1
&gt;&gt; arr1.equal? arr3         ##=&gt; true
</code></pre>

<p>除了<strong>==</strong>以外，Ruby还提供了<strong>eql?</strong>方法用来判断对象的值是否相等。大部分情况下 <strong>==</strong>与<strong>eql?</strong>执行结果都是一样的。但针对数值类，<strong>eql?</strong>方法会被重定义。</p>

<pre><code class="ruby">p 1.0 == 1                  ##=&gt; true
p 1.0.eql? 1                    ##=&gt; false
</code></pre>
]]></content>
  </entry>
  
</feed>
