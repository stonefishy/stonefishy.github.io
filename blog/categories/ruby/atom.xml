<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Stonefishy Blog]]></title>
  <link href="http://stonefishy.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://stonefishy.github.io/"/>
  <updated>2015-08-21T17:49:30+08:00</updated>
  <id>http://stonefishy.github.io/</id>
  <author>
    <name><![CDATA[Yu]]></name>
    <email><![CDATA[andrewsy@live.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(4)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/08/17/ruby-practice-4/"/>
    <updated>2015-08-17T17:01:35+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/08/17/ruby-practice-4</id>
    <content type="html"><![CDATA[<h3>循环</h3>

<p>对于任何一种程序设计语言，都有循环处理的方法，Ruby也一样，但是在Ruby中有两种实现循环的方法。</p>

<ul>
<li>使用循环语句，即利用Ruby提供的现有循环语句</li>
<li>使用方法实现循环，其具体做法为，将块传给方法，然后在块里面写上需要循环的处理。</li>
</ul>


<p>在Ruby中，有6种循环语句或方法：</p>

<!-- more -->


<ul>
<li>times方法</li>
<li>while语句</li>
<li>each方法</li>
<li>for语句</li>
<li>until语句</li>
<li>loop方法</li>
</ul>


<p><em>times方法</em>
用于已知道执行的次数，具体用法如下:</p>

<pre><code>循环次数.times do
    逻辑处理
end

#do ~ end部分可以用 { ~ }代替.

循环次数.times {
    逻辑处理
}
</code></pre>

<pre><code class="ruby times方法">&gt;&gt; 3.times do
&gt;&gt;      print "hello "
&gt;&gt; end
hello hello hello =&gt; 3              #=&gt; 打印3个hello，并返回循环次数
</code></pre>

<p>如果想知道当前的循环次数，则需要添加一个当前的循环次数变量:</p>

<pre><code>循环次数.times do |i|
    逻辑处理
end
</code></pre>

<pre><code class="ruby 带循环次数的times方法">&gt;&gt; 3.times do |i|
&gt;&gt;      print "hello#{i} "
&gt;&gt; end
hello0 hello1 hello2 =&gt; 3           #=&gt; 打印3个带有当前第几次循环的hello,并返回循环次数
</code></pre>

<p><em>注：<strong>times</strong>方法会返回循环次数</em></p>

<p><em>for语句</em>
与<strong>times</strong>方法不同，<strong>for</strong>并不是方法，而是循环控制语句。</p>

<pre><code>for 变量 in 开始时的数值..结束时的数值 do
    循环处理
end

#遍历对象的for语句
for 变量 in 对象 do
    循环处理
end
</code></pre>

<p><strong>for</strong>语句的循环开始值和结束值可以任意指定。</p>

<pre><code class="ruby for语句">&gt;&gt; for i in 1..3
&gt;&gt;      print "hello "
&gt;&gt; end
hello hello hello =&gt; 1..3           #=&gt; 打印3个hello，返回1..3的range


&gt;&gt; language = ["Python", "Javascript", "Ruby"]
&gt;&gt; for lan in language
&gt;&gt;      print "#{lan} "
&gt;&gt; end
Python Javascript Ruby =&gt; ["Python", "Javascript", "Ruby"]          #=&gt; 一次打印数组中的元素，并返回数组
</code></pre>

<p><em>注：..或者&hellip;都是创建范围对象时所需的符号</em></p>

<p><em>while语句</em>
之前了解到，语法如下，十分简单</p>

<pre><code>while 条件 do
    循环处理
end
</code></pre>

<pre><code class="ruby while语句">&gt;&gt; i, sum = 1, 0
&gt;&gt; while sum &lt; 50 do
&gt;&gt;      sum += i
&gt;&gt;      i += 1
&gt;&gt; end
&gt;&gt; puts sum                 #=&gt; 55
</code></pre>

<p><em>until语句</em>
和<strong>while</strong>语句刚刚相反，<strong>until</strong>语句不满足条件时才执行循环处理，知道条件满足终止。</p>

<pre><code>until 条件 do
    循环处理
end
</code></pre>

<pre><code class="ruby until语句">&gt;&gt; i, sum = 1, 0
&gt;&gt; until sum &gt;=50 do
&gt;&gt;      sum += i
&gt;&gt;      i += 1
&gt;&gt; end
&gt;&gt;  puts sum                    #=&gt; 55
</code></pre>

<p><em>each方法</em>
<strong>each</strong>方法将对象集合里的对象逐个取出，这与<strong>for</strong>语句循环取出数组元素非常相似。</p>

<pre><code>对象.each do |变量|
    循环处理
end

#与下面的for语句处理一样
for 变量 in 对象
    循环处理
end
</code></pre>

<pre><code class="ruby each方法">&gt;&gt; language = ["Python", "Javascript", "Ruby"]
&gt;&gt; language.each do |lan|
&gt;&gt;      print "#{lan} "
&gt;&gt; end
Python Javascript Ruby =&gt; ["Python", "Javascript", "Ruby"]          #=&gt; 返回对象
</code></pre>

<p><em>注：在Ruby内部，<strong>for</strong>语句是用<strong>each</strong>方法来实现的。可以使用<strong>each</strong>方法的对象，也可以用<strong>for</strong>语句</em></p>

<p><em>loop方法</em>
此循环方法没用终止循环条件，需要用得循环控制语句来控制此循环</p>

<pre><code>loop do
    循环处理
end
</code></pre>

<h3>循环控制命令</h3>

<ul>
<li>break 终止程序，跳出循环</li>
<li>next 跳到下一次循环，和其他类似Java，C#的continue一样</li>
<li>redo 在相同的条件下重复刚才的处理</li>
</ul>


<p><strong>redo</strong>与<strong>next</strong>非常像，与<strong>next</strong>的不同之处是，<strong>redo</strong>会再执行一次相同的循环。所以要注意<strong>redo</strong>的使用方法，很容易陷入死循环中。</p>

<p>*注： <strong>do ~ end</strong> 和 <strong>{ ~ }</strong> 是等价的语句块。 只不过从编码规范上来说，如果程序是跨行写的时候使用<strong>do ~ end</strong>，程序写在1行的时候用<strong>{ ~ }</strong>.</p>

<pre><code class="ruby">&gt;&gt; 3.times do |i|
&gt;&gt;      puts i
&gt;&gt; end

&gt;&gt; 3.times { |i| puts i }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(3)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/08/14/ruby-practice-3/"/>
    <updated>2015-08-14T17:47:01+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/08/14/ruby-practice-3</id>
    <content type="html"><![CDATA[<p>在Ruby中任何表现数据的基本单位都称为对象(object), 而Ruby的类(class)表示的就是这些对象的种类。</p>

<h3>变量</h3>

<p>和其他面向对象语言一样，Ruby也有多种类型的变量，但是在Ruby中，变量的类型是由变量的命名方式决定的。</p>

<p><em>局部变量(local variable)</em>
以英文字母或者_开头</p>

<pre><code class="ruby">words = "Hello Ruby"
_words = "Hello Ruby"
</code></pre>

<!--more-->


<p><em>全局变量(global variable)</em>
以$开头</p>

<pre><code class="ruby">$words="Hello Ruby"
</code></pre>

<p><em>实例变量(instance variable)</em>
以@开头</p>

<pre><code class="ruby">@words="Hello Ruby"
</code></pre>

<p><em>类变量(class variable)</em></p>

<p>以@@开头
<code>ruby
@@words = "Hello Ruby"
</code></p>

<p><em>伪变量(pseudo variable)</em>
伪变量是Ruby预先定义好的代表某个特定值的特殊变量，因此这个值是无法改变的。如，nil、true、false、self等。</p>

<p><em>注：Ruby不需要在意变量名的长度，对于多个单词组合的变量名，使用_隔开各个单词，或者单词以大写字母开头，如：my_words,或者myWords。但是在Ruby中的变量名和方法名一般使用前者，而后者主要用于类名和模块名。</em></p>

<h3>常量</h3>

<p>顾名思义，即不可修改，对已经赋值的常量再进行赋值时，Ruby会做出警告。常量均以大写字母来命名。如Ruby中预先定义好的RUBY_VERSION(运行版本)、RUBTY_PLATFORM(运行平台)、ARGV(命令行参数数组).</p>

<h3>多重赋值</h3>

<p>多重赋值是Ruby中的简化代码的一种方式，通过多重赋值可以将多个变量同时赋值。</p>

<pre><code class="ruby">&gt;&gt; a, b, c = 1, 2, 3    ##同时赋值a, b, c
&gt;&gt; p [a, b, c]          ##=&gt; [1, 2, 3]
</code></pre>

<p>这样a, b, c均被赋值了1, 2, 3。
<em>注：在使用多重赋值时，建议对彼此相关变量进行多重赋值，避免程序难读懂。</em></p>

<p>即使等号(=)左右两边列表的数量不相等，Ruby也不会报错。
<em>左边变量部分数量多时</em></p>

<pre><code class="ruby">&gt;&gt; a, b, c, d = 1, 2
&gt;&gt; p [a, b, c, d]           ##=&gt; [1, 2, nil, nil]
</code></pre>

<p>当左边变量部分数量多时，Ruby会自动将<strong>nil</strong>赋值给未被分配值的变量。如上的c, d变量。</p>

<p><em>左边变量部分数量少时</em></p>

<pre><code class="ruby">&gt;&gt; a, b, c = 1, 2, 3, 4
&gt;&gt; p [a, b, c]              ##=&gt; [1, 2, 3]
</code></pre>

<p>当变量部分比较少时，Ruby会忽略掉该值，不会分配多余的值，如上的值4。</p>

<p><em>将未被分配的值赋给指定的变量</em>
当给一个变量前加上*，表示Ruby会将未分配的值封装为数组赋值给该变量。通过这种方式，Ruby会将变量与右边的值一一匹配。</p>

<pre><code class="ruby">&gt;&gt; a, b, *c = 1, 2, 3, 4
&gt;&gt; p [a, b, c]                  ##=&gt; [1, 2, [3, 4]]

&gt;&gt; a, *b, c = 1, 2, 3, 4, 5
&gt;&gt; p [a, b, c]                  ##=&gt; [1, [2, 3, 4], 5]
</code></pre>

<p>使用多重赋值简化变量值交换：</p>

<pre><code class="ruby">&gt;&gt; a, b = 0, 1
&gt;&gt; a, b = b, a                  ##置换变量a、b的值
&gt;&gt; p [a, b]                     ##=&gt; [1, 0]
</code></pre>

<p>使用多重赋值获取数组的元素:</p>

<pre><code class="ruby">&gt;&gt; arr = [1, 2]
&gt;&gt; a, b = arr
&gt;&gt; p a                              ##=&gt; 1
&gt;&gt; p b                              ##=&gt; 2


&gt;&gt; arr = [1, [2, 3], 4]
&gt;&gt; a, b, c = arr
&gt;&gt; p a                              ##=&gt; 1
&gt;&gt; p b                              ##=&gt; [2, 3]
&gt;&gt; p c                              ##=&gt; 4


&gt;&gt; arr = [1, [2, 3], 4]
&gt;&gt; a, (b, c), d = arr
&gt;&gt; p a                              ##=&gt; 1
&gt;&gt; p b                              ##=&gt; 2
&gt;&gt; p c                              ##=&gt; 3
&gt;&gt; p d                              ##=&gt; 4
</code></pre>

<p>只要等号左边的变量结构与数组的结构一致，即使再复杂的结构，多重赋值以可以轻松对应。</p>

<h3>条件判断</h3>

<p>Ruby中条件判断有三种，if语句，unless语句，case语句。If语句我们之前讲过，这里主要涉及剩余两种。</p>

<p><em>unless语句</em>
这个判断语句刚好与if语句相反，当条件为假时才执行</p>

<pre><code>unless 条件为假 then
    逻辑处理
end

unless 条件为假
    逻辑处理1
else
    逻辑处理2
end
</code></pre>

<p><em>then</em>关键字可以省略。</p>

<p><em>case语句</em>
如果需要比较的对象只有一个，根据这个对象值的不同，执行不同的逻辑处理。</p>

<pre><code>case 比较对象
when 值1 then
    逻辑处理1
when 值2 then
    逻辑处理2
when 值3 then
    逻辑处理3
else
    逻辑处理4
end
</code></pre>

<p>当然，<em>then</em>关键字也可以省略。
<em>when</em>关键字也可以一次指定多个值。</p>

<pre><code>case 比较对象
when 值1，值2，值3 then
    逻辑处理1
else
    逻辑处理2
end
</code></pre>

<p>在<em>case</em>语句中，<em>when</em>判断值是否相等时，实际是使用<strong>===</strong>运算符来判断的。当左边是数值或者字符串时，<strong>===</strong>与<strong>==</strong>的意义是一样的。</p>

<p><em>注:Ruby中只有<strong>nil</strong>和<strong>false</strong>为假，除此之外的值全为真.</em></p>

<p>在Ruby中，所有的对象都是唯一的，可以通过<strong>object_id</strong>（或者<strong><strong>id</strong></strong>)方法获取对象的标识。</p>

<pre><code class="ruby">&gt;&gt; arr1 = []
&gt;&gt; arr2 = []
&gt;&gt; p arr1.object_id         ##=&gt; 70115564029000
&gt;&gt; p arr2.__id__                ##=&gt; 70115559585120
</code></pre>

<p>如果判断两个对象是否是同一个对象，即是否引用的是同一个ID的对象。Ruby提供了<strong>equal?</strong>方法来判断。</p>

<pre><code class="ruby">&gt;&gt; arr1 = []
&gt;&gt; arr2 = []
&gt;&gt; arr1.equal? arr2         ##=&gt; false
&gt;&gt; arr3 = arr1
&gt;&gt; arr1.equal? arr3         ##=&gt; true
</code></pre>

<p>除了<strong>==</strong>以外，Ruby还提供了<strong>eql?</strong>方法用来判断对象的值是否相等。大部分情况下 <strong>==</strong>与<strong>eql?</strong>执行结果都是一样的。但针对数值类，<strong>eql?</strong>方法会被重定义。</p>

<pre><code class="ruby">p 1.0 == 1                  ##=&gt; true
p 1.0.eql? 1                    ##=&gt; false
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(2)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/08/13/ru-practice-2/"/>
    <updated>2015-08-13T13:35:15+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/08/13/ru-practice-2</id>
    <content type="html"><![CDATA[<h3>数组</h3>

<p>Ruby中数组的大小是按实际情况自动调整的，即所谓的<strong>动态数组</strong></p>

<pre><code class="ruby">&gt;&gt; rubyArray = ["data1", "data2"]   ##定义两个数据的数组
&gt;&gt; rubyArray[2] = "data3"           ##新增第三个数据
&gt;&gt; print rubyArray                  ##打印["data1", "data2", "data3"]
</code></pre>

<p>Ruby数组还支持多种不同对象的混合保存, 通过<strong>数组.size</strong>可获取数组的大小</p>

<pre><code class="ruby">&gt;&gt; mixedArray = [1, "data", 2, "time", 3]
&gt;&gt; mixedArray.size     #=&gt; 5
</code></pre>

<!-- more -->


<p>遍历数组也很方便，利用each方法，ruby提供了两种书写方式。<em>each方法会返回原数组的值</em></p>

<pre><code class="ruby do/end代码块方式">&gt;&gt; mixedArray = [1, "data", 2, "time",3]
&gt;&gt; mixedArray.each do |value|
&gt;&gt; print "#{value} "
&gt;&gt; end

##将会打印出:1 data 2 time 3,并且返回mixedArray。
</code></pre>

<pre><code class="ruby {}代码块方式">&gt;&gt; mixedArray.each {
&gt;&gt; |value|
&gt;&gt; print "#{value} "
&gt;&gt; }
</code></pre>

<p>上面两种方式的输出结果和返回值都一样。建议采用第一种，更加符合Ruby的风格。</p>

<p><em>注:通过在终端输入<strong>irb &ndash;simple-promot</strong>，可以简化ruby交互式的提示输入，如上面的Ruby的提示输入符&#8217;>>&lsquo;</em></p>

<h3>散列</h3>

<p>Ruby中的键值(key-value pair)数据结构是用散列(hash)来表示，一般以字符串或者符号(Symbol)来作为键，值来保存对应的对象。</p>

<p><em>符号(symbol)</em>与字符串对象很相似，符号也是对象，一般都作为名称标签来使用。我们可以将符号简单理解为轻量级的字符串。</p>

<p>符号的定义只需在标识符的开头加上&#8217;:&lsquo;即可</p>

<pre><code class="ruby">&gt;&gt; sym1 = :text
&gt;&gt; sym2 = :"text"
</code></pre>

<p>以上两行代码都是表示符号&#8221;:foo&#8221;.</p>

<p>使用符号比使用字符串更有效率，而且符号与字符串可以互相任意转换, 用<strong>to_s</strong>和<strong>to_sym</strong>方法</p>

<pre><code class="ruby">&gt;&gt; sym = :text
=&gt; :text
&gt;&gt; sym.to_s         ##将符号转为话字符串
=&gt; "text"
&gt;&gt; "text".to_sym    ##将字符串转为符号
=&gt; :text
&gt;&gt;
</code></pre>

<p>如何定义一个散列，定义一个散列有下列两种写法:</p>

<pre><code class="ruby 散列定义方式一">&gt;&gt; details = {:name =&gt; "yu", :gender =&gt; "male", :alias =&gt; "stonefishy"}
=&gt; {:name=&gt;"yu", :gender=&gt;"male", :alias=&gt;"stonefishy"}
</code></pre>

<pre><code class="ruby 散列定义方式二">&gt;&gt; details = {name: "yu", gender: "male", alias: "stonefishy"}
=&gt; {:name=&gt;"yu", :gender=&gt;"male", :alias=&gt;"stonefishy"}
</code></pre>

<p>第二种方式和<em>json</em>数据的格式相似。</p>

<p>操作散列也很简单，直接看下面执行示例</p>

<pre><code class="ruby">&gt;&gt; details[:age] = 18               ##新增一个age值
=&gt; 18
&gt;&gt; details
=&gt; {:name=&gt;"yu", :gender=&gt;"male", :alias=&gt;"stonefishy", :age=&gt;18}
&gt;&gt; details[:name]                   ##获取指定键的值
=&gt; "yu"
&gt;&gt; details[:age] = 20               ##修改指定键的值
=&gt; 20
&gt;&gt; details
=&gt; {:name=&gt;"yu", :gender=&gt;"male", :alias=&gt;"stonefishy", :age=&gt;20}
</code></pre>

<p><em>注: =>符号表示ruby交互式模式的输出命令</em></p>

<p>使用each方法遍历散列：</p>

<pre><code class="ruby">&gt;&gt; details.each do |key, value|
?&gt; puts "#{key} - #{value}"
&gt;&gt; end
name - yu
gender - male
alias - stonefishy
age - 20
=&gt; {:name=&gt;"yu", :gender=&gt;"male", :alias=&gt;"stonefishy", :age=&gt;20}   ##each方法同样会返回散列
</code></pre>

<h3>正则表达式</h3>

<p>正则表达式(Regular Expression)的语法如下，</p>

<pre><code>/模式/
</code></pre>

<p>使用运算符=~来匹配正则表达式和字符串, 若匹配成功返回匹配部分的位置，匹配失败返回nil值。</p>

<pre><code>/模式/ =~ 希望匹配的字符串
</code></pre>

<pre><code class="ruby">&gt;&gt; /ruby/ =~ "hello, ruby"          ##包含‘ruby’字符串
=&gt; 7
&gt;&gt; /^ruby$/ =~ "hello, ruby"        ##完全匹配‘ruby’字符串
=&gt; nil
&gt;&gt; /ruby$/ =~ "hello, ruby"     ##以‘ruby’字符串结尾
=&gt; 7
</code></pre>

<p>正则表达式右边的/后面添加i表示不区分大小写匹配:</p>

<pre><code class="ruby">&gt;&gt; /RUby/i =~ "hello, ruby"
=&gt; 7
</code></pre>

<p>定义正则表达式还有另外一种方式，直接用<strong>Regexp</strong>类来创建:</p>

<pre><code class="ruby">pattern = Regexp.new("ruby")        ##定义一个正则表达式
=&gt; /ruby/
&gt;&gt; pattern =~ "hello, ruby"
=&gt; 7
</code></pre>

<p><em>注: 如果想更加详细的了解正则表达式的语法，可以查看使用<a href="http://rubular.com/">Rubular</a></em></p>

<h3>命令行参数</h3>

<p>Ruby中使用<strong>ARGV</strong>这个Ruby预定义好的数组来获取从命令行传递过来的数据。在命令行指定多个脚本参数时，各个参数之间用空格隔开。</p>

<p>使用<strong>each_with_index</strong>方法可以获取遍历的index，</p>

<pre><code class="ruby argv.rb">ARGV.each_with_index do |arg, index|
puts "第#{index + 1}个参数: #{arg}"
end
</code></pre>

<p>执行和输出结果如下:</p>

<pre><code>&gt; ruby argv.rb hello world and ruby ##命令行输入参数
=&gt; 第1个参数: hello
=&gt; 第2个参数: world
=&gt; 第3个参数: and
=&gt; 第4个参数: ruby
</code></pre>

<h3>文件读取</h3>

<p>Ruby中通过File类来读取文件，两种读取方式，一次性读取和逐行读取，示例如下,</p>

<pre><code class="ruby read_all_text.rb">file = File.open(ARGV[0])       ##打开文件
text = file.read                    ##读取文件中得所有文本数据
print text
file.close                      ##关闭文件句柄
</code></pre>

<pre><code class="ruby read_each_line_text.rb">file = File.open(ARGV[0])
file.each_line do |line|         ##逐行读取文件
    print line
end
file.close
</code></pre>

<h3>方法的定义</h3>

<p>Ruby方法的定义和Python一样简答，</p>

<pre><code>def 方法名
    希望处理的逻辑
end
</code></pre>

<p>我们现在将上面读取文件的代码定义在一个方法中，</p>

<pre><code class="ruby read_file.rb">def read_file(file_name)
    file = File.open(file_name)
    file.each_line do |line|
        print line
    end
end
</code></pre>

<p>现在我们想在其他文件里面使用上面定义的文件读取方法，那么该如何引用了，且看下，</p>

<h3>引用文件</h3>

<p>Ruby使用<strong>require</strong>方法来引用库或文件</p>

<pre><code>require 希望使用的库名
</code></pre>

<p><em>库名可以省略后缀.rb</em></p>

<pre><code class="ruby invoke_read_file.rb">require "./read_file"           ##引入读取文件的库
read_file("argv.rb");           ##直接调用库中的方法
</code></pre>

<p>执行示例：</p>

<pre><code>&gt; ruby invoke_read_file.rb
=&gt; ARGV.each_with_index do |arg, index|
=&gt; puts "第#{index + 1}个参数: #{arg}"
=&gt; end
</code></pre>

<h3>p与pp方法</h3>

<p>如前我们所介绍的打印数据到终端的有<strong>p</strong>, <strong>puts</strong>, <strong>print</strong>等方法，现在再介绍一种按数据排版打印的方法<strong>pp</strong>, 其全名为 pretty print。但是如果想使用该方法，需要使用require方法引入<strong>pp</strong>库。直接看示例</p>

<pre><code class="ruby p_and_pp.rb">require "pp"

details = [{content1: "This is content1", 
            content2: "This is content2", 
            content3: "This is content3"}]

puts "p的输出格式如下:"
p details

puts "pp的输出格式如下:"
pp details
</code></pre>

<p>执行示例:</p>

<pre><code>p的输出格式如下:
[{:content1=&gt;"This is content1", :content2=&gt;"This is content2", :content3=&gt;"This is content3"}]
pp的输出格式如下:
[{:content1=&gt;"This is content1",
  :content2=&gt;"This is content2",
  :content3=&gt;"This is content3"}]
</code></pre>

<p>与<strong>p</strong>方法的不同之处在于，<strong>pp</strong>方法在输出对象的结果时，为了更容易看懂，会适当的换行以调整输出结果。如上所示。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(1)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/08/12/ruby-practice-1/"/>
    <updated>2015-08-12T16:08:21+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/08/12/ruby-practice-1</id>
    <content type="html"><![CDATA[<p><img src="/assets/images/ruby-logo.png" width="50" height="50"><strong>Ruby</strong>是一门脚本语言，由日本人松本行弘发明，旨在让开发人员用更简洁的方式快乐的编程。他的语法类似Python脚本语言，比较优雅，而且还提供了一些丰富强大的类库。Ruby的意思是<strong>红宝石</strong>.</p>

<h3>特点</h3>

<p><em>脚本语言</em> <br/>
即动态语言，和其他脚本语言一样，无需编译即可直接运行，而C#、C++和Java等需要通过编译然后才能运行。Ruby减少了开发者的开发流程。</p>

<!-- more -->


<p><em>完全的面向对象</em><br/>
对Ruby来说，纯数字都属于对象，可以直接调用其方法。比如下面代码： <br/>
<code>
-1.abs   #return 1
</code></p>

<p>这是其他面向对象编程语言如C#、Java不具备的。同时Ruby也具备有其他面向对象编程语言的特性，如：继承、Mixin等。</p>

<p><em>跨平台</em> <br/>
能在类Unix操作系统如：Mac OS X、Linux和windows操作系统上运行。</p>

<h3>安装</h3>

<p>Ruby的安装很简单，以在Mac OS X电脑的安装为例。使用Homebrew包管理器可以得到ruby的最新版本: <br/>
<code>
brew install ruby
</code></p>

<p>安装完后，在输入如下命令查看ruby版本: <br/>
<code>
ruby -v
</code></p>

<p>进入<a href="https://www.ruby-lang.org/en/documentation/installation/">Ruby Installation</a>链接可以查看Ruby在其他操作系统上的安装</p>

<h3>HelloWorld</h3>

<p>用ruby编写第一个Hello world程序，只需一行代码，比其他的面向对象语言简单多了。 <br/>
<code>ruby
print("Hello world\n");
</code></p>

<p>直接将这行代码写入helloworld.rb文件，然后输入如下指令运行即可看到内容输出在终端控制器上。 <br/>
<code>
ruby helloworld.rb
</code></p>

<p>当然如果你想直接和ruby交互的话，也有办法，Ruby提供了和Python类似的交互式操作。在命令行输入<strong>irb</strong>进入交互模式。</p>

<p>ruby也提供了字符的转义功能，比如换行(\n), 制表符(\t)等等。如上面的打印Hello world。</p>

<p><em>注:上面代码中调用print方法的括号可以省略。ruby尽量的简化了开发人员的工作量</em></p>

<h3>puts、print和p的区别</h3>

<p><strong>puts</strong>方法会在每次输出后输出换行符，而<strong>print</strong>则不会。例如以下的输出内容是一致的:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">puts</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="no">Helle</span> <span class="n">world</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;print &amp;ldquo;Hello world\n&amp;rdquo;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>使用<strong>p</strong>方法可以将数据按照原始类型输出来，这是<strong>puts</strong>和<strong>print</strong>所不具备的，直接用代码来解释:
<code>ruby
puts "1"   #=&gt; 1
puts 1     #=&gt; 1
print 1    #=&gt; 1
print "1"  #=&gt; 1
p "1"      #=&gt; "1"
p 1        #=&gt; 1
</code></p>

<p>所以基于<strong>p</strong>方法的特性，转义字符在其内是不工作的，将会被直接打印出来,如以下代码将会输出&#8221;Hello world\n&#8221;。还有<strong>p</strong>方法也会输出换行符，并且还会将打印的内容按数据类型返回，而其他两种方法只返回<strong>nil</strong>空值。
<code>ruby
p "Hello world\n"  
</code></p>

<p><em>注:在Ruby中，任何函数均有返回值。<strong>nil</strong>空值就是其中一种常见的返回。</em></p>

<p><strong>print</strong>, <strong>puts</strong>和<strong>p</strong>方法均可传入多个参数，调用方式和返回结果如下，可以体会下用法:<br/>
<em>print方法</em>  <br/>
<code>ruby
print "Hello", " Ruby“
</code></p>

<pre><code>Hello Ruby
</code></pre>

<p><em>puts方法</em> <br/>
<code>ruby
puts "Hello", " Ruby"
</code></p>

<pre><code>Hello
Ruby
</code></pre>

<p><em>p方法</em>    <br/>
<code>ruby
p "Hello", " Ruby"
</code></p>

<pre><code>”Hello"
"Ruby"
</code></pre>

<h3>变量</h3>

<p>在ruby中声明变量也很简单，不需要任何如javascript的<em>var</em>等关键字，直接定义赋值。</p>

<pre><code class="ruby">greet = "Hello world"
</code></pre>

<p>访问变量也简单:</p>

<pre><code class="ruby">puts greet
puts "#{greet}"
</code></pre>

<p>以上两种写法均会直接输出Hello world.</p>

<h3>控制语句</h3>

<p><em>if 语句</em></p>

<pre><code>if 条件 then
    逻辑处理
end
</code></pre>

<p><em>if else 语句</em></p>

<pre><code>if 条件 then
    逻辑处理
else
    逻辑处理
end
</code></pre>

<p><em>if elsif 语句</em></p>

<pre><code>if 条件 then
    逻辑处理
elsif 条件 then
    逻辑处理
else
    逻辑处理
end
</code></pre>

<p><em>注:在上面的if各种控制语句中，<strong>then</strong>关键字是可以省略的.</em></p>

<h3>循环语句</h3>

<p><em>while 语句</em></p>

<pre><code>while 条件 do
    逻辑处理
end
</code></pre>

<p><em>times迭代器</em></p>

<p>当循环的次数已经确定时，可直接使用times方法来循环处理我们需要的逻辑
    I
    循环次数.times do
        逻辑处理
    end</p>

<p><em>注:<strong>times</strong>方法被成为迭代器，除了times方法迭代器，ruby还提供了其他的迭代器，比如<strong>each</strong>方法.</em></p>
]]></content>
  </entry>
  
</feed>
