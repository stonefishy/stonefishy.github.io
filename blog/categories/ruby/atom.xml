<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Stonefishy Blog]]></title>
  <link href="http://stonefishy.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://stonefishy.github.io/"/>
  <updated>2015-10-12T18:02:27+08:00</updated>
  <id>http://stonefishy.github.io/</id>
  <author>
    <name><![CDATA[Yu]]></name>
    <email><![CDATA[andrewsy@live.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(11)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/09/28/ruby-practice-11/"/>
    <updated>2015-09-28T10:33:41+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/09/28/ruby-practice-11</id>
    <content type="html"><![CDATA[<p>Ruby中所有表现数据的类型都称为数值类，他们都是<strong>Numeric</strong>的子类。起详尽的类继承结构如下：</p>

<p><img src="assets/images/numeric-inheritance.png" alt="assets/images/numberic-inheritance.png" /></p>

<!-- more -->


<p>Ruby中一般用到得整数都是在<strong>Fixnum</strong>类范围内的，如果超过了Fixnum的范围，Ruby会自动将其转换为<strong>Bignum</strong>类。</p>

<p>正如上图所示，Ruby可以处理有理数和复数，有理数用<strong>Rational</strong>类表示，复数用<strong>Complex</strong>类表示。其定义形式如下：</p>

<p>1.Rational对象</p>

<pre><code>Rational(分子，分母)
</code></pre>

<pre><code class="ruby">a = Rational(1, 3)      #=&gt; (1/3)
a.to_f                      #=&gt; 0.3333333
</code></pre>

<p>通过<em>Rational#to_f</em>方法可将有理数转为Float对象</p>

<p>2.Complex对象</p>

<pre><code>Complex(实数，虚数)
</code></pre>

<pre><code class="ruby">a = Complex(1, 2)       #=&gt; (1+2i)
</code></pre>

<p>单纯的数字罗列表示10进制整数。以0b开头的数值表示2进制数，以0或者0o开头的数值表示8进制数，以0d开头的数值表示10进制数，以0x开头的数值表示16进制数。字面量中的_会被自动忽略。</p>

<pre><code class="ruby">p 123           #=&gt; 123
p 1_23          #=&gt; 123
p 0123      #=&gt; 83
p 0o123     #=&gt; 83
p 0d123     #=&gt; 123
p 0x123     #=&gt; 291
</code></pre>

<p>Integer对象与Float对象的计算结果为Float对象。</p>

<p>x.<strong>div</strong>(y)
返回x除以y后的商的整数</p>

<pre><code class="ruby">p 5.div(2)  #=&gt; 2
p 5.div(2.2)    #=&gt; 2
</code></pre>

<p>x.<strong>quo</strong>(y)
返回x除以y后的商，如果x、y都是整数则返回Rational对象</p>

<pre><code class="ruby">p 5.quo(2)  #=&gt; (5/2)
p 5.quo(2.2)    #=&gt; 2.27272727
</code></pre>

<p>x.<strong>modulo</strong>(y)
返回x除以y后的余数，与<em>x % y</em>等价</p>

<pre><code class="ruby">p 5.modulo(2)           #=&gt; 1
p 5 % 2             #=&gt; 1
</code></pre>

<p>x.<strong>divmod</strong>(y)
将x除以y后的商和余数作为数组返回,余数的符号与y的符号一致。</p>

<pre><code class="ruby">p 5.divmod(2)           #=&gt; [2, 1]
p -5.divmod(2)      #=&gt; [-3, 1]
p 5.divmod(-2)      #=&gt; [-3, -1]
</code></pre>

<p>x.<strong>remainder</strong>(y)
返回x除以y的余数，结果的符号与x的符号一致</p>

<pre><code class="ruby">p 5.remainder(2)        #=&gt; 1
p 5.remainder(-2)   #=&gt; 1
p -5.remainder(2)   #=&gt; -1
</code></pre>

<p><em>注：当除数为0时，Integer类会返回错误，而Float类则会返回Infinity（无限大）或者NaN（Not a Number）。</em></p>

<pre><code class="ruby">p 1 / 0         #=&gt; ZeroDivisionError
p 1.0 / 0       #=&gt; Infinity
p 0 / 0.0           #=&gt; NaN
</code></pre>

<p>针对数值类型，Ruby提供<strong>Math</strong>模块增强数据的处理功能，包括三角函数，对数函数等常用的函数运算方法。通过调用如下方法可得到<strong>Math</strong>模块提供的方法</p>

<pre><code class="ruby">Math.methods
</code></pre>

<p><strong>to_f</strong>方法可将Integer对象转换为Float对象，<strong>to_i</strong>方法可将Float对象转换为Integer对象，to_i方法会将小数点以后的值去掉。通过使用<strong>round</strong>方法可对小数进行四舍五入的处理.<strong>ceil</strong>方法返回比比原数值大得最小整数，<strong>floor</strong>方法返回比原数值小的最大整数。通过<strong>to_r</strong>和<strong>to_c</strong>方法可将数值转换为Rational对象和Complex对象。</p>

<pre><code class="ruby">p 1.to_f            #=&gt; 1.0
p 1.23.to_i     #=&gt; 1
p 1.23.round        #=&gt; 1
p 1.50.round        #=&gt; 2
p 1.23.ceil     #=&gt; 2
p 1.23.floor        #=&gt; 1
p 1.5.to_r      #=&gt; (3/2)
p 1.5.to_c      #=&gt; (1.5+0i)
</code></pre>

<p>Integer类按照指定次数循环处理逻辑</p>

<p>执行指定的n次逻辑</p>

<pre><code>n.times do |i|
    逻辑
end
</code></pre>

<pre><code class="ruby">ary = []
5.times do |i|
    ary &lt;&lt; i
end
p ary               #=&gt; [0, 1, 2, 3, 4]
</code></pre>

<p>从<em>from</em>开始循环加对<em>i</em>进行加1处理，直到<em>i</em>等于<em>to</em></p>

<pre><code>from.upto(to) do |i|
    逻辑
end
</code></pre>

<pre><code class="ruby">ary = []
1.upto(5) do |i|
    ary &lt;&lt; i
end
p ary               #=&gt; [1, 2, 3, 4, 5]
</code></pre>

<p>从<em>from</em>开始循环对<em>i</em>进行减1处理，直到<em>i</em>等于<em>to</em></p>

<pre><code>from.downto(to) do |i|
    逻辑
end
</code></pre>

<pre><code class="ruby">ary = []
5.downto(1) do |i|
    ary &lt;&lt; i
end
p ary               #=&gt; [5, 4, 3, 2, 1]
</code></pre>

<p>从<em>from</em>开始循环对<em>i</em>进行加<em>step</em>处理，直到<em>i</em>等于<em>to</em></p>

<pre><code>from.step(to, step) do |i|
    逻辑
end
</code></pre>

<pre><code class="ruby">ary = []
1.step(5, 2) do |i|
    ary &lt;&lt; i
end
p ary               #=&gt; [1, 3, 5]
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(10)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/09/15/ruby-practice-10/"/>
    <updated>2015-09-15T15:18:16+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/09/15/ruby-practice-10</id>
    <content type="html"><![CDATA[<h3>块</h3>

<p><strong>块(block)</strong>，有时也称代码块，能与参数一起传递的多个处理的集合。像之前的<em>each</em>，<em>time</em>就是带块的方法。</p>

<pre><code class="ruby">(1..5).each do |i|
    puts i
end
</code></pre>

<p>上面代码中do和end之间的部分就是所谓的块。这样的方法称为“带块的方法”或“调用块”，其调用方式如下：</p>

<pre><code>对象.方法名(参数列表) do |变量|
    希望的处理
end

或者

对象.方法名(参数列表) { |变量|
    希望的处理
}
</code></pre>

<!-- more -->


<p>each方法可以将数组的元素一个一个取出来然后处理，散列也可以，但与数组不同的是，散列会将*[key,value]的组合作为数组来提取元素。</p>

<pre><code class="ruby">outcome = {"breakfast"=&gt;10.00, "lunch"=&gt;20.00, "dinner"=&gt;15.00 }
sum_outcome = 0
outcome.each do |pair|          #pair是key，value组成的数组，pair[0]为key，pair[1]为value
    sum_outcome += pair[1]
end

puts sum_outcome                    #=&gt; 45.0
</code></pre>

<p>在接收块变量时，多重赋值规则也同样适用。</p>

<pre><code class="ruby">outcome.each { |key, value|
    puts "#{key} : #{value}"    #=&gt; 打印对应的outcome信息
}
</code></pre>

<p>块除了应用于迭代器以外，还被广泛用于其他地方，其中一个就是确保后处理被执行。看代码</p>

<ul>
<li>(1)未使用块做后处理
<code>ruby file_open.rb
file = File.open("each_hash_data.rb")
file.each_line do |line|
  puts line
end
file.close
</code></li>
<li>(2)使用块做后处理
<code>ruby block_file_open.rb
File.open("each_hash_data.rb") do |file|
  file.each_line do |line|
      puts line
  end
end
</code>
仔细观察代码，你会发现在第种方式中，File#open方法接收了块，然后将file对象作为块变量，并且执行完毕后，并没有调用close方法去关闭文件。用这种方式会使程序出问题吗？答案是不会，因为块内部其实执行了如下代码的处理。</li>
</ul>


<pre><code class="ruby">file = File.open("each_hash_data.rb")
begin
    file.each_line do |line|
        puts line
    end
ensure
    file.close
end
</code></pre>

<p>块还有一种常见的用法，用于替换部分算法，以Array类的sort方法为例</p>

<pre><code class="ruby">ary = ["ruby", "pathon", "c#", "javascript"]

sorted_ary = ary.sort
print sorted_ary            #=&gt; ["c#", "javascript", "pathon", "ruby"]

sorted_ary = ary.sort { |a, b| a.length &lt;=&gt; b.length }
print sorted_ary            #=&gt; ["c#", "ruby", "pathon", "javascript"]

sorted_ary = ary.sort { |a, b| a.reverse &lt;=&gt; b.reverse}
print sorted_ary            #=&gt; ["c#", "pathon", "javascript", "ruby"]
</code></pre>

<p>将排序算法作为块传递给sort方法，然后返回按指定排序方式排序后的数组。</p>

<p><em>注意：块中最后一个表达式的值就是块的执行结果</em></p>

<h4>定义带块的方法</h4>

<p>使用<strong>yield</strong>关键字代替块，如下</p>

<pre><code class="ruby">def my_block
    yield
end

my_block do 
    puts "this is execution in my block"
end
</code></pre>

<h5>传递块参数，获取块的值</h5>

<pre><code class="ruby">def total(from, to)
    result = 0
    from.upto(to) do |num|
        if block_given?                 # 如果有快的话
            result += yield(num)        # 将经过块处理后的值累加
        else
            result += num
        end
    end
    result
end

print total(1, 10)                          #=&gt; 55
print total(1, 10) { |num| num * 2}     #=&gt; 110
</code></pre>

<p><strong>block_given?</strong>方法被用于判断当调用方法时是否有块被传递，有则返回true，否则false</p>

<p><em>yield</em>参数的个数可以与块变量的个数不一样，当块变量的个数多时，多出的参数会被赋值为nil，当块变量不足时，则不能接受多余的参数值。</p>

<p>*注：<strong>break</strong>和<strong>next</strong>方法可指定参数，如果没有指定任何参数，则返回nil，如果指定了参数则返回参数，如：break 0 和next 0 都会返回0。</p>

<h5>将块封装为对象</h5>

<p>Ruby还可以将块当作对象处理。把块当作对象处理后，就可以在接收块的方法之外的其他地方执行块，或者把块交给其他方法执行。如果要实现这样的功能，就需要<strong>Proc</strong>对象，<strong>Proc</strong>对象是能让块作为对象在程序中使用的类。</p>

<p>通过调用<strong>Proc.new</strong>这个带块的方法，可以定义Proc对象，然后再调用Proc对象的<strong>call</strong>方法执行块。</p>

<pre><code class="ruby">hello = Proc.new do |name|          # 使用Proc.new方法定义块对象hello
    puts "Hello #{name}"
end

hello.call("world")                 # 使用Proc.call方法调用块对象
hello.call("ruby")              
</code></pre>

<p>在方法定义时，如果末尾的参数使用<strong>&amp;参数名</strong>的形式，Ruby就会自动把调用方法时传进来的块封装为Proc对象。</p>

<pre><code class="ruby">def total(from, to, &amp;block)
    result = 0
    from.upto(to) do |num|
        if block                                #如果有块对象
            result += block.call(num)       #执行快对象
        else
            result += num
        end
    end
    result
end

puts total(1, 10)                           #=&gt; 55
puts total(1, 10) { |num| num * 2}      #=&gt; 110
</code></pre>

<p>在变量名前添加<strong>&amp;</strong>的参数被成为<strong>Proc参数</strong>. 而且Proc参数一定要在所有参数之后，也就是方法的最后一个参数。</p>

<p>将Proc对象作为块传递给其他方法处理，在调用方法时，用<strong>&amp;Proc对象</strong>的形式定义参数就可以了。</p>

<pre><code class="ruby">def my_each(ary, &amp;block)    
    ary.each(&amp;block)            #将proc对象以块的形式传递给数组的each方法
end

my_each([1, 2, 3]) do |i|
    print "#{i} "
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(9)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/09/09/ruby-practice-9/"/>
    <updated>2015-09-09T23:22:26+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/09/09/ruby-practice-9</id>
    <content type="html"><![CDATA[<h3>异常处理</h3>

<p>在Ruby中，抛出异常的信息格式如下：</p>

<pre><code>文件名：行号：in 方法名：错误信息 (异常类名)
        from 文件名：行号：in 方法名
</code></pre>

<p>以from开头的行表示发生错位的位置。
在Ruby中,使用<strong>begin ~ rescue ~ end</strong>语句来做异常处理，其语法如下：</p>

<pre><code>begin
    可能会发生异常的处理
rescue
    发生异常时的处理
end
</code></pre>

<pre><code class="ruby">begin
    1 / 0
rescue
    puts "has a exception"              #=&gt; has a exception
end
</code></pre>

<!-- more -->


<p>通过在<strong>rescue</strong>后指定变量名，可以获得异常对象。异常对象有两个方法，方法名为<strong>class</strong>、<strong>message</strong>、<strong>backtrace</strong>。</p>

<ul>
<li><strong>class</strong>方法可以获取到异常的种类</li>
<li><strong>message</strong>方法获取异常信息。</li>
<li><p><strong>backtrace</strong>方法获取异常发生的位置信息</p>

<p>  begin
      可能会发生的异常的处理
  rescue =>   引用异常对象的变量
      发生异常时的处理
  end</p></li>
</ul>


<pre><code class="ruby">begin
    1 / 0
rescue =&gt; ex                                #=&gt; 将异常对象引用到ex对象
    puts ex.class                           #=&gt; ZeroDivisionError
    puts ex.message                     #=&gt; divided by 0
    puts ex.backtrace                   #=&gt; exception.rb:2:in `/'exception.rb:2:in `&lt;main&gt;'
end
</code></pre>

<p><em>Note：此处是将代码直接写在ruby文件里，然后直接运行的，没有写在方法里面。所以看到的信息是文件名和发生错误的行号</em></p>

<p>如果不指定变量名，Ruby将会把异常对象赋值给<strong>$!</strong>、<strong>$2</strong>变量</p>

<ul>
<li><strong>$!</strong> 引用到最后发生的异常对象</li>
<li><strong>$@</strong> 引用到发生的异常的位置信息</li>
</ul>


<pre><code class="ruby">begin
    1 / 0
rescue
    puts $!.class                           #=&gt; ZeroDivisionError
    puts $!.message                     #=&gt; divided by 0
    puts $!.backtrace                   #=&gt; exception.rb:2:in `/'exception.rb:2:in `&lt;main&gt;'
    puts $@                             #=&gt; exception.rb:2:in `/'exception.rb:2:in `&lt;main&gt;'
end
</code></pre>

<p>从上面的运行示例可以看出，其实<strong>$!.backtrace</strong>与<strong>$@</strong>是等价的，都表示异常发生的位置。</p>

<p>在Ruby中可以通过<strong>ensure</strong>来确保无论是否引发异常都将执行处理，类似于Java和C#中得finally。</p>

<pre><code>begin
    可能发生的异常
rescue =&gt; 变量
    发生异常时的处理
ensure
    无论是否有异常，都会处理
end
</code></pre>

<pre><code class="ruby">def copy(from to)
    src = File.open(from)
    begin
        dst = File.open(to, 'w')
        data = src.read
        dst.write(data)
        dst.close
    rescue =&gt; ex
        print ex.message
    ensure
        src.close
    end
end
</code></pre>

<p>在<strong>rescue</strong>中使用<strong>retry</strong>后，<strong>begin</strong>以下的处理会再重做一遍。所以需要注意陷入死循环的情况。</p>

<pre><code class="ruby">count = 0
num = 0
begin
    1 / num                     #=&gt; 如果发生异常，则执行rescue中的语句
rescue
    if count &gt;= 5
        num += 1
    end

    count += 1

    retry                           #=&gt; 重复执行begin后的语句
end

puts count                      #=&gt; 6
</code></pre>

<h4>使用rescue做为修饰符</h4>

<p>使用rescue作为修饰符可以简化很多代码</p>

<pre><code>表达式1 rescue 表达式2
</code></pre>

<p>与下面的写法等价</p>

<pre><code>begin
    表达式1
rescue
    表达式2
end
</code></pre>

<p>其意义为如果表达式1中发生异常，表达式2的值就会成为整体表达式的值。</p>

<pre><code class="ruby">def parseInt(param)
    Integer(param) rescue 0     #=&gt; 如果Integer(param)语句无异常，直接返回该值，否者返回0
end

puts parseInt("123")            #=&gt; 123
puts parseInt("abc")            #=&gt; 0
</code></pre>

<p>在判断字符串是否为数值形式时，可以使用这种方法。</p>

<h4>异常处理的其他语法</h4>

<p><em>方法内</em>
如果异常处理的范围是整个方法体，这时可以省略begin以及end关键字，直接使用rescue和ensure。</p>

<pre><code>def 方法名
    方法体
rescue =&gt; 异常对象
    异常处理
ensure
    后处理
end
</code></pre>

<p><em>类定义中</em>
在类定义中也可以使用rescue以及ensure。但是，如果类定义途中发生异常，那么异常发生部分后的方法定义就不会再执行了。所以一般很少在类定义中使用。</p>

<pre><code>class 类名
    类定义
rescue =&gt; 异常对象
    异常处理
ensure
    后处理
end
</code></pre>

<h4>指定需要捕捉的异常</h4>

<p>当然，Ruby也提供了针对特定异常的捕捉处理，可以使用多个rescue来分开处理</p>

<pre><code>begin
    可能发生异常的地方
rescue Exception1, Exception2 =&gt;变量
    对Exception1或Exception2的处理
rescue Exception3 =&gt; 变量
    对Exception3的处理
rescue
    对上述异常以外的异常的处理
end
</code></pre>

<pre><code class="ruby">def multi_rescue 
    begin
        yield                   #块参数在此处，如有异常，将执行后续指定的异常处理
    rescue NameError, NoMethodError =&gt; ex
        puts ex.class
    rescue ZeroDivisionError
        puts $!.class
    rescue 
        puts $!.class
    end
end

multi_rescue do 
    1 / 0                           #触发ZeroDivisionError异常
end

multi_rescue do
    val.size                        #触发NameError异常
end

multi_rescue do 
    val = 4
    sqrt(val)                       #触发NoMethodError异常  
end
</code></pre>

<p>以上代码定义了一个带块的方法，通过此方法可以插入任何你想要得代码执行块。</p>

<h4>异常类</h4>

<p><em>注意：ruby中所有异常都是</em>Exception<em>类的子类。</em>
当rescue中不指定异常类时，程序会默认捕捉<em>StandardError</em>类及其子类的异常. 所以在定义自己的异常时，可以先定义继承StandardError类的新类，然后再继承这个新类。</p>

<pre><code class="ruby">MyError = Class.new(StandardError)

class MyError &lt; StandardError
end
</code></pre>

<p>上面两种写法是等效的，都是表示定义一个继承StandardError类的新类。第一种方式是一种简洁的写法。</p>

<pre><code class="ruby">MyError = Class.new(StandardError)      #自定义MyError异常

#自定义MyError1异常继承自MyError，并重写message方法
class MyError1 &lt; MyError
    def message
        "the exception message is from MyError1"
    end
end

#自定义MyError2异常继承自MyError，并重写message方法
class MyError2 &lt; MyError
    def message
        "the exception message is from MyError2"
    end
end

#定义带块的处理异常的方法
def raiseException
    yield
rescue MyError1 =&gt; ex
    puts ex.message
rescue MyError2 =&gt; ex
    puts ex.message
rescue
    puts $!.message
end

#抛出异常MyError1
raiseException do
    raise MyError1      #=&gt; the exception message is from MyError1      
end

#抛出异常MyError2   
raiseException do
    raise MyError2      #=&gt; the exception message is from MyError2
end
</code></pre>

<h4>抛出异常</h4>

<p>使用<strong>raise</strong>方法，可以使程序主动抛出异常。</p>

<p>raise方法有一下4中调用方式：</p>

<ul>
<li><p>raise message
抛出<em>RuntimeError</em>异常，并把字符串作为message设置给新生成的异常对象</p></li>
<li><p>raise 异常类
抛出指定的异常</p></li>
<li><p>raise 异常类，message
抛出指定的异常，并把message信息设置给新生成的异常对象</p></li>
<li><p>raise
在rescue外抛出RuntimeError。 在rescue中调用时，会再次抛出最后一次发生的异常。</p></li>
</ul>


<pre><code class="ruby">#自定义MyError3异常
MyError3 = Class.new(MyError

raiseException do
    raise MyError3, "customized message for MyError3"   #=&gt;抛出指定message
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(8)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/09/06/ruby-practice-8/"/>
    <updated>2015-09-06T20:36:07+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/09/06/ruby-practice-8</id>
    <content type="html"><![CDATA[<h3>运算符</h3>

<p>以下两种运算符是等价的, op即代表操作运算符</p>

<pre><code>value1 op= value2
value1 = value1 op value2
</code></pre>

<p>利用运算符<strong>||</strong>的特性，可以简化相关的赋值代码，如下是等价的
<code>ruby 赋值方式1
name = "Ruby"
if var              #当var不是nil或false时
    name = var
end
</code></p>

<pre><code class="ruby 赋值方式2">name = var || "Ruby"
</code></pre>

<!-- more -->


<p>而利用<strong>&amp;&amp;</strong>运算符，可以避免不必要要得程序错误</p>

<pre><code class="ruby 隐藏的错误">name = ary[0]          #如果ary为nil，则此时将引发程序错误
</code></pre>

<pre><code class="ruby 使用&&避免错误">name = ary &amp;&amp; ary[0]    #避免当ary为nil时，读取ary[0]时的错误
</code></pre>

<p>使用<strong>&amp;&amp;</strong>可以在确定对象存在后再调用方法。而且代码更加简洁。</p>

<h4>范围运算符</h4>

<p>相比其他的语言如Java等，范围运算符算是一个比较特殊的运算符，范围运算符有<strong>..</strong>和<strong>&hellip;</strong>两种，其区别在于如下</p>

<ul>
<li><strong>x..y</strong>的范围是从x到y</li>
<li><strong>x&hellip;y</strong>的范围是从x到y得前一个元素</li>
</ul>


<pre><code class="ruby">(1..5).to_a             #=&gt; [1, 2, 3, 4, 5]
("a".."d").to_a         #=&gt; ["a", "b", "c", "d"]

(1...5).to_a                #=&gt; [1, 2, 3, 4]
("a"..."d").to_a            #=&gt; ["a", "b", "c"]
</code></pre>

<p>Ruby中有范围对象(Range)来表示范围对象，以下两个写法是等价的</p>

<pre><code class="ruby">ary = Range.new(1, 5)   #=&gt; 1..5
ary.class                   #=&gt; Range


ary = 1..5              #=&gt; 1..5
ary.class                   #=&gt; Range
</code></pre>

<p>在Range对象内部，可以使用<strong>succ</strong>方法根据起点值逐个生成下一值</p>

<pre><code class="ruby">a = 1
a = a.succ                  #=&gt; 2
a = a.succ                  #=&gt; 3
a.succ.succ                 #=&gt; 5
</code></pre>

<h4>运算符重定义</h4>

<p>在Ruby中有以下运算符不能重定义
::, &amp;&amp;, ||, .., &hellip;, ?:, not, =, and</p>

<p><em>二元运算符重定义</em>,如加号+、减号-</p>

<pre><code class="ruby">class Point
    attr_reader :x, :y

    def initialize(x, y)
        @x, @y = x, y
    end

    def +(other)
        self.class.new(x + other.x, y + other.y)
    end

    def -(other)
        self.class.new(x - other.x, y - other.y)
    end

    def display
        "(#{x}, #{y})"
    end
end

p1 = Point.new(1, 2)
p2 = Point.new(3, 4)
p = p1 + p2
puts p.display                  #=&gt; (4, 6)

p = p2 - p1
puts p.display                  #=&gt; (2, 2)
</code></pre>

<p><em>一元运算符</em>，如正号+，负号-等，其重定义与二元运算符不同。可定义的一元运算符有<strong>+</strong>, <strong>-</strong>, <strong>~</strong>, <strong>!</strong>4个。分别以+@， -@， ~@， !@为方法名进行方法定义。而且一元运算符都是没有参数的。</p>

<pre><code class="ruby">class Point
    attr_reader :x, :y

    def initialize(x, y)
        @x, @y = x, y
    end

    def +@
        dup
    end

    def -@
        self.class.new(-x ,-y)
    end

    def ~@
        self.class.new(-y, x)
    end

    def display
        "(#{x}, #{y})"
    end
end

p1 = Point.new(1, 2)
puts (-p1).display              #=&gt; (-1, -2)
puts (+p1).display              #=&gt; (1, 2)
</code></pre>

<h4>下标方法</h4>

<p>数组、散列中的<em>obj[i]</em>以及<em>obj[i]=x</em>这样的方法，称为下标方法。定义下标方法时的方法名分别为<strong>[]</strong>和<strong>[]=</strong>.</p>

<pre><code class="ruby">class Point
    attr_reader :x, :y

    def initialize(x, y)
        @x, @y = x, y
    end

    def [](index)
        case index
        when 0
            x
        when 1
            y
        else
            raise ArgumentError, "out of range (#{index})"
        end
    end

    def []=(index, val)
        case index
        when 0
            self.x = val
        when 1
            self.y = val
        else
            raise ArgumentError, "out of range (#{index})"
        end
    end


    def display
        "(#{x}, #{y})"
    end
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(7)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/09/01/ruby-practice-7/"/>
    <updated>2015-09-01T09:06:53+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/09/01/ruby-practice-7</id>
    <content type="html"><![CDATA[<h3>模块</h3>

<p>Ruby中的类是表现事物的属性和行为，那么模块呢？，在Ruby中<em>模块</em>表现的只是事物的行为。</p>

<p>模块与类的区别于下：</p>

<ul>
<li>模块不能拥有实例</li>
<li>模块不能被继承</li>
</ul>


<p>如何访问模块内的方法？有两种方式可以访问</p>

<p>1.使用<strong>模块名.方法名</strong>的形式来直接调用模块中定义的方法。</p>

<pre><code class="ruby">Math.sqrt(4)            #=&gt; 2.0
</code></pre>

<!-- more -->


<p>2.通过<strong>include 模块名</strong>的形式预先将模块引入到当前的命名空间，然后就可直接访问模块内的方法和常量。</p>

<pre><code class="ruby">include Math
sqrt(4)             #=&gt; 2.0
</code></pre>

<p>第二种方式也就是<strong>Mix-in</strong>扩展类的功能，将模块混合到类中。在定义类时使用<strong>include</strong>引入指定的模块后，此时该类就可以使用模块里的所有方法和常量，从而增加了该类的功能。</p>

<p><strong>Mix-in</strong>可以灵活地解决以下问题：</p>

<ul>
<li>虽然两个类拥有相似的功能，但是不希望把他们作为相同的种类（Class）来考虑的时候，此时可将相似功能封装为模块供这两个类使用</li>
<li>Ruby不支持父类的多重继承，因此无法对已经继承的类添加共同的功能的时候</li>
</ul>


<pre><code class="ruby">class Calculator
    include Math
    def my_sqrt(a, b)
        sqrt(a) + sqrt(b)           #=&gt; 调用Math模块中得sqrt方法
    end

    @@PI = PI
end

cal = Calculator.new
cal.my_sqrt(1, 4)                   #=&gt; 3.0
Calculator::PI                      #=&gt; 3.141592653589793
</code></pre>

<h4>创建模块</h4>

<p>使用<strong>module</strong>关键来创建模块，模块名的首字母必须大写</p>

<pre><code>module 模块名
    模块定义
end
</code></pre>

<pre><code class="ruby">module HelloModule
    Version = "1.0"

    def say_hello(name)
        puts "Hello #{name}"
    end

    module_function :say_hello
end

p HelloModule::Version                  #=&gt; "1.0"
HelloModule.say_hello("Ruby")           #=&gt; Hello Ruby

include HelloModule                     #=&gt; 包含模块
Version                                 #=&gt; "1.0"
say_hello("Ruby")                       #=&gt; Hello Ruby
</code></pre>

<p>在上面代码中，我们可以看到<strong>module_function</strong>方法，此方法主要用于将需要把模块函数公开给外部使用，其参数是表示方法方法名的符号，可以跟多个参数。</p>

<p><em>注：不建议在定义为模块函数的方法中使用self</em></p>

<h4>Mix-in</h4>

<p>前面提到的，在类中使用<em>include</em>引入模块，此时类的功能将得到增强。</p>

<p>如果想知道类是否包含某个模块，可以使用<strong>include？</strong>方法，如之前的Calculator类中。</p>

<pre><code class="ruby">Calculator.include?(Math)               #=&gt; true
</code></pre>

<p>Ruby中类的实例在调用方法时的顺序为，该类>包含的模块>该类的父类等这个顺序查找该方法。</p>

<pre><code class="ruby">module HelloModule
    Version = "1.0"

    def say_hello(name)
        puts "Hello #{name}"
    end
end

class HelloClass
    include HelloModule
end

hello = HelloClass.new
hello.say_hello("Ruby")                 #=&gt; Hello Ruby
</code></pre>

<p>以上代码中调用的是module中的方法。</p>

<p>用<em>ancestors</em>方法和<em>superclass</em>方法调查类的继承关系。<em>superclass</em>方法可直接返回类的父类</p>

<pre><code class="ruby">p HelloClass.ancestors                  #=&gt; [HelloClass, HelloModule, Object, Kernel, BasicObject]
p HelloClass.superclass                 #=&gt; Object
</code></pre>

<p><em>Kenerl</em>是Ruby内部的一个核心模块，Ruby程序运行时所需的共通函数都封装在此模块中。</p>

<p>单一继承的优点就是简单，不会因为过多的继承而导致类之间的关系变得复杂。所以我们需要灵活使用单一继承和Mix-in。</p>

<h4>Mix-in查找方法的规则</h4>

<ul>
<li>优先使用原来中定义的同名方法。</li>
<li>在同一个类中包含多个模块时，优先使用最后一个包含的模块。</li>
<li>嵌套include时，查找顺序也是线性的。</li>
<li>相同的模块被包含两次也上的，第2次以后的会被省略。</li>
</ul>


<h4>Object#extend方法</h4>

<p>利用Object#extend方法可以使单例类包含模块，并把模块的功能扩展到对象中。</p>

<pre><code class="ruby">module Welcome
    def welcome(name)
        "#{self} Welcome #{name}"
    end
end

str = "World"
str.extend(Welcome)                     #=&gt; 将Welcome模块扩展到str对象上
puts str.welcome("Ruby")                #=&gt; World Welcome Ruby
</code></pre>

<p><strong>include</strong>可以帮助我们突破继承的限制，通过模块扩展类的功能；而<strong>extend</strong>则可以帮助我们跨过类，直接通过模块扩展对象的功能.</p>

<p>所有类本身都是Class类的对象，类方法就是类对象的实例方法。可以把类方法理解为下:</p>

<ul>
<li><strong>Class</strong>类的实例方法</li>
<li>类对象的单例方法</li>
</ul>


<p>使用<strong>extend</strong>方法为类对象追加类方法，使用<strong>include</strong>方法追加实例方法。</p>

<pre><code class="ruby">module ClassMethod
    def class_method
        "class method"
    end
end

module InstanceMethod
    def instance_method
        "instance method"
    end
end

class MyClass
    extend ClassMethod                  #使用extend方法定义类方法
    include InstanceMethod              #使用include定义实例方法
end

p MyClass.class_method                  #=&gt; "class method"
p MyClass.new.instance_method           #=&gt; "instance method"
</code></pre>
]]></content>
  </entry>
  
</feed>
