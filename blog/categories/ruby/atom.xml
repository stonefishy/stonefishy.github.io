<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Stonefishy Blog]]></title>
  <link href="http://stonefishy.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://stonefishy.github.io/"/>
  <updated>2015-08-14T17:45:23+08:00</updated>
  <id>http://stonefishy.github.io/</id>
  <author>
    <name><![CDATA[Yu]]></name>
    <email><![CDATA[andrewsy@live.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(2)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/08/13/ru-practice-2/"/>
    <updated>2015-08-13T13:35:15+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/08/13/ru-practice-2</id>
    <content type="html"><![CDATA[<h3>数组</h3>

<p>Ruby中数组的大小是按实际情况自动调整的，即所谓的<strong>动态数组</strong></p>

<pre><code class="ruby">&gt;&gt; rubyArray = ["data1", "data2"]   ##定义两个数据的数组
&gt;&gt; rubyArray[2] = "data3"           ##新增第三个数据
&gt;&gt; print rubyArray                  ##打印["data1", "data2", "data3"]
</code></pre>

<p>Ruby数组还支持多种不同对象的混合保存, 通过<strong>数组.size</strong>可获取数组的大小</p>

<pre><code class="ruby">&gt;&gt; mixedArray = [1, "data", 2, "time", 3]
&gt;&gt; mixedArray.size     #=&gt; 5
</code></pre>

<!-- more -->


<p>遍历数组也很方便，利用each方法，ruby提供了两种书写方式。<em>each方法会返回原数组的值</em></p>

<pre><code class="ruby do/end代码块方式">&gt;&gt; mixedArray = [1, "data", 2, "time",3]
&gt;&gt; mixedArray.each do |value|
&gt;&gt; print "#{value} "
&gt;&gt; end

##将会打印出:1 data 2 time 3,并且返回mixedArray。
</code></pre>

<pre><code class="ruby {}代码块方式">&gt;&gt; mixedArray.each {
&gt;&gt; |value|
&gt;&gt; print "#{value} "
&gt;&gt; }
</code></pre>

<p>上面两种方式的输出结果和返回值都一样。建议采用第一种，更加符合Ruby的风格。</p>

<p><em>注:通过在终端输入<strong>irb &ndash;simple-promot</strong>，可以简化ruby交互式的提示输入，如上面的Ruby的提示输入符&#8217;>>&lsquo;</em></p>

<h3>散列</h3>

<p>Ruby中的键值(key-value pair)数据结构是用散列(hash)来表示，一般以字符串或者符号(Symbol)来作为键，值来保存对应的对象。</p>

<p><em>符号(symbol)</em>与字符串对象很相似，符号也是对象，一般都作为名称标签来使用。我们可以将符号简单理解为轻量级的字符串。</p>

<p>符号的定义只需在标识符的开头加上&#8217;:&lsquo;即可</p>

<pre><code class="ruby">&gt;&gt; sym1 = :text
&gt;&gt; sym2 = :"text"
</code></pre>

<p>以上两行代码都是表示符号&#8221;:foo&#8221;.</p>

<p>使用符号比使用字符串更有效率，而且符号与字符串可以互相任意转换, 用<strong>to_s</strong>和<strong>to_sym</strong>方法</p>

<pre><code class="ruby">&gt;&gt; sym = :text
=&gt; :text
&gt;&gt; sym.to_s         ##将符号转为话字符串
=&gt; "text"
&gt;&gt; "text".to_sym    ##将字符串转为符号
=&gt; :text
&gt;&gt;
</code></pre>

<p>如何定义一个散列，定义一个散列有下列两种写法:</p>

<pre><code class="ruby 散列定义方式一">&gt;&gt; details = {:name =&gt; "yu", :gender =&gt; "male", :alias =&gt; "stonefishy"}
=&gt; {:name=&gt;"yu", :gender=&gt;"male", :alias=&gt;"stonefishy"}
</code></pre>

<pre><code class="ruby 散列定义方式二">&gt;&gt; details = {name: "yu", gender: "male", alias: "stonefishy"}
=&gt; {:name=&gt;"yu", :gender=&gt;"male", :alias=&gt;"stonefishy"}
</code></pre>

<p>第二种方式和<em>json</em>数据的格式相似。</p>

<p>操作散列也很简单，直接看下面执行示例</p>

<pre><code class="ruby">&gt;&gt; details[:age] = 18               ##新增一个age值
=&gt; 18
&gt;&gt; details
=&gt; {:name=&gt;"yu", :gender=&gt;"male", :alias=&gt;"stonefishy", :age=&gt;18}
&gt;&gt; details[:name]                   ##获取指定键的值
=&gt; "yu"
&gt;&gt; details[:age] = 20               ##修改指定键的值
=&gt; 20
&gt;&gt; details
=&gt; {:name=&gt;"yu", :gender=&gt;"male", :alias=&gt;"stonefishy", :age=&gt;20}
</code></pre>

<p><em>注: =>符号表示ruby交互式模式的输出命令</em></p>

<p>使用each方法遍历散列：</p>

<pre><code class="ruby">&gt;&gt; details.each do |key, value|
?&gt; puts "#{key} - #{value}"
&gt;&gt; end
name - yu
gender - male
alias - stonefishy
age - 20
=&gt; {:name=&gt;"yu", :gender=&gt;"male", :alias=&gt;"stonefishy", :age=&gt;20}   ##each方法同样会返回散列
</code></pre>

<h3>正则表达式</h3>

<p>正则表达式(Regular Expression)的语法如下，</p>

<pre><code>/模式/
</code></pre>

<p>使用运算符=~来匹配正则表达式和字符串, 若匹配成功返回匹配部分的位置，匹配失败返回nil值。</p>

<pre><code>/模式/ =~ 希望匹配的字符串
</code></pre>

<pre><code class="ruby">&gt;&gt; /ruby/ =~ "hello, ruby"          ##包含‘ruby’字符串
=&gt; 7
&gt;&gt; /^ruby$/ =~ "hello, ruby"        ##完全匹配‘ruby’字符串
=&gt; nil
&gt;&gt; /ruby$/ =~ "hello, ruby"     ##以‘ruby’字符串结尾
=&gt; 7
</code></pre>

<p>正则表达式右边的/后面添加i表示不区分大小写匹配:</p>

<pre><code class="ruby">&gt;&gt; /RUby/i =~ "hello, ruby"
=&gt; 7
</code></pre>

<p>定义正则表达式还有另外一种方式，直接用<strong>Regexp</strong>类来创建:</p>

<pre><code class="ruby">pattern = Regexp.new("ruby")        ##定义一个正则表达式
=&gt; /ruby/
&gt;&gt; pattern =~ "hello, ruby"
=&gt; 7
</code></pre>

<p><em>注: 如果想更加详细的了解正则表达式的语法，可以查看使用<a href="http://rubular.com/">Rubular</a></em></p>

<h3>命令行参数</h3>

<p>Ruby中使用<strong>ARGV</strong>这个Ruby预定义好的数组来获取从命令行传递过来的数据。在命令行指定多个脚本参数时，各个参数之间用空格隔开。</p>

<p>使用<strong>each_with_index</strong>方法可以获取遍历的index，</p>

<pre><code class="ruby argv.rb">ARGV.each_with_index do |arg, index|
puts "第#{index + 1}个参数: #{arg}"
end
</code></pre>

<p>执行和输出结果如下:</p>

<pre><code>&gt; ruby argv.rb hello world and ruby ##命令行输入参数
=&gt; 第1个参数: hello
=&gt; 第2个参数: world
=&gt; 第3个参数: and
=&gt; 第4个参数: ruby
</code></pre>

<h3>文件读取</h3>

<p>Ruby中通过File类来读取文件，两种读取方式，一次性读取和逐行读取，示例如下,</p>

<pre><code class="ruby read_all_text.rb">file = File.open(ARGV[0])       ##打开文件
text = file.read                    ##读取文件中得所有文本数据
print text
file.close                      ##关闭文件句柄
</code></pre>

<pre><code class="ruby read_each_line_text.rb">file = File.open(ARGV[0])
file.each_line do |line|         ##逐行读取文件
    print line
end
file.close
</code></pre>

<h3>方法的定义</h3>

<p>Ruby方法的定义和Python一样简答，</p>

<pre><code>def 方法名
    希望处理的逻辑
end
</code></pre>

<p>我们现在将上面读取文件的代码定义在一个方法中，</p>

<pre><code class="ruby read_file.rb">def read_file(file_name)
    file = File.open(file_name)
    file.each_line do |line|
        print line
    end
end
</code></pre>

<p>现在我们想在其他文件里面使用上面定义的文件读取方法，那么该如何引用了，且看下，</p>

<h3>引用文件</h3>

<p>Ruby使用<strong>require</strong>方法来引用库或文件</p>

<pre><code>require 希望使用的库名
</code></pre>

<p><em>库名可以省略后缀.rb</em></p>

<pre><code class="ruby invoke_read_file.rb">require "./read_file"           ##引入读取文件的库
read_file("argv.rb");           ##直接调用库中的方法
</code></pre>

<p>执行示例：</p>

<pre><code>&gt; ruby invoke_read_file.rb
=&gt; ARGV.each_with_index do |arg, index|
=&gt; puts "第#{index + 1}个参数: #{arg}"
=&gt; end
</code></pre>

<h3>p与pp方法</h3>

<p>如前我们所介绍的打印数据到终端的有<strong>p</strong>, <strong>puts</strong>, <strong>print</strong>等方法，现在再介绍一种按数据排版打印的方法<strong>pp</strong>, 其全名为 pretty print。但是如果想使用该方法，需要使用require方法引入<strong>pp</strong>库。直接看示例</p>

<pre><code class="ruby p_and_pp.rb">require "pp"

details = [{content1: "This is content1", 
            content2: "This is content2", 
            content3: "This is content3"}]

puts "p的输出格式如下:"
p details

puts "pp的输出格式如下:"
pp details
</code></pre>

<p>执行示例:</p>

<pre><code>p的输出格式如下:
[{:content1=&gt;"This is content1", :content2=&gt;"This is content2", :content3=&gt;"This is content3"}]
pp的输出格式如下:
[{:content1=&gt;"This is content1",
  :content2=&gt;"This is content2",
  :content3=&gt;"This is content3"}]
</code></pre>

<p>与<strong>p</strong>方法的不同之处在于，<strong>pp</strong>方法在输出对象的结果时，为了更容易看懂，会适当的换行以调整输出结果。如上所示。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(1)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/08/12/ruby-practice-1/"/>
    <updated>2015-08-12T16:08:21+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/08/12/ruby-practice-1</id>
    <content type="html"><![CDATA[<p><img src="/assets/images/ruby-logo.png" width="50" height="50"><strong>Ruby</strong>是一门脚本语言，由日本人松本行弘发明，旨在让开发人员用更简洁的方式快乐的编程。他的语法类似Python脚本语言，比较优雅，而且还提供了一些丰富强大的类库。Ruby的意思是<strong>红宝石</strong>.</p>

<h3>特点</h3>

<p><em>脚本语言</em> <br/>
即动态语言，和其他脚本语言一样，无需编译即可直接运行，而C#、C++和Java等需要通过编译然后才能运行。Ruby减少了开发者的开发流程。</p>

<!-- more -->


<p><em>完全的面向对象</em><br/>
对Ruby来说，纯数字都属于对象，可以直接调用其方法。比如下面代码： <br/>
<code>
-1.abs   #return 1
</code></p>

<p>这是其他面向对象编程语言如C#、Java不具备的。同时Ruby也具备有其他面向对象编程语言的特性，如：继承、Mixin等。</p>

<p><em>跨平台</em> <br/>
能在类Unix操作系统如：Mac OS X、Linux和windows操作系统上运行。</p>

<h3>安装</h3>

<p>Ruby的安装很简单，以在Mac OS X电脑的安装为例。使用Homebrew包管理器可以得到ruby的最新版本: <br/>
<code>
brew install ruby
</code></p>

<p>安装完后，在输入如下命令查看ruby版本: <br/>
<code>
ruby -v
</code></p>

<p>进入<a href="https://www.ruby-lang.org/en/documentation/installation/">Ruby Installation</a>链接可以查看Ruby在其他操作系统上的安装</p>

<h3>HelloWorld</h3>

<p>用ruby编写第一个Hello world程序，只需一行代码，比其他的面向对象语言简单多了。 <br/>
<code>ruby
print("Hello world\n");
</code></p>

<p>直接将这行代码写入helloworld.rb文件，然后输入如下指令运行即可看到内容输出在终端控制器上。 <br/>
<code>
ruby helloworld.rb
</code></p>

<p>当然如果你想直接和ruby交互的话，也有办法，Ruby提供了和Python类似的交互式操作。在命令行输入<strong>irb</strong>进入交互模式。</p>

<p>ruby也提供了字符的转义功能，比如换行(\n), 制表符(\t)等等。如上面的打印Hello world。</p>

<p><em>注:上面代码中调用print方法的括号可以省略。ruby尽量的简化了开发人员的工作量</em></p>

<h3>puts、print和p的区别</h3>

<p><strong>puts</strong>方法会在每次输出后输出换行符，而<strong>print</strong>则不会。例如以下的输出内容是一致的:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">puts</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="no">Helle</span> <span class="n">world</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="p">;</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;print &amp;ldquo;Hello world\n&amp;rdquo;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>使用<strong>p</strong>方法可以将数据按照原始类型输出来，这是<strong>puts</strong>和<strong>print</strong>所不具备的，直接用代码来解释:
<code>ruby
puts "1"   #=&gt; 1
puts 1     #=&gt; 1
print 1    #=&gt; 1
print "1"  #=&gt; 1
p "1"      #=&gt; "1"
p 1        #=&gt; 1
</code></p>

<p>所以基于<strong>p</strong>方法的特性，转义字符在其内是不工作的，将会被直接打印出来,如以下代码将会输出&#8221;Hello world\n&#8221;。还有<strong>p</strong>方法也会输出换行符，并且还会将打印的内容按数据类型返回，而其他两种方法只返回<strong>nil</strong>空值。
<code>ruby
p "Hello world\n"  
</code></p>

<p><em>注:在Ruby中，任何函数均有返回值。<strong>nil</strong>空值就是其中一种常见的返回。</em></p>

<p><strong>print</strong>, <strong>puts</strong>和<strong>p</strong>方法均可传入多个参数，调用方式和返回结果如下，可以体会下用法:<br/>
<em>print方法</em>  <br/>
<code>ruby
print "Hello", " Ruby“
</code></p>

<pre><code>Hello Ruby
</code></pre>

<p><em>puts方法</em> <br/>
<code>ruby
puts "Hello", " Ruby"
</code></p>

<pre><code>Hello
Ruby
</code></pre>

<p><em>p方法</em>    <br/>
<code>ruby
p "Hello", " Ruby"
</code></p>

<pre><code>”Hello"
"Ruby"
</code></pre>

<h3>变量</h3>

<p>在ruby中声明变量也很简单，不需要任何如javascript的<em>var</em>等关键字，直接定义赋值。</p>

<pre><code class="ruby">greet = "Hello world"
</code></pre>

<p>访问变量也简单:</p>

<pre><code class="ruby">puts greet
puts "#{greet}"
</code></pre>

<p>以上两种写法均会直接输出Hello world.</p>

<h3>控制语句</h3>

<p><em>if 语句</em></p>

<pre><code>if 条件 then
    逻辑处理
end
</code></pre>

<p><em>if else 语句</em></p>

<pre><code>if 条件 then
    逻辑处理
else
    逻辑处理
end
</code></pre>

<p><em>if elsif 语句</em></p>

<pre><code>if 条件 then
    逻辑处理
elsif 条件 then
    逻辑处理
else
    逻辑处理
end
</code></pre>

<p><em>注:在上面的if各种控制语句中，<strong>then</strong>关键字是可以省略的.</em></p>

<h3>循环语句</h3>

<p><em>while 语句</em></p>

<pre><code>while 条件 do
    逻辑处理
end
</code></pre>

<p><em>times迭代器</em></p>

<p>当循环的次数已经确定时，可直接使用times方法来循环处理我们需要的逻辑
    I
    循环次数.times do
        逻辑处理
    end</p>

<p><em>注:<strong>times</strong>方法被成为迭代器，除了times方法迭代器，ruby还提供了其他的迭代器，比如<strong>each</strong>方法.</em></p>
]]></content>
  </entry>
  
</feed>
