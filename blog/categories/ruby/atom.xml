<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Stonefishy Blog]]></title>
  <link href="http://stonefishy.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://stonefishy.github.io/"/>
  <updated>2015-09-23T22:09:20+08:00</updated>
  <id>http://stonefishy.github.io/</id>
  <author>
    <name><![CDATA[Yu]]></name>
    <email><![CDATA[andrewsy@live.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(10)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/09/15/ruby-practice-10/"/>
    <updated>2015-09-15T15:18:16+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/09/15/ruby-practice-10</id>
    <content type="html"><![CDATA[<h3>块</h3>

<p><strong>块(block)</strong>，有时也称代码块，能与参数一起传递的多个处理的集合。像之前的<em>each</em>，<em>time</em>就是带块的方法。</p>

<pre><code class="ruby">(1..5).each do |i|
    puts i
end
</code></pre>

<p>上面代码中do和end之间的部分就是所谓的块。这样的方法称为“带块的方法”或“调用块”，其调用方式如下：</p>

<pre><code>对象.方法名(参数列表) do |变量|
    希望的处理
end

或者

对象.方法名(参数列表) { |变量|
    希望的处理
}
</code></pre>

<!-- more -->


<p>each方法可以将数组的元素一个一个取出来然后处理，散列也可以，但与数组不同的是，散列会将*[key,value]的组合作为数组来提取元素。</p>

<pre><code class="ruby">outcome = {"breakfast"=&gt;10.00, "lunch"=&gt;20.00, "dinner"=&gt;15.00 }
sum_outcome = 0
outcome.each do |pair|          #pair是key，value组成的数组，pair[0]为key，pair[1]为value
    sum_outcome += pair[1]
end

puts sum_outcome                    #=&gt; 45.0
</code></pre>

<p>在接收块变量时，多重赋值规则也同样适用。</p>

<pre><code class="ruby">outcome.each { |key, value|
    puts "#{key} : #{value}"    #=&gt; 打印对应的outcome信息
}
</code></pre>

<p>块除了应用于迭代器以外，还被广泛用于其他地方，其中一个就是确保后处理被执行。看代码</p>

<ul>
<li>(1)未使用块做后处理
<code>ruby file_open.rb
file = File.open("each_hash_data.rb")
file.each_line do |line|
  puts line
end
file.close
</code></li>
<li>(2)使用块做后处理
<code>ruby block_file_open.rb
File.open("each_hash_data.rb") do |file|
  file.each_line do |line|
      puts line
  end
end
</code>
仔细观察代码，你会发现在第种方式中，File#open方法接收了块，然后将file对象作为块变量，并且执行完毕后，并没有调用close方法去关闭文件。用这种方式会使程序出问题吗？答案是不会，因为块内部其实执行了如下代码的处理。</li>
</ul>


<pre><code class="ruby">file = File.open("each_hash_data.rb")
begin
    file.each_line do |line|
        puts line
    end
ensure
    file.close
end
</code></pre>

<p>块还有一种常见的用法，用于替换部分算法，以Array类的sort方法为例</p>

<pre><code class="ruby">ary = ["ruby", "pathon", "c#", "javascript"]

sorted_ary = ary.sort
print sorted_ary            #=&gt; ["c#", "javascript", "pathon", "ruby"]

sorted_ary = ary.sort { |a, b| a.length &lt;=&gt; b.length }
print sorted_ary            #=&gt; ["c#", "ruby", "pathon", "javascript"]

sorted_ary = ary.sort { |a, b| a.reverse &lt;=&gt; b.reverse}
print sorted_ary            #=&gt; ["c#", "pathon", "javascript", "ruby"]
</code></pre>

<p>将排序算法作为块传递给sort方法，然后返回按指定排序方式排序后的数组。</p>

<p><em>注意：块中最后一个表达式的值就是块的执行结果</em></p>

<h4>定义带块的方法</h4>

<p>使用<strong>yield</strong>关键字代替块，如下</p>

<pre><code class="ruby">def my_block
    yield
end

my_block do 
    puts "this is execution in my block"
end
</code></pre>

<h5>传递块参数，获取块的值</h5>

<pre><code class="ruby">def total(from, to)
    result = 0
    from.upto(to) do |num|
        if block_given?                 # 如果有快的话
            result += yield(num)        # 将经过块处理后的值累加
        else
            result += num
        end
    end
    result
end

print total(1, 10)                          #=&gt; 55
print total(1, 10) { |num| num * 2}     #=&gt; 110
</code></pre>

<p><strong>block_given?</strong>方法被用于判断当调用方法时是否有块被传递，有则返回true，否则false</p>

<p><em>yield</em>参数的个数可以与块变量的个数不一样，当块变量的个数多时，多出的参数会被赋值为nil，当块变量不足时，则不能接受多余的参数值。</p>

<p>*注：<strong>break</strong>和<strong>next</strong>方法可指定参数，如果没有指定任何参数，则返回nil，如果指定了参数则返回参数，如：break 0 和next 0 都会返回0。</p>

<h5>将块封装为对象</h5>

<p>Ruby还可以将块当作对象处理。把块当作对象处理后，就可以在接收块的方法之外的其他地方执行块，或者把块交给其他方法执行。如果要实现这样的功能，就需要<strong>Proc</strong>对象，<strong>Proc</strong>对象是能让块作为对象在程序中使用的类。</p>

<p>通过调用<strong>Proc.new</strong>这个带块的方法，可以定义Proc对象，然后再调用Proc对象的<strong>call</strong>方法执行块。</p>

<pre><code class="ruby">hello = Proc.new do |name|          # 使用Proc.new方法定义块对象hello
    puts "Hello #{name}"
end

hello.call("world")                 # 使用Proc.call方法调用块对象
hello.call("ruby")              
</code></pre>

<p>在方法定义时，如果末尾的参数使用<strong>&amp;参数名</strong>的形式，Ruby就会自动把调用方法时传进来的块封装为Proc对象。</p>

<pre><code class="ruby">def total(from, to, &amp;block)
    result = 0
    from.upto(to) do |num|
        if block                                #如果有块对象
            result += block.call(num)       #执行快对象
        else
            result += num
        end
    end
    result
end

puts total(1, 10)                           #=&gt; 55
puts total(1, 10) { |num| num * 2}      #=&gt; 110
</code></pre>

<p>在变量名前添加<strong>&amp;</strong>的参数被成为<strong>Proc参数</strong>. 而且Proc参数一定要在所有参数之后，也就是方法的最后一个参数。</p>

<p>将Proc对象作为块传递给其他方法处理，在调用方法时，用<strong>&amp;Proc对象</strong>的形式定义参数就可以了。</p>

<pre><code class="ruby">def my_each(ary, &amp;block)    
    ary.each(&amp;block)            #将proc对象以块的形式传递给数组的each方法
end

my_each([1, 2, 3]) do |i|
    print "#{i} "
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(9)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/09/09/ruby-practice-9/"/>
    <updated>2015-09-09T23:22:26+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/09/09/ruby-practice-9</id>
    <content type="html"><![CDATA[<h3>异常处理</h3>

<p>在Ruby中，抛出异常的信息格式如下：</p>

<pre><code>文件名：行号：in 方法名：错误信息 (异常类名)
        from 文件名：行号：in 方法名
</code></pre>

<p>以from开头的行表示发生错位的位置。
在Ruby中,使用<strong>begin ~ rescue ~ end</strong>语句来做异常处理，其语法如下：</p>

<pre><code>begin
    可能会发生异常的处理
rescue
    发生异常时的处理
end
</code></pre>

<pre><code class="ruby">begin
    1 / 0
rescue
    puts "has a exception"              #=&gt; has a exception
end
</code></pre>

<!-- more -->


<p>通过在<strong>rescue</strong>后指定变量名，可以获得异常对象。异常对象有两个方法，方法名为<strong>class</strong>、<strong>message</strong>、<strong>backtrace</strong>。</p>

<ul>
<li><strong>class</strong>方法可以获取到异常的种类</li>
<li><strong>message</strong>方法获取异常信息。</li>
<li><p><strong>backtrace</strong>方法获取异常发生的位置信息</p>

<p>  begin
      可能会发生的异常的处理
  rescue =>   引用异常对象的变量
      发生异常时的处理
  end</p></li>
</ul>


<pre><code class="ruby">begin
    1 / 0
rescue =&gt; ex                                #=&gt; 将异常对象引用到ex对象
    puts ex.class                           #=&gt; ZeroDivisionError
    puts ex.message                     #=&gt; divided by 0
    puts ex.backtrace                   #=&gt; exception.rb:2:in `/'exception.rb:2:in `&lt;main&gt;'
end
</code></pre>

<p><em>Note：此处是将代码直接写在ruby文件里，然后直接运行的，没有写在方法里面。所以看到的信息是文件名和发生错误的行号</em></p>

<p>如果不指定变量名，Ruby将会把异常对象赋值给<strong>$!</strong>、<strong>$2</strong>变量</p>

<ul>
<li><strong>$!</strong> 引用到最后发生的异常对象</li>
<li><strong>$@</strong> 引用到发生的异常的位置信息</li>
</ul>


<pre><code class="ruby">begin
    1 / 0
rescue
    puts $!.class                           #=&gt; ZeroDivisionError
    puts $!.message                     #=&gt; divided by 0
    puts $!.backtrace                   #=&gt; exception.rb:2:in `/'exception.rb:2:in `&lt;main&gt;'
    puts $@                             #=&gt; exception.rb:2:in `/'exception.rb:2:in `&lt;main&gt;'
end
</code></pre>

<p>从上面的运行示例可以看出，其实<strong>$!.backtrace</strong>与<strong>$@</strong>是等价的，都表示异常发生的位置。</p>

<p>在Ruby中可以通过<strong>ensure</strong>来确保无论是否引发异常都将执行处理，类似于Java和C#中得finally。</p>

<pre><code>begin
    可能发生的异常
rescue =&gt; 变量
    发生异常时的处理
ensure
    无论是否有异常，都会处理
end
</code></pre>

<pre><code class="ruby">def copy(from to)
    src = File.open(from)
    begin
        dst = File.open(to, 'w')
        data = src.read
        dst.write(data)
        dst.close
    rescue =&gt; ex
        print ex.message
    ensure
        src.close
    end
end
</code></pre>

<p>在<strong>rescue</strong>中使用<strong>retry</strong>后，<strong>begin</strong>以下的处理会再重做一遍。所以需要注意陷入死循环的情况。</p>

<pre><code class="ruby">count = 0
num = 0
begin
    1 / num                     #=&gt; 如果发生异常，则执行rescue中的语句
rescue
    if count &gt;= 5
        num += 1
    end

    count += 1

    retry                           #=&gt; 重复执行begin后的语句
end

puts count                      #=&gt; 6
</code></pre>

<h4>使用rescue做为修饰符</h4>

<p>使用rescue作为修饰符可以简化很多代码</p>

<pre><code>表达式1 rescue 表达式2
</code></pre>

<p>与下面的写法等价</p>

<pre><code>begin
    表达式1
rescue
    表达式2
end
</code></pre>

<p>其意义为如果表达式1中发生异常，表达式2的值就会成为整体表达式的值。</p>

<pre><code class="ruby">def parseInt(param)
    Integer(param) rescue 0     #=&gt; 如果Integer(param)语句无异常，直接返回该值，否者返回0
end

puts parseInt("123")            #=&gt; 123
puts parseInt("abc")            #=&gt; 0
</code></pre>

<p>在判断字符串是否为数值形式时，可以使用这种方法。</p>

<h4>异常处理的其他语法</h4>

<p><em>方法内</em>
如果异常处理的范围是整个方法体，这时可以省略begin以及end关键字，直接使用rescue和ensure。</p>

<pre><code>def 方法名
    方法体
rescue =&gt; 异常对象
    异常处理
ensure
    后处理
end
</code></pre>

<p><em>类定义中</em>
在类定义中也可以使用rescue以及ensure。但是，如果类定义途中发生异常，那么异常发生部分后的方法定义就不会再执行了。所以一般很少在类定义中使用。</p>

<pre><code>class 类名
    类定义
rescue =&gt; 异常对象
    异常处理
ensure
    后处理
end
</code></pre>

<h4>指定需要捕捉的异常</h4>

<p>当然，Ruby也提供了针对特定异常的捕捉处理，可以使用多个rescue来分开处理</p>

<pre><code>begin
    可能发生异常的地方
rescue Exception1, Exception2 =&gt;变量
    对Exception1或Exception2的处理
rescue Exception3 =&gt; 变量
    对Exception3的处理
rescue
    对上述异常以外的异常的处理
end
</code></pre>

<pre><code class="ruby">def multi_rescue 
    begin
        yield                   #块参数在此处，如有异常，将执行后续指定的异常处理
    rescue NameError, NoMethodError =&gt; ex
        puts ex.class
    rescue ZeroDivisionError
        puts $!.class
    rescue 
        puts $!.class
    end
end

multi_rescue do 
    1 / 0                           #触发ZeroDivisionError异常
end

multi_rescue do
    val.size                        #触发NameError异常
end

multi_rescue do 
    val = 4
    sqrt(val)                       #触发NoMethodError异常  
end
</code></pre>

<p>以上代码定义了一个带块的方法，通过此方法可以插入任何你想要得代码执行块。</p>

<h4>异常类</h4>

<p><em>注意：ruby中所有异常都是</em>Exception<em>类的子类。</em>
当rescue中不指定异常类时，程序会默认捕捉<em>StandardError</em>类及其子类的异常. 所以在定义自己的异常时，可以先定义继承StandardError类的新类，然后再继承这个新类。</p>

<pre><code class="ruby">MyError = Class.new(StandardError)

class MyError &lt; StandardError
end
</code></pre>

<p>上面两种写法是等效的，都是表示定义一个继承StandardError类的新类。第一种方式是一种简洁的写法。</p>

<pre><code class="ruby">MyError = Class.new(StandardError)      #自定义MyError异常

#自定义MyError1异常继承自MyError，并重写message方法
class MyError1 &lt; MyError
    def message
        "the exception message is from MyError1"
    end
end

#自定义MyError2异常继承自MyError，并重写message方法
class MyError2 &lt; MyError
    def message
        "the exception message is from MyError2"
    end
end

#定义带块的处理异常的方法
def raiseException
    yield
rescue MyError1 =&gt; ex
    puts ex.message
rescue MyError2 =&gt; ex
    puts ex.message
rescue
    puts $!.message
end

#抛出异常MyError1
raiseException do
    raise MyError1      #=&gt; the exception message is from MyError1      
end

#抛出异常MyError2   
raiseException do
    raise MyError2      #=&gt; the exception message is from MyError2
end
</code></pre>

<h4>抛出异常</h4>

<p>使用<strong>raise</strong>方法，可以使程序主动抛出异常。</p>

<p>raise方法有一下4中调用方式：</p>

<ul>
<li><p>raise message
抛出<em>RuntimeError</em>异常，并把字符串作为message设置给新生成的异常对象</p></li>
<li><p>raise 异常类
抛出指定的异常</p></li>
<li><p>raise 异常类，message
抛出指定的异常，并把message信息设置给新生成的异常对象</p></li>
<li><p>raise
在rescue外抛出RuntimeError。 在rescue中调用时，会再次抛出最后一次发生的异常。</p></li>
</ul>


<pre><code class="ruby">#自定义MyError3异常
MyError3 = Class.new(MyError

raiseException do
    raise MyError3, "customized message for MyError3"   #=&gt;抛出指定message
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(8)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/09/06/ruby-practice-8/"/>
    <updated>2015-09-06T20:36:07+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/09/06/ruby-practice-8</id>
    <content type="html"><![CDATA[<h3>运算符</h3>

<p>以下两种运算符是等价的, op即代表操作运算符</p>

<pre><code>value1 op= value2
value1 = value1 op value2
</code></pre>

<p>利用运算符<strong>||</strong>的特性，可以简化相关的赋值代码，如下是等价的
<code>ruby 赋值方式1
name = "Ruby"
if var              #当var不是nil或false时
    name = var
end
</code></p>

<pre><code class="ruby 赋值方式2">name = var || "Ruby"
</code></pre>

<!-- more -->


<p>而利用<strong>&amp;&amp;</strong>运算符，可以避免不必要要得程序错误</p>

<pre><code class="ruby 隐藏的错误">name = ary[0]          #如果ary为nil，则此时将引发程序错误
</code></pre>

<pre><code class="ruby 使用&&避免错误">name = ary &amp;&amp; ary[0]    #避免当ary为nil时，读取ary[0]时的错误
</code></pre>

<p>使用<strong>&amp;&amp;</strong>可以在确定对象存在后再调用方法。而且代码更加简洁。</p>

<h4>范围运算符</h4>

<p>相比其他的语言如Java等，范围运算符算是一个比较特殊的运算符，范围运算符有<strong>..</strong>和<strong>&hellip;</strong>两种，其区别在于如下</p>

<ul>
<li><strong>x..y</strong>的范围是从x到y</li>
<li><strong>x&hellip;y</strong>的范围是从x到y得前一个元素</li>
</ul>


<pre><code class="ruby">(1..5).to_a             #=&gt; [1, 2, 3, 4, 5]
("a".."d").to_a         #=&gt; ["a", "b", "c", "d"]

(1...5).to_a                #=&gt; [1, 2, 3, 4]
("a"..."d").to_a            #=&gt; ["a", "b", "c"]
</code></pre>

<p>Ruby中有范围对象(Range)来表示范围对象，以下两个写法是等价的</p>

<pre><code class="ruby">ary = Range.new(1, 5)   #=&gt; 1..5
ary.class                   #=&gt; Range


ary = 1..5              #=&gt; 1..5
ary.class                   #=&gt; Range
</code></pre>

<p>在Range对象内部，可以使用<strong>succ</strong>方法根据起点值逐个生成下一值</p>

<pre><code class="ruby">a = 1
a = a.succ                  #=&gt; 2
a = a.succ                  #=&gt; 3
a.succ.succ                 #=&gt; 5
</code></pre>

<h4>运算符重定义</h4>

<p>在Ruby中有以下运算符不能重定义
::, &amp;&amp;, ||, .., &hellip;, ?:, not, =, and</p>

<p><em>二元运算符重定义</em>,如加号+、减号-</p>

<pre><code class="ruby">class Point
    attr_reader :x, :y

    def initialize(x, y)
        @x, @y = x, y
    end

    def +(other)
        self.class.new(x + other.x, y + other.y)
    end

    def -(other)
        self.class.new(x - other.x, y - other.y)
    end

    def display
        "(#{x}, #{y})"
    end
end

p1 = Point.new(1, 2)
p2 = Point.new(3, 4)
p = p1 + p2
puts p.display                  #=&gt; (4, 6)

p = p2 - p1
puts p.display                  #=&gt; (2, 2)
</code></pre>

<p><em>一元运算符</em>，如正号+，负号-等，其重定义与二元运算符不同。可定义的一元运算符有<strong>+</strong>, <strong>-</strong>, <strong>~</strong>, <strong>!</strong>4个。分别以+@， -@， ~@， !@为方法名进行方法定义。而且一元运算符都是没有参数的。</p>

<pre><code class="ruby">class Point
    attr_reader :x, :y

    def initialize(x, y)
        @x, @y = x, y
    end

    def +@
        dup
    end

    def -@
        self.class.new(-x ,-y)
    end

    def ~@
        self.class.new(-y, x)
    end

    def display
        "(#{x}, #{y})"
    end
end

p1 = Point.new(1, 2)
puts (-p1).display              #=&gt; (-1, -2)
puts (+p1).display              #=&gt; (1, 2)
</code></pre>

<h4>下标方法</h4>

<p>数组、散列中的<em>obj[i]</em>以及<em>obj[i]=x</em>这样的方法，称为下标方法。定义下标方法时的方法名分别为<strong>[]</strong>和<strong>[]=</strong>.</p>

<pre><code class="ruby">class Point
    attr_reader :x, :y

    def initialize(x, y)
        @x, @y = x, y
    end

    def [](index)
        case index
        when 0
            x
        when 1
            y
        else
            raise ArgumentError, "out of range (#{index})"
        end
    end

    def []=(index, val)
        case index
        when 0
            self.x = val
        when 1
            self.y = val
        else
            raise ArgumentError, "out of range (#{index})"
        end
    end


    def display
        "(#{x}, #{y})"
    end
end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(7)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/09/01/ruby-practice-7/"/>
    <updated>2015-09-01T09:06:53+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/09/01/ruby-practice-7</id>
    <content type="html"><![CDATA[<h3>模块</h3>

<p>Ruby中的类是表现事物的属性和行为，那么模块呢？，在Ruby中<em>模块</em>表现的只是事物的行为。</p>

<p>模块与类的区别于下：</p>

<ul>
<li>模块不能拥有实例</li>
<li>模块不能被继承</li>
</ul>


<p>如何访问模块内的方法？有两种方式可以访问</p>

<p>1.使用<strong>模块名.方法名</strong>的形式来直接调用模块中定义的方法。</p>

<pre><code class="ruby">Math.sqrt(4)            #=&gt; 2.0
</code></pre>

<!-- more -->


<p>2.通过<strong>include 模块名</strong>的形式预先将模块引入到当前的命名空间，然后就可直接访问模块内的方法和常量。</p>

<pre><code class="ruby">include Math
sqrt(4)             #=&gt; 2.0
</code></pre>

<p>第二种方式也就是<strong>Mix-in</strong>扩展类的功能，将模块混合到类中。在定义类时使用<strong>include</strong>引入指定的模块后，此时该类就可以使用模块里的所有方法和常量，从而增加了该类的功能。</p>

<p><strong>Mix-in</strong>可以灵活地解决以下问题：</p>

<ul>
<li>虽然两个类拥有相似的功能，但是不希望把他们作为相同的种类（Class）来考虑的时候，此时可将相似功能封装为模块供这两个类使用</li>
<li>Ruby不支持父类的多重继承，因此无法对已经继承的类添加共同的功能的时候</li>
</ul>


<pre><code class="ruby">class Calculator
    include Math
    def my_sqrt(a, b)
        sqrt(a) + sqrt(b)           #=&gt; 调用Math模块中得sqrt方法
    end

    @@PI = PI
end

cal = Calculator.new
cal.my_sqrt(1, 4)                   #=&gt; 3.0
Calculator::PI                      #=&gt; 3.141592653589793
</code></pre>

<h4>创建模块</h4>

<p>使用<strong>module</strong>关键来创建模块，模块名的首字母必须大写</p>

<pre><code>module 模块名
    模块定义
end
</code></pre>

<pre><code class="ruby">module HelloModule
    Version = "1.0"

    def say_hello(name)
        puts "Hello #{name}"
    end

    module_function :say_hello
end

p HelloModule::Version                  #=&gt; "1.0"
HelloModule.say_hello("Ruby")           #=&gt; Hello Ruby

include HelloModule                     #=&gt; 包含模块
Version                                 #=&gt; "1.0"
say_hello("Ruby")                       #=&gt; Hello Ruby
</code></pre>

<p>在上面代码中，我们可以看到<strong>module_function</strong>方法，此方法主要用于将需要把模块函数公开给外部使用，其参数是表示方法方法名的符号，可以跟多个参数。</p>

<p><em>注：不建议在定义为模块函数的方法中使用self</em></p>

<h4>Mix-in</h4>

<p>前面提到的，在类中使用<em>include</em>引入模块，此时类的功能将得到增强。</p>

<p>如果想知道类是否包含某个模块，可以使用<strong>include？</strong>方法，如之前的Calculator类中。</p>

<pre><code class="ruby">Calculator.include?(Math)               #=&gt; true
</code></pre>

<p>Ruby中类的实例在调用方法时的顺序为，该类>包含的模块>该类的父类等这个顺序查找该方法。</p>

<pre><code class="ruby">module HelloModule
    Version = "1.0"

    def say_hello(name)
        puts "Hello #{name}"
    end
end

class HelloClass
    include HelloModule
end

hello = HelloClass.new
hello.say_hello("Ruby")                 #=&gt; Hello Ruby
</code></pre>

<p>以上代码中调用的是module中的方法。</p>

<p>用<em>ancestors</em>方法和<em>superclass</em>方法调查类的继承关系。<em>superclass</em>方法可直接返回类的父类</p>

<pre><code class="ruby">p HelloClass.ancestors                  #=&gt; [HelloClass, HelloModule, Object, Kernel, BasicObject]
p HelloClass.superclass                 #=&gt; Object
</code></pre>

<p><em>Kenerl</em>是Ruby内部的一个核心模块，Ruby程序运行时所需的共通函数都封装在此模块中。</p>

<p>单一继承的优点就是简单，不会因为过多的继承而导致类之间的关系变得复杂。所以我们需要灵活使用单一继承和Mix-in。</p>

<h4>Mix-in查找方法的规则</h4>

<ul>
<li>优先使用原来中定义的同名方法。</li>
<li>在同一个类中包含多个模块时，优先使用最后一个包含的模块。</li>
<li>嵌套include时，查找顺序也是线性的。</li>
<li>相同的模块被包含两次也上的，第2次以后的会被省略。</li>
</ul>


<h4>Object#extend方法</h4>

<p>利用Object#extend方法可以使单例类包含模块，并把模块的功能扩展到对象中。</p>

<pre><code class="ruby">module Welcome
    def welcome(name)
        "#{self} Welcome #{name}"
    end
end

str = "World"
str.extend(Welcome)                     #=&gt; 将Welcome模块扩展到str对象上
puts str.welcome("Ruby")                #=&gt; World Welcome Ruby
</code></pre>

<p><strong>include</strong>可以帮助我们突破继承的限制，通过模块扩展类的功能；而<strong>extend</strong>则可以帮助我们跨过类，直接通过模块扩展对象的功能.</p>

<p>所有类本身都是Class类的对象，类方法就是类对象的实例方法。可以把类方法理解为下:</p>

<ul>
<li><strong>Class</strong>类的实例方法</li>
<li>类对象的单例方法</li>
</ul>


<p>使用<strong>extend</strong>方法为类对象追加类方法，使用<strong>include</strong>方法追加实例方法。</p>

<pre><code class="ruby">module ClassMethod
    def class_method
        "class method"
    end
end

module InstanceMethod
    def instance_method
        "instance method"
    end
end

class MyClass
    extend ClassMethod                  #使用extend方法定义类方法
    include InstanceMethod              #使用include定义实例方法
end

p MyClass.class_method                  #=&gt; "class method"
p MyClass.new.instance_method           #=&gt; "instance method"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby修炼之道(5)]]></title>
    <link href="http://stonefishy.github.io/blog/2015/08/24/ruby-practice-5/"/>
    <updated>2015-08-24T15:22:56+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/08/24/ruby-practice-5</id>
    <content type="html"><![CDATA[<h3>方法</h3>

<p>在Ruby中，调用方法时是可以省略()的</p>

<pre><code class="ruby">&gt;&gt; print("Hello world")             #=&gt;Hello world
&gt;&gt; print "Hello world"              #=&gt;Hello world
</code></pre>

<p><em>带块的方法</em>
带块的方法如time,each方法，其语法如下：</p>

<pre><code>对象.方法名(参数，...) do |变量1，...|
    块内容
end
</code></pre>

<p>Ruby中方法可归为3类：</p>

<!-- more -->


<p><em>实例方法</em>
即由对象来调用，以下数组的size方法为实例方法</p>

<pre><code class="ruby">&gt;&gt; [1, 2].size                      #=&gt;size方法即为实例方法
</code></pre>

<p><em>类方法</em>
由类本身来调用，和C#、Java中得静态方法类似，类方法不属于任何一个对象</p>

<pre><code class="ruby">&gt;&gt; Array.new
&gt;&gt; File.open("some_file")
&gt;&gt; Time.now
</code></pre>

<p>调用类方法时，可以使用<strong>::</strong>代替<strong>.</strong></p>

<p><em>函数式方法</em></p>

<pre><code class="ruby">&gt;&gt; print "hello"
&gt;&gt; sleep(10)
</code></pre>

<p>在Ruby的帮助文档中，一般使用<strong>类名#方法名</strong>来标记实例方法，用<strong>类名.方法名</strong>或者<strong>类名::方法名</strong>来标记类方法</p>

<h4>方法的定义</h4>

<p>定义方法的语句如下:</p>

<pre><code>def 方法名(参数1，参数2,...)
    希望执行的处理
end
</code></pre>

<p>可以指定默认参数给方法，当方法有多个参数时，从参数列表的右边开始依次指定默认值</p>

<pre><code class="ruby">def func(a, b = 1, c = 2)
    #some codes
end
</code></pre>

<p><em>注，只省略左边的参数或中间的某个参数是不行的</em></p>

<p>方法的返回值使用<strong>return</strong>关键字，当这个关键字省略时，方法的最后一个表达式的结果就会成为方法的返回值。</p>

<p><em>定义带块的方法</em>
在定义带块的方法时，需要使用<strong>yield</strong>关键字来定义块所在的位置。如下代码所示</p>

<pre><code class="ruby">#定义
def func
    yield
end

#调用
func do
    print "hello world"
end
</code></pre>

<p>如果<strong>yield</strong>部分有参数，程序就会将其当作块变量传到块里。快里面最后的表达式的值即为快得执行结果，同时也可以作为<strong>yield</strong>的返回值在块的外部使用。</p>

<p><em>参数个数不确定的方法</em>
通过使用<strong>*变量名</strong>的形式来定义参数个数不确定的方法。Ruby会把所有的参数封装为数组，提供方法内部使用。</p>

<pre><code class="ruby">def func(*args)
    args
end

p func(1, 2, 3)             #=&gt; [1, 2, 3]
</code></pre>

<p>当方法需要指定特定的参数，而其他参数又不确定的情况下</p>

<pre><code class="ruby ">def sum(arg1, arg2, *args)
    result = arg1 + arg2
    args.each do | arg |
        result += arg
    end
    result
end

p sum(1, 2, 3, 4)           #=&gt; 10
</code></pre>

<p>所有不确定的参数都被作为数组赋值给变量args, <strong>*变量名</strong>这种形式的参数，只能在方法定义的参数列表中出现一次。</p>

<p><em>关键字参数</em>
使用关键字参数，可以将参数名与参数值成对地传给方法内部使用，这时，调用方法的参数个数以及调用顺序就可以打乱。</p>

<pre><code>def 方法名(参数1：值1, 参数2：值2, ...)
    逻辑处理
end
</code></pre>

<p>而且还可以在方法定义时指定参数默认值</p>

<pre><code class="ruby">def sum(a: 0, b: 0)
    a + b
end

p sum(a: 10, b: 20)         #=&gt; 30
p sum(b: 20, a: 10)         #=&gt; 30  改变参数的调用顺序
p sum(b: 20)                    #=&gt; 20 省略了参数a，a默认值为0
</code></pre>

<p>使用关键字参数定义方法，如果我们传入了未定义的参数，那么程序将会报错。如何避免呢，在Ruby中可以使用<strong>**变量名</strong>的形式来接收未定义的参数。此时，Ruby会把参数列表以外的其他关键字参数以散列对象的形式保存。</p>

<pre><code class="ruby ">def sum(a: 0, b: 0, **args)
    result = a + b
    args.each do |key, value|           #=&gt; 遍历散列
        result += value
    end
    result
end

sum(a: 1, b: 2, c: 3, d: 4)         #=&gt; 10
</code></pre>

<p>当然，关键字参数也可以与普通参数一起搭配使用。</p>

<pre><code class="ruby">def sum(a, b: 1, c: 2)
    sum = a + b + c
end

sum(10, b: 20, c: 30)           #=&gt; 60
</code></pre>

<p>以关键字参数定义的方法，Ruby会自动将其封装为散列然后传递给方法内部，所以基于此，我们当然也可以利用散列的键值来将散列传递给方法</p>

<pre><code class="ruby">def sum(a: 0, b: 0, c: 0)
    sum = a + b + c
end

args = {a: 1, b: 2, c: 3}           #=&gt; 定义散列args
sum(args)                               #=&gt; 6 将散列args传递给sum方法
sum({"a"=&gt;1, "b"=&gt;2, "c"=&gt;3}）     #=&gt; 6 将散列直接传给方法
sum(c: 3, a: 1, b: 2)               #=&gt; 6 可省略{}
</code></pre>

<p><em>使用关键字参数定义方法，既可以对键进行限制，又可以定义参数的默认值，建议在实际编程中多尝试使用关键字参数</em></p>
]]></content>
  </entry>
  
</feed>
