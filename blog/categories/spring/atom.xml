<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Spring | Stonefishy Blog]]></title>
  <link href="http://stonefishy.github.io/blog/categories/spring/atom.xml" rel="self"/>
  <link href="http://stonefishy.github.io/"/>
  <updated>2015-06-11T18:13:14+08:00</updated>
  <id>http://stonefishy.github.io/</id>
  <author>
    <name><![CDATA[Yu]]></name>
    <email><![CDATA[andrewsy@live.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Static Pointcut]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/11/spring-aop-static-pointcut/"/>
    <updated>2015-06-11T16:08:48+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/11/spring-aop-static-pointcut</id>
    <content type="html"><![CDATA[<p>Let&rsquo;s first to see the three very technical terms as below.</p>

<ul>
<li>Adivce - Indicate the action to take either before or after the method execution.</li>
<li>Pointcut - Indicate which method should be intercept, by method name or regular expression pattern.</li>
<li>Advisor - Group ‘Advice’ and ‘Pointcut’ into a single unit, and pass it to a proxy factory object</li>
</ul>


<!-- more -->


<h3>No pointcut example</h3>

<pre><code class="java MyLogicClass">package spring.test.aop;

public class MyLogicClass {

    public void logicMethodOne() {
        System.out.println("This is from logicMethodOne");
    }

    public void logicMethodTwo() {
        System.out.println("This is from logicMethodTwo");
    }

    public void testLogic() {
        System.out.println("This is from testLogic");
    }
}
</code></pre>

<pre><code class="java MyAroundAdvice.java">package spring.test.aop;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class MyAroundAdvice implements MethodInterceptor {

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("Before method execuation");

        Object result = invocation.proceed();

        System.out.println("After method execuation");

        return result;
    }

}
</code></pre>

<pre><code class="java App.java">package spring.test.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {

    private static ApplicationContext applicationContext;

    public static void main(String[] args) {

        applicationContext = new ClassPathXmlApplicationContext("springConfig.xml");

        MyLogicClass logicClass = (MyLogicClass)applicationContext.getBean("proxyFactoryBean");

        System.out.println("\n--------------------\n");
        logicClass.logicMethodOne();

        System.out.println("\n--------------------\n");
        logicClass.logicMethodTwo();

        System.out.println("\n--------------------\n");
        logicClass.testLogic();
        System.out.println("\n--------------------\n");

    }

}
</code></pre>

<pre><code class="xml">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;
    &lt;bean id="myAroundAdvice" class="spring.test.aop.MyAroundAdvice"/&gt;

    &lt;bean id="myLogicClass" class="spring.test.aop.MyLogicClass"/&gt;

    &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myAroundAdvice&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<pre><code class="text output">--------------------

Before method execuation
This is from logicMethodOne
After method execuation

--------------------

Before method execuation
This is from logicMethodTwo
After method execuation

--------------------

Before method execuation
This is from testLogic
After method execuation

--------------------
</code></pre>

<p>In above example, all logic methods of the class has been intercepted due to the application doesn&rsquo;t use the pointcut to specific.</p>

<h3>Name match example</h3>

<p>And now, we just want to intercept the method <em>testLogic</em>, so we need to create <strong>NameMatchMethodPointcut</strong> bean in spring config xml. and put the method name you want to intercept to the <strong>mappedName</strong> property value.</p>

<pre><code class="xml">&lt;bean id="nameMatchPointcut" class="org.springframework.aop.support.NameMatchMethodPointcut"&gt;
        &lt;property name="mappedName" value="testLogic"/&gt;
&lt;/bean&gt;
</code></pre>

<p>And also you can mapped multiple methods with <strong>mappedNames</strong>, like below.</p>

<pre><code class="xml">&lt;bean id="nameMatchPointcut" class="org.springframework.aop.support.NameMatchMethodPointcut"&gt;
        &lt;property name="mappedNames"&gt;
            &lt;list&gt;
                &lt;value&gt;logicMethodOne&lt;/value&gt;
                &lt;value&gt;logicMethodTwo&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
&lt;/bean&gt;
</code></pre>

<p>Then create <strong>DefaultPointcutAdvisor</strong> bean to group and associate the pointcut and advice.</p>

<pre><code class="xml">&lt;bean id="myPointcutAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor"&gt;
        &lt;property name="pointcut" ref="nameMatchPointcut"/&gt;
        &lt;property name="advice" ref="myAroundAdvice"/&gt;
&lt;/bean&gt;
</code></pre>

<p>Replace the <strong>interceptorNames</strong> of <strong>ProxyFactoryBean</strong> with the new Advisor.</p>

<pre><code class="xml">&lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myPointcutAdvisor&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
&lt;/bean&gt;
</code></pre>

<p>It&rsquo;s done, let&rsquo;s see the full spring config file and output.</p>

<pre><code class="xml springConfig.xml">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;
    &lt;bean id="myAroundAdvice" class="spring.test.aop.MyAroundAdvice"/&gt;

    &lt;bean id="myLogicClass" class="spring.test.aop.MyLogicClass"/&gt;

    &lt;bean id="nameMatchPointcut" class="org.springframework.aop.support.NameMatchMethodPointcut"&gt;
        &lt;property name="mappedName" value="testLogic"/&gt;
        &lt;!-- &lt;property name="mappedNames"&gt;
            &lt;list&gt;
                &lt;value&gt;logicMethodOne&lt;/value&gt;
                &lt;value&gt;logicMethodTwo&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt; --&gt;
    &lt;/bean&gt;

    &lt;bean id="myPointcutAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor"&gt;
        &lt;property name="pointcut" ref="nameMatchPointcut"/&gt;
        &lt;property name="advice" ref="myAroundAdvice"/&gt;
    &lt;/bean&gt;

    &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myPointcutAdvisor&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<pre><code class="text output">--------------------

This is from logicMethodOne

--------------------

This is from logicMethodTwo

--------------------

Before method execuation
This is from testLogic
After method execuation

--------------------
</code></pre>

<h3>Regular expression example</h3>

<p>Also we can use regular expression to match methods which should be intercepted. Create <strong>RegexpMethodPointcutAdvisor</strong> bean and set the <em>pattern</em> property value with regular expression and combine with advice.</p>

<pre><code class="xml ">&lt;bean id="regexPointcutAdvisor" class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"&gt;
        &lt;property name="pattern" value=".*Method.*"/&gt;

        &lt;property name="advice" ref="myAroundAdvice"/&gt;
&lt;/bean&gt;
</code></pre>

<p>And you can specific multiple patterns with <em>patterns</em> property.</p>

<pre><code class="xml ">&lt;bean id="regexPointcutAdvisor" class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"&gt;
        &lt;property name="patterns"&gt;
            &lt;list&gt;
                &lt;value&gt;.*Method.*&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;

        &lt;property name="advice" ref="myAroundAdvice"/&gt;
&lt;/bean&gt;
</code></pre>

<p>Finally pass the advisor to the <strong>ProxyFactoryBean</strong>.</p>

<pre><code class="xml">&lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;regexPointcutAdvisor&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
&lt;/bean&gt;
</code></pre>

<pre><code class="text output">--------------------

Before method execuation
This is from logicMethodOne
After method execuation

--------------------

Before method execuation
This is from logicMethodTwo
After method execuation

--------------------

This is from testLogic

--------------------
</code></pre>

<p>In practice, you can use it to manage DAO layer, where you can declare “.*DAO.*” to intercept all your DAO classes to support transaction.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Pointcut]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/10/spring-aop-pointcut/"/>
    <updated>2015-06-10T11:19:44+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/10/spring-aop-pointcut</id>
    <content type="html"><![CDATA[<p>What is <code>Pointcut</code> of Spring AOP? let&rsquo;s describe it. A <code>Pointcut</code> defines what <code>Advice</code>s are required at what <code>Join Point</code>s. In fact all business logic methods of the class are not required all services, that means each business logic method might require different service even some methods don&rsquo;t require. So Pointcut can informs IOC container that what business methods of a class needs what type of services.</p>

<!-- more -->


<p>There are two types of AOP:</p>

<ul>
<li>StaticMethodMatcherPointcut</li>
<li>DynamicMethodMatcherPointcut</li>
</ul>


<p>Pointcut verifys whether a particular method of particular class is eligible for getting the advice or not. Spring AOP has two static pointcut class.</p>

<ul>
<li>NameMatchMethodPointcut</li>
<li>RegexpMethodPointcutAdvisor</li>
</ul>


<p>In above two static pointcut class, they given by spring AOP framework. And they only verify whether the method name is matching with given condition or not, but they doesn&rsquo;t check whether the class names are matching or not. If you want to verify the class name, you can implement <code>StaticMethodMatcherPointcut</code> abstract class and override the <code>getClassFilter()</code>, <code>matches()</code> methods.</p>

<p>The dynamic pointcut is almost same with static pointcut, the only difference is that the dynamic pointcut can verify the arguments of the method at runtime, but static pointcut couldn&rsquo;t.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Join Point]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/09/spring-aop-joint-point/"/>
    <updated>2015-06-09T17:19:23+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/09/spring-aop-joint-point</id>
    <content type="html"><![CDATA[<p>In Spring AOP, while we create business logic of the method we usually need to inject the services at different places or points. So we call these places or points as <code>JoinPoint</code>.</p>

<p>At a join point place services will be injected at run time. And while executing business logic of method, the services can be injected in following 3 join points.</p>

<ul>
<li>Before business logic of method starts</li>
<li>After business logic of method complete</li>
<li>If business logic of method throws exception at run time.</li>
</ul>


<p>In a <code>join point</code>, many <code>Aspect</code>s(just name, not implementation) can be injected. Actually the <code>Advice</code>(the implementation of Aspect) is injected.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Throws Advice]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/08/spring-aop-throws-advice/"/>
    <updated>2015-06-08T14:39:43+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/08/spring-aop-throws-advice</id>
    <content type="html"><![CDATA[<p>In this type of Advice. This service executed when the logic method throws exceptions. To create Throws Advice, we should implement the interface called <code>ThrowsAdvice</code>.</p>

<p><code>ThrowsAdvice</code> is provided by <em>org.springframework.aop.*</em> package. But it has not any method we need to override.</p>

<!-- more -->


<p></p>

<p>While creating a ThrowsAdvice class in spring AOP, we should implement our services in a method called <code>afterThrowing()</code> with 1 or 4 parameter(s). In fact, this method not given in <code>ThrowsAdvice</code> interface, but we should implement our services in afterThrowing() method only because when ever an Exception is occurred in the business logic then the IOC container internally calls afterThrowing() method to apply the services.</p>

<p>Let&rsquo;s see the <code>afterThrowing()</code> method.</p>

<pre><code class="java ">package spring.test.aop;

import java.lang.reflect.Method;

import org.springframework.aop.ThrowsAdvice;

public class MyThrowsAdvice implements ThrowsAdvice {

    // just exception
    public void afterThrowing(Exception e) {

    }

    // specific null pointer exception
    public void afterThrowing(NullPointerException e) {

    }

    // with 4 parameters
    public void afterThrowing(Method method, Object[] args, Object target, Exception e) {

    }
}
</code></pre>

<p>If we write multiple afterThrowing methods in a class, then the <code>IOC</code> container will give the preference as below:</p>

<p>Specific exception > 4 parameters > just exception.</p>

<p>Let&rsquo;s take a practice.</p>

<pre><code class="java MyLogicInterface.java">package spring.test.aop;

public interface MyLogicInterface {
    void divide(int a, int b);
}
</code></pre>

<pre><code class="java MyLogicClass.java">package spring.test.aop;

public class MyLogicClass implements MyLogicInterface {

    @Override
    public void divide(int a, int b) {
        System.out.println(String.format("%s divide %s is %s\n", a, b, a / b));
    }

}
</code></pre>

<p>In our logic class. We print the message about one param divided by another one.</p>

<pre><code class="java MyThrowsAdvice.java">package spring.test.aop;

import java.lang.reflect.Method;

import org.springframework.aop.ThrowsAdvice;

public class MyThrowsAdvice implements ThrowsAdvice {

    // just exception
    public void afterThrowing(Exception e) {
        System.out.println("Exception: " + e.getMessage());
    }

    // specific exception
    public void afterThrowing(ArithmeticException e) {
        System.out.println("Specific ArithmeticException: " + e.getMessage());
    }

    // with 4 parameters
    public void afterThrowing(Method method, Object[] args, Object target, Exception e) {
        System.out.println("With 4 parameters exception: " + e.getMessage());
    }
}
</code></pre>

<p>There have three implementations of afterThrowing method. And also we can add our handle exception logic in them.</p>

<pre><code class="xml springConfig.xml">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;
    &lt;bean id="myThrowsAdvice" class="spring.test.aop.MyThrowsAdvice"/&gt;

    &lt;bean id="myLogicClass" class="spring.test.aop.MyLogicClass"/&gt;

    &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="proxyInterfaces" value="spring.test.aop.MyLogicInterface"/&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myThrowsAdvice&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<pre><code class="java App.java">package spring.test.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {

    private static ApplicationContext applicationContext;

    public static void main(String[] args) {
        applicationContext = new ClassPathXmlApplicationContext("springConfig.xml");
        MyLogicInterface myLogicInterface = (MyLogicInterface)applicationContext.getBean("proxyFactoryBean");

        myLogicInterface.divide(10, 5);

        myLogicInterface.divide(10, 0);
    }

}
</code></pre>

<p>In our client, we can see the divide method is called twice. The First one will not throw exception, but second will throw ArithmeticException.</p>

<p>Let&rsquo;s see the result of execution:</p>

<pre><code>10 divide 5 is 2

Exception in thread "main" Specific ArithmeticException: / by zero
</code></pre>

<p>We can see the specific ArithmeticException is executed. Okay, let us remove the specific exception method and run it again.</p>

<pre><code>10 divide 5 is 2

With 4 parameters exception: / by zero
</code></pre>

<p>The afterThrowing method with 4 parameters has been executed. Keep remove this method and run it.</p>

<pre><code>10 divide 5 is 2

Exception: / by zero
</code></pre>

<p>So there is only one afterThrowing method is executed when there have multiple implementation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Around Advice]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/08/spring-aop-around-advice/"/>
    <updated>2015-06-08T09:42:08+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/08/spring-aop-around-advice</id>
    <content type="html"><![CDATA[<p>In this blog, let us talk about <code>Around Advice</code>. There are some few points about it.</p>

<ul>
<li><code>Around Advice</code> is combination of <code>Before Advice</code> and <code>After Advice</code>.</li>
<li>In a single <code>Around Advice</code> we can implement both <em>before</em> and <em>after</em> services.</li>
<li><strong>Note</strong>, <code>Around Advice</code> is not given by <em>spring framework</em>, it is from <em>Open Source</em> implementation called <code>AOP</code> alliance.</li>
<li><code>Around Advice</code> can be used by any framework which supports <code>AOP</code>.</li>
<li><code>Around Advice</code> can access the return value of business method and it can modify the value and it can return a different value back to the client, as return type is Object, but in the <code>After Advice</code> its not possible right, as its return type is void.</li>
</ul>


<!-- more -->


<p>In order to create <code>Around Advice</code>, we should implement an interface called <code>MethodInterceptor</code> and override the method called <code>invoke</code> which has a prarameter <code>MethodInvocation</code> type. We can use this parameter to invoke our business logic method like <code>methodInvoation.proceed()</code>. And we can add our before services before this code execution and put after services after this code.</p>

<p>Let&rsquo;s see an instance.</p>

<pre><code class="java ">package spring.test.aop;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class MyAroundAdvice implements MethodInterceptor{

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        // Adding before service in here.

        invocation.proceed();

        // Adding after service in here.
        // we can change the return value we want via below return codes.

        return null;
    }

}
</code></pre>

<p>In above codes, we can see that we put the before services before the <code>proceed()</code> method and put the after services after it. and we can change the return value of the logic method.</p>

<p>So now let us to see a full expample.</p>

<pre><code class="java MyLogicInterface.java">package spring.test.aop;

public interface MyLogicInterface {
    int add(int a, int b);
}
</code></pre>

<pre><code class="java MyLogicClass.java">package spring.test.aop;

public class MyLogicClass implements MyLogicInterface {

    @Override
    public int add(int a, int b) {
        System.out.println(String.format("The internal result of %s + %s is: %s", a, b, a + b));
        return a + b;
    }

}
</code></pre>

<p>In our logic class, we print the result value before the return of method.</p>

<pre><code class="java MyAroundAdvice.java">package spring.test.aop;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class MyAroundAdvice implements MethodInterceptor {

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        // Adding before service
        methodDescription(invocation);

        Object currentResult = invocation.proceed();

        // Adding after service.
        Object changedResult = changedReturnValue(invocation);

        return changedResult == null ? currentResult : changedResult;
    }

    private void methodDescription(MethodInvocation invocation) {
        String methodName = invocation.getMethod().getName();
        Object[] args = invocation.getArguments();

        String description = String.format("Before Services : %s(%s, %s)",
                methodName, args[0], args[1]);
        System.out.println(description);
    }

    private Object changedReturnValue(MethodInvocation invocation) {
        Object[] args = invocation.getArguments();
        int secondParam = (int) args[1];

        // changed the return value to 0 when the second parameter is less than 0.
        if (secondParam &lt; 0)
            return 0;

        return null;
    }

}
</code></pre>

<p>In this our around advice. we print the method description in our before service and changed the return value to 0 when the second parameter is less than 0 in after service.</p>

<pre><code class="xml springConfig.xml">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;
    &lt;bean id="myAroundAdvice" class="spring.test.aop.MyAroundAdvice"/&gt;

    &lt;bean id="myLogicClass" class="spring.test.aop.MyLogicClass"/&gt;

    &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="proxyInterfaces" value="spring.test.aop.MyLogicInterface"/&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myAroundAdvice&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>The spring config xml is same with before except the interceptorNames.</p>

<pre><code class="java App.java">package spring.test.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {

    private static ApplicationContext applicationContext;

    public static void main(String[] args) {
        applicationContext = new ClassPathXmlApplicationContext("springConfig.xml");
        MyLogicInterface logicInterface = (MyLogicInterface)applicationContext.getBean("proxyFactoryBean");

        int result1 = logicInterface.add(1, 10);
        System.out.println(String.format("After Advice - The result is: %s \n", result1));

        int result2 = logicInterface.add(1, -10);
        System.out.println(String.format("After Advice - The result is: %s", result2));
    }

}
</code></pre>

<p>You will notice that we pass -10 to second parameter in second times method called. Let&rsquo;s see the result:</p>

<pre><code>Before Services : add(1, 10)
The internal result of 1 + 10 is: 11
After Advice - The result is: 11 

Before Services : add(1, -10)
The internal result of 1 + -10 is: -9
After Advice - The result is: 0
</code></pre>

<p>You see, the internal result is -9, but after service, the result is changed to 0. So the return value is changed by our <code>Around Advice</code>.</p>

<p><em><strong>Note again:</strong> The <code>Around Advice</code> can change the return value of business logic method, but <code>After Advice</code> cannot.</em></p>
]]></content>
  </entry>
  
</feed>
