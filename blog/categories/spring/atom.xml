<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Spring | Stonefishy Blog]]></title>
  <link href="http://stonefishy.github.io/blog/categories/spring/atom.xml" rel="self"/>
  <link href="http://stonefishy.github.io/"/>
  <updated>2015-06-09T18:01:34+08:00</updated>
  <id>http://stonefishy.github.io/</id>
  <author>
    <name><![CDATA[Yu]]></name>
    <email><![CDATA[andrewsy@live.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Join Point]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/09/spring-aop-joint-point/"/>
    <updated>2015-06-09T17:19:23+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/09/spring-aop-joint-point</id>
    <content type="html"><![CDATA[<p>In Spring AOP, while we create business logic of the method we usually need to inject the services at different places or points. So we call these places or points as <code>JoinPoint</code>.</p>

<p>At a join point place services will be injected at run time. And while executing business logic of method, the services can be injected in following 3 join points.</p>

<ul>
<li>Before business logic of method starts</li>
<li>After business logic of method complete</li>
<li>If business logic of method throws exception at run time.</li>
</ul>


<p>In a <code>join point</code>, many <code>Aspect</code>s(just name, not implementation) can be injected. Actually the <code>Advice</code>(the implementation of Aspect) is injected.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Throws Advice]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/08/spring-aop-throws-advice/"/>
    <updated>2015-06-08T14:39:43+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/08/spring-aop-throws-advice</id>
    <content type="html"><![CDATA[<p>In this type of Advice. This service executed when the logic method throws exceptions. To create Throws Advice, we should implement the interface called <code>ThrowsAdvice</code>.</p>

<p><code>ThrowsAdvice</code> is provided by <em>org.springframework.aop.*</em> package. But it has not any method we need to override.</p>

<!-- more -->


<p></p>

<p>While creating a ThrowsAdvice class in spring AOP, we should implement our services in a method called <code>afterThrowing()</code> with 1 or 4 parameter(s). In fact, this method not given in <code>ThrowsAdvice</code> interface, but we should implement our services in afterThrowing() method only because when ever an Exception is occurred in the business logic then the IOC container internally calls afterThrowing() method to apply the services.</p>

<p>Let&rsquo;s see the <code>afterThrowing()</code> method.</p>

<pre><code class="java ">package spring.test.aop;

import java.lang.reflect.Method;

import org.springframework.aop.ThrowsAdvice;

public class MyThrowsAdvice implements ThrowsAdvice {

    // just exception
    public void afterThrowing(Exception e) {

    }

    // specific null pointer exception
    public void afterThrowing(NullPointerException e) {

    }

    // with 4 parameters
    public void afterThrowing(Method method, Object[] args, Object target, Exception e) {

    }
}
</code></pre>

<p>If we write multiple afterThrowing methods in a class, then the <code>IOC</code> container will give the preference as below:</p>

<p>Specific exception > 4 parameters > just exception.</p>

<p>Let&rsquo;s take a practice.</p>

<pre><code class="java MyLogicInterface.java">package spring.test.aop;

public interface MyLogicInterface {
    void divide(int a, int b);
}
</code></pre>

<pre><code class="java MyLogicClass.java">package spring.test.aop;

public class MyLogicClass implements MyLogicInterface {

    @Override
    public void divide(int a, int b) {
        System.out.println(String.format("%s divide %s is %s\n", a, b, a / b));
    }

}
</code></pre>

<p>In our logic class. We print the message about one param divided by another one.</p>

<pre><code class="java MyThrowsAdvice.java">package spring.test.aop;

import java.lang.reflect.Method;

import org.springframework.aop.ThrowsAdvice;

public class MyThrowsAdvice implements ThrowsAdvice {

    // just exception
    public void afterThrowing(Exception e) {
        System.out.println("Exception: " + e.getMessage());
    }

    // specific exception
    public void afterThrowing(ArithmeticException e) {
        System.out.println("Specific ArithmeticException: " + e.getMessage());
    }

    // with 4 parameters
    public void afterThrowing(Method method, Object[] args, Object target, Exception e) {
        System.out.println("With 4 parameters exception: " + e.getMessage());
    }
}
</code></pre>

<p>There have three implementations of afterThrowing method. And also we can add our handle exception logic in them.</p>

<pre><code class="xml springConfig.xml">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;
    &lt;bean id="myThrowsAdvice" class="spring.test.aop.MyThrowsAdvice"/&gt;

    &lt;bean id="myLogicClass" class="spring.test.aop.MyLogicClass"/&gt;

    &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="proxyInterfaces" value="spring.test.aop.MyLogicInterface"/&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myThrowsAdvice&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<pre><code class="java App.java">package spring.test.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {

    private static ApplicationContext applicationContext;

    public static void main(String[] args) {
        applicationContext = new ClassPathXmlApplicationContext("springConfig.xml");
        MyLogicInterface myLogicInterface = (MyLogicInterface)applicationContext.getBean("proxyFactoryBean");

        myLogicInterface.divide(10, 5);

        myLogicInterface.divide(10, 0);
    }

}
</code></pre>

<p>In our client, we can see the divide method is called twice. The First one will not throw exception, but second will throw ArithmeticException.</p>

<p>Let&rsquo;s see the result of execution:</p>

<pre><code>10 divide 5 is 2

Exception in thread "main" Specific ArithmeticException: / by zero
</code></pre>

<p>We can see the specific ArithmeticException is executed. Okay, let us remove the specific exception method and run it again.</p>

<pre><code>10 divide 5 is 2

With 4 parameters exception: / by zero
</code></pre>

<p>The afterThrowing method with 4 parameters has been executed. Keep remove this method and run it.</p>

<pre><code>10 divide 5 is 2

Exception: / by zero
</code></pre>

<p>So there is only one afterThrowing method is executed when there have multiple implementation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Around Advice]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/08/spring-aop-around-advice/"/>
    <updated>2015-06-08T09:42:08+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/08/spring-aop-around-advice</id>
    <content type="html"><![CDATA[<p>In this blog, let us talk about <code>Around Advice</code>. There are some few points about it.</p>

<ul>
<li><code>Around Advice</code> is combination of <code>Before Advice</code> and <code>After Advice</code>.</li>
<li>In a single <code>Around Advice</code> we can implement both <em>before</em> and <em>after</em> services.</li>
<li><strong>Note</strong>, <code>Around Advice</code> is not given by <em>spring framework</em>, it is from <em>Open Source</em> implementation called <code>AOP</code> alliance.</li>
<li><code>Around Advice</code> can be used by any framework which supports <code>AOP</code>.</li>
<li><code>Around Advice</code> can access the return value of business method and it can modify the value and it can return a different value back to the client, as return type is Object, but in the <code>After Advice</code> its not possible right, as its return type is void.</li>
</ul>


<!-- more -->


<p>In order to create <code>Around Advice</code>, we should implement an interface called <code>MethodInterceptor</code> and override the method called <code>invoke</code> which has a prarameter <code>MethodInvocation</code> type. We can use this parameter to invoke our business logic method like <code>methodInvoation.proceed()</code>. And we can add our before services before this code execution and put after services after this code.</p>

<p>Let&rsquo;s see an instance.</p>

<pre><code class="java ">package spring.test.aop;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class MyAroundAdvice implements MethodInterceptor{

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        // Adding before service in here.

        invocation.proceed();

        // Adding after service in here.
        // we can change the return value we want via below return codes.

        return null;
    }

}
</code></pre>

<p>In above codes, we can see that we put the before services before the <code>proceed()</code> method and put the after services after it. and we can change the return value of the logic method.</p>

<p>So now let us to see a full expample.</p>

<pre><code class="java MyLogicInterface.java">package spring.test.aop;

public interface MyLogicInterface {
    int add(int a, int b);
}
</code></pre>

<pre><code class="java MyLogicClass.java">package spring.test.aop;

public class MyLogicClass implements MyLogicInterface {

    @Override
    public int add(int a, int b) {
        System.out.println(String.format("The internal result of %s + %s is: %s", a, b, a + b));
        return a + b;
    }

}
</code></pre>

<p>In our logic class, we print the result value before the return of method.</p>

<pre><code class="java MyAroundAdvice.java">package spring.test.aop;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;

public class MyAroundAdvice implements MethodInterceptor {

    @Override
    public Object invoke(MethodInvocation invocation) throws Throwable {
        // Adding before service
        methodDescription(invocation);

        Object currentResult = invocation.proceed();

        // Adding after service.
        Object changedResult = changedReturnValue(invocation);

        return changedResult == null ? currentResult : changedResult;
    }

    private void methodDescription(MethodInvocation invocation) {
        String methodName = invocation.getMethod().getName();
        Object[] args = invocation.getArguments();

        String description = String.format("Before Services : %s(%s, %s)",
                methodName, args[0], args[1]);
        System.out.println(description);
    }

    private Object changedReturnValue(MethodInvocation invocation) {
        Object[] args = invocation.getArguments();
        int secondParam = (int) args[1];

        // changed the return value to 0 when the second parameter is less than 0.
        if (secondParam &lt; 0)
            return 0;

        return null;
    }

}
</code></pre>

<p>In this our around advice. we print the method description in our before service and changed the return value to 0 when the second parameter is less than 0 in after service.</p>

<pre><code class="xml springConfig.xml">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;
    &lt;bean id="myAroundAdvice" class="spring.test.aop.MyAroundAdvice"/&gt;

    &lt;bean id="myLogicClass" class="spring.test.aop.MyLogicClass"/&gt;

    &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="proxyInterfaces" value="spring.test.aop.MyLogicInterface"/&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myAroundAdvice&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>The spring config xml is same with before except the interceptorNames.</p>

<pre><code class="java App.java">package spring.test.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {

    private static ApplicationContext applicationContext;

    public static void main(String[] args) {
        applicationContext = new ClassPathXmlApplicationContext("springConfig.xml");
        MyLogicInterface logicInterface = (MyLogicInterface)applicationContext.getBean("proxyFactoryBean");

        int result1 = logicInterface.add(1, 10);
        System.out.println(String.format("After Advice - The result is: %s \n", result1));

        int result2 = logicInterface.add(1, -10);
        System.out.println(String.format("After Advice - The result is: %s", result2));
    }

}
</code></pre>

<p>You will notice that we pass -10 to second parameter in second times method called. Let&rsquo;s see the result:</p>

<pre><code>Before Services : add(1, 10)
The internal result of 1 + 10 is: 11
After Advice - The result is: 11 

Before Services : add(1, -10)
The internal result of 1 + -10 is: -9
After Advice - The result is: 0
</code></pre>

<p>You see, the internal result is -9, but after service, the result is changed to 0. So the return value is changed by our <code>Around Advice</code>.</p>

<p><em><strong>Note again:</strong> The <code>Around Advice</code> can change the return value of business logic method, but <code>After Advice</code> cannot.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - After Advice]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/06/spring-aop-after-advice/"/>
    <updated>2015-06-06T10:14:46+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/06/spring-aop-after-advice</id>
    <content type="html"><![CDATA[<p><code>Advice</code> is the implementation of the <code>cross-cutting</code> functionality. An <code>Adivce</code> provides the code for implementation of the service.</p>

<p>There are four types of Advice:</p>

<ul>
<li>Before Advice</li>
<li><strong>After Advice</strong></li>
<li>Around Advice</li>
<li>Throws Advice</li>
</ul>


<!-- more -->


<p><code>After Advice</code> is same as <code>Before Advice</code>. But in order to create our after advice in spring, our class should implement an interface called <code>AfterReturningAdvice</code>, this interface is given in <em>org.springframework.aop.*</em> package. And we need to override a method given by this interface called <code>afterReturning()</code>.</p>

<pre><code class="java">public class MyAfterAdvice implements AfterReturningAdvice {

    @Override
    public void afterReturning(Object returnValue, Method method,
            Object[] args, Object target) throws Throwable {
        // TODO Auto-generated method stub

    }

}
</code></pre>

<p>The <em>returnValuef</em> is the return value of the logic method, we can use it to access the return of the logic function. The <em>method</em> parameter is the logic method, we can use <em>getName()</em> to access the name of method. And the <em>args</em> parameter is arguments of logic method.</p>

<p>Let&rsquo;s see full example.</p>

<pre><code class="java ">package spring.test.aop;

public interface MyLogicInterface {
    int add(int a, int b);

    int subtract(int a, int b);
}
</code></pre>

<p>In this interface, we changed the method&rsquo;s signature, we have return value for both two method.</p>

<pre><code class="java">package spring.test.aop;

public class MyLogicClass implements MyLogicInterface {

    @Override
    public int add(int a, int b) {
        return a + b;
    }

    @Override
    public int subtract(int a, int b) {
        return a - b;
    }

}
</code></pre>

<p>In <em>MyLogicClass</em>, we implemented the two methods <em>add</em> and <em>subtract</em>, and return the value.
&#8220;` java
package spring.test.aop;</p>

<p>import java.lang.reflect.Method;</p>

<p>import org.springframework.aop.AfterReturningAdvice;</p>

<p>public class MyAfterAdvice implements AfterReturningAdvice {</p>

<pre><code>@Override
public void afterReturning(Object returnValue, Method method,
        Object[] args, Object target) throws Throwable {

    String message = String.format(
            "The result from method %s(%s, %s) is: %s", method.getName(),
            args[0], args[1], returnValue);

    System.out.println(message);

}
</code></pre>

<p>}
<code>``
We print all the messages of the logic method in our</code>After Advice`, include method name, the return value of method, the arguments etc.</p>

<p>Okay, let&rsquo;s see our spring config file.</p>

<pre><code class="java">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;
    &lt;bean id="myAfterAdvice" class="spring.test.aop.MyAfterAdvice"/&gt;

    &lt;bean id="myLogicClass" class="spring.test.aop.MyLogicClass"/&gt;

    &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="proxyInterfaces" value="spring.test.aop.MyLogicInterface"/&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myAfterAdvice&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>It is same with last spring config file of <code>Before After</code>. We just use <em>MyAfterAdvice</em> to instead of <em>MyBeforeAdvice</em>.</p>

<p>To make this application run, we should read spring config file.</p>

<pre><code class="java">package spring.test.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {

    private static ApplicationContext applicationContext;

    public static void main(String[] args) {
        applicationContext = new ClassPathXmlApplicationContext("springConfig.xml");
        MyLogicInterface myLogicInterface = (MyLogicInterface)applicationContext.getBean("proxyFactoryBean");

        myLogicInterface.add(10, 20);
        myLogicInterface.subtract(10, 5);
    }

}
</code></pre>

<p>The result of the application executioin.</p>

<pre><code>The result from method add(10, 20) is: 30
The result from method subtract(10, 5) is: 5
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring AOP - Before Advice]]></title>
    <link href="http://stonefishy.github.io/blog/2015/06/05/spring-aop-before-advice/"/>
    <updated>2015-06-05T15:33:00+08:00</updated>
    <id>http://stonefishy.github.io/blog/2015/06/05/spring-aop-before-advice</id>
    <content type="html"><![CDATA[<p>As we know the <code>Aspect</code> is just the name of the <code>cross-cutting</code> functionality, not the implementation. So what&rsquo;s the implementation of the <code>cross-cutting</code> functionality? It&rsquo;s called <code>Advice</code>. An <code>Advice</code> provides the code for implementation of the service. It is like <em>Logging</em> service, <em>Logging</em> is a <code>Aspect</code> and <code>Advice</code> denotes the implementation of <em>Log4j</em>.</p>

<!-- more -->


<p>There are four types of <code>Adivce</code>:</p>

<ul>
<li><strong>Before Advice</strong></li>
<li>After Advice</li>
<li>Around Advice</li>
<li>Throws Advice</li>
</ul>


<p>In this article, we only explain <code>Before Advice</code>. The other advices we will talk about it in later blogs.</p>

<p>The <code>Before Advice</code> is the implementation of the service. It will be applied before the business logic of method is going to execute. So this means this advice will execute before the business logic. we can use it to do something like authentication before the business logic execution.</p>

<p>It will be applied in the runtime of application, not the compilation of the code. And also it will generate a new <em>proxy</em> class which is combined by this advice and business logic class in the runtime automatically.</p>

<p>When we create a <code>Before Advice</code>, we should implement the <code>MethodBeforeAdvice</code> interface, this interface is given by <em>org.springframework.aop.*</em> package. And then we need to override the <code>before</code> method of it.</p>

<pre><code class="java">package spring.test.aop;

import java.lang.reflect.Method;

import org.springframework.aop.MethodBeforeAdvice;

public class MyBeforeAdvice implements MethodBeforeAdvice {

    @Override
    public void before(Method method, Object[] args, Object target)
            throws Throwable {
        // TODO Auto-generated method stub

    }

}
</code></pre>

<p>There are 3 parameters in the <em>before</em> method.</p>

<p>The first parameter <em><code>Method</code> method</em> is used to access the method name of the business logic via <code>getName()</code>.</p>

<p>The second parameter <em>Object[] args</em> is Object array, it is used to access the arguments of the logic method.</p>

<p>The last parameter <em>Object target</em> is an object to whom this service will be going to apply, usually this will taken care by <em>container</em>, actually we no need to care it.</p>

<p>Okay, let&rsquo;s see a full example.</p>

<pre><code class="xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
            &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;
            &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;
            &lt;version&gt;4.1.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>

<p>In the pom.xml file, we add above dependencies to our project. (this project use maven to manage)</p>

<p>Okay, let us create our logic class, firstly we need to create interface for it.</p>

<pre><code class="java">package spring.test.aop;

public interface MyLogicInterface {
    void add(int a, int b);

    void subtract(int a, int b);
}
</code></pre>

<p>We created two method in this interface, this interface is very important for our <code>AOP</code> project.</p>

<pre><code class="java">package spring.test.aop;

public class MyLogicClass implements MyLogicInterface {

    @Override
    public void add(int a, int b) {
        String result = String.format("%s + %s = %s", a, b, a + b);
        System.out.println(result);
    }

    @Override
    public void subtract(int a, int b) {
        String result = String.format("%s - %s = %s", a, b, a - b);
        System.out.println(result);
    }

}
</code></pre>

<p>Our class implements the interface, just print the result of the add or subtract.</p>

<p>For now, we have our logic class. but now we want to do something before the method logic is going to execute. So the <code>Before Advice</code> is comming.</p>

<pre><code class="java">package spring.test.aop;

import java.lang.reflect.Method;

import org.springframework.aop.MethodBeforeAdvice;

public class MyBeforeAdvice implements MethodBeforeAdvice {

    @Override
    public void before(Method method, Object[] args, Object target) throws Throwable {
        System.out.println(String.format("This will be executed before the %s method", method.getName()));
    }
}
</code></pre>

<p>We print some messages in our <code>Before Advice</code>, this will be printed before the logic method result.</p>

<p>Finally, we need to make the logic class and our <code>Before Advice</code> are combined together. so we need to config them in the xml file.</p>

<pre><code class="xml">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
            "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;
    &lt;bean id="myBeforeAdvice" class="spring.test.aop.MyBeforeAdvice"/&gt;

    &lt;bean id="myLogicClass" class="spring.test.aop.MyLogicClass"/&gt;

    &lt;bean id="proxyFactoryBean" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
        &lt;property name="proxyInterfaces" value="spring.test.aop.MyLogicInterface"/&gt;
        &lt;property name="interceptorNames"&gt;
            &lt;list&gt;
                &lt;value&gt;myBeforeAdvice&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="target" ref="myLogicClass"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>In <code>AOP</code> always we need to create a spring bean in the form of interface and implementation class only, because the IOC container internally creates proxy class by implementing that interface with the help of <code>ProxyFactoryBean</code>.
To run this application, we need a class which with <em>main</em> method. See below codes.</p>

<pre><code class="java">package spring.test.aop;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class App {

    private static ApplicationContext applicationContext;

    public static void main(String[] args) {
        applicationContext = new ClassPathXmlApplicationContext("springConfig.xml");
        MyLogicInterface myLogicInterface = (MyLogicInterface)applicationContext.getBean("proxyFactoryBean");

        myLogicInterface.add(10, 20);
        myLogicInterface.subtract(10, 5);
    }

}
</code></pre>

<p>In the client application, we are passing id of <code>ProxyFactoryBean</code> (proxyFactoryBean) to get the object, because we need proxyed object to invoke our logic method.</p>

<p>The result of the execution is below:</p>

<pre><code>This will be executed before the add method
10 + 20 = 30
This will be executed before the subtract method
10 - 5 = 5
</code></pre>

<p>So, it is simple to use it. and we separated the logic and the services completely, only need to config the xml file when the services changed.</p>
]]></content>
  </entry>
  
</feed>
